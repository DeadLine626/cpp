#include <string>
#include <fstream>
#include <iostream>
#include <vector>
#include "enet/include/enet.h"
#include <nlohmann/json.hpp>
#include "alfa/Item.h"
#include "alfa/Base.h"
#include "alfa/Player.h"
#include "alfa/Packet.h"
#include "alfa/Guilds.h"
#include "alfa/World.h"
#include "alfa/Algorithm.h"
#include "proton/Variant.hpp"
#include "proton/Vector.hpp"
#pragma comment(lib, "Ws2_32.lib")
BOOL WINAPI ConsoleHandler(DWORD dwType)
{
	switch (dwType) {
	case CTRL_LOGOFF_EVENT: case CTRL_SHUTDOWN_EVENT: case CTRL_CLOSE_EVENT:
	{
		trigger_save_();
		return TRUE;
	}
	default:
	{
		break;
	}
	}
	return FALSE;
}
vector<string> split_string_by_newline(const string& str)
{
	auto result = vector<string>{};
	auto ss = stringstream{ str };

	for (string line; getline(ss, line, '\n');)
		result.push_back(line);

	return result;
}

//ENetPeer* peer
long long last_time = 0, last_guild_save = time(NULL) + 60, last_time_ = 0, last_time2_ = 0, last_world_menu = 0, last_honors_reset = 0, autofarm_delay = 0, last_autofarm = 0, last_bot = 0, last_hm_time = 0, last_growganoth_time = 0;
void loop_spammer() {
	while (true) {
		std::this_thread::sleep_for(seconds(3)); // 5 Seconds
		try {
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world.empty() or pInfo(currentPeer)->tankIDName.empty()) continue;
				string name_ = pInfo(currentPeer)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					if (pInfo(currentPeer)->npc_summon) {
						if (pInfo(currentPeer)->npc_text != "") {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(currentPeer)->npc_netID);
							p.Insert(pInfo(currentPeer)->npc_text);
							p.Insert(0), p.Insert(0);

							gamepacket_t p2;
							p2.Insert("OnConsoleMessage");
							p2.Insert("CP:_PL:0_OID:_CT:[W]_ `6<`w" + pInfo(currentPeer)->npc_name + "`6> " + pInfo(currentPeer)->npc_text + "");

							for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
								if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
								if (pInfo(currentPeer2)->world != pInfo(currentPeer2)->npc_world) continue;

								p.CreatePacket(currentPeer2);
								p2.CreatePacket(currentPeer2);
							}
						}
					}
				}
			}

		}


		catch (const std::out_of_range& e) {
			std::cout << e.what() << std::endl;
		}
	}
}
void loop_cheat(ENetPeer* peer) {
	long long ms_time = duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
	try {
		if (autofarm_delay - ms_time <= 0) {
			autofarm_delay = ms_time + 400;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world.empty() or pInfo(currentPeer)->tankIDName.empty()) continue;
				if (not has_playmod(pInfo(currentPeer), "Cheat Active: Auto Farm") && pInfo(currentPeer)->slave.active == 0) continue;
				bool isRemote = pInfo(currentPeer)->isRemote;
				// Auto Farm
				string name_ = pInfo(currentPeer)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (pInfo(currentPeer)->Cheat_AF_PlantingTree != 0 and pInfo(currentPeer)->Cheat_AF_isRunning) {
						string name_ = pInfo(currentPeer)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							WorldBlock* block_ = &world_->blocks[pInfo(currentPeer)->Cheat_AF_PunchX + (pInfo(currentPeer)->Cheat_AF_PunchY * 100)];
							if (block_->fg == 0 and block_->bg == 0) {
								if (items[pInfo(currentPeer)->Cheat_AF_PlantingTree].blockType == BlockTypes::CLOTHING) {
									pInfo(currentPeer)->Cheat_AF_PlantingTree = 0;
									break;
								}
								{
									for (ENetPeer* peer = server->peers; peer < &server->peers[server->peerCount]; ++peer) {
										if (peer->state != ENET_PEER_STATE_CONNECTED or peer->data == NULL) continue;
										string name = pInfo(peer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name](const World& a) { return a.name == name; });
										if (p != worlds.end()) {
											World* world = &worlds[p - worlds.begin()];
											int ySize = world->blocks.size() / 100, xSize = world->blocks.size() / ySize;
											if (pInfo(peer)->cheat_harvest == true) {
												for (int a_ = 0; a_ < world->blocks.size(); a_++) {
													if (world->blocks[a_].fg == pInfo(peer)->idcheat_harvest) {
														int x_ = a_ % xSize, y_ = a_ / xSize;
														WorldBlock* block_ = &world->blocks[x_ + (y_ * world->blocks.size() / 100)];
														long long time_ = time(nullptr);
														uint32_t laikas = uint32_t((time_ - block_->planted <= items[block_->fg].growTime ? time_ - block_->planted : items[block_->fg].growTime));
														if (/*items[machine->target_item].blockType == BlockTypes::SEED and*/ laikas == items[block_->fg].growTime) {
															int drop_count = items[block_->fg - 1].rarity == 1 ? (items[block_->fg - 1].farmable ? (rand() % 9) + 4 : (rand() % block_->fruit) + 1) : items[block_->fg - 1].farmable ? (rand() % 5) + 4 : (rand() % block_->fruit) + 1;
															bool jalan;
															if (harvest_seed(world, block_, x_, y_, drop_count, pInfo(peer)->netID, peer)) {
																gamepacket_t p(0, pInfo(peer)->netID);
																p.Insert("OnSetPos");
																p.Insert(static_cast<float>(x_) * 32.f, static_cast<float>(y_) * 32.f);
																p.CreatePacket(peer);
															}
															else if (world->weather == 8 and rand() % 300 < 2) {
																WorldDrop drop_block_{};
																drop_block_.id = 3722, drop_block_.count = 1, drop_block_.uid = uint16_t(world->drop.size()) + 1, drop_block_.x = static_cast<float>(x_) * 32 + rand() % 17, drop_block_.y = static_cast<float>(y_) * 32 + rand() % 17;
																dropas_(world, drop_block_);
																PlayerMoving data_2{};
																data_2.packetType = 0x11, data_2.x = drop_block_.x, data_2.y = drop_block_.y, data_2.YSpeed = 108;
																BYTE* raw2 = packPlayerMoving(&data_2);
																for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world->name) continue;
																	send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
																}
																delete[] raw2;
															}
															if (drop_count != 0) drop_rare_item(world, peer, pInfo(peer)->idcheat_harvest - 1, x_, y_, true);
															{
																PlayerMoving data_{};
																data_.packetType = 17, data_.x = static_cast<float>(x_) * 32 + 16, data_.y = static_cast<float>(y_) * 32 + 16, data_.characterState = 0x8;
																data_.XSpeed = 2, data_.YSpeed = 1;
																BYTE* raw = packPlayerMoving(&data_, 56);
																float rotation = 2;
																memcpy(raw + 40, &rotation, 4);
																PlayerMoving extended_particle_data_{};
																extended_particle_data_.packetType = 36, extended_particle_data_.x = static_cast<float>(x_) * 32 + 16, extended_particle_data_.y = static_cast<float>(y_) * 32 + 16, extended_particle_data_.characterState = 0x8;
																extended_particle_data_.netID = 109;
																BYTE* ex_raw = packPlayerMoving(&extended_particle_data_, 56);
																for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																	if (pInfo(currentPeer)->world == world->name) {
																		send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
																		send_raw(currentPeer, 4, ex_raw, 56, ENET_PACKET_FLAG_RELIABLE);
																	}
																}
																delete[] raw, ex_raw;
															}
														}
														break;
													}
												}
											}
										}
									}
								}
								{
									for (ENetPeer* peer = server->peers; peer < &server->peers[server->peerCount]; ++peer) {
										if (peer->state != ENET_PEER_STATE_CONNECTED or peer->data == NULL) continue;
										string name = pInfo(peer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name](const World& a) { return a.name == name; });
										if (p != worlds.end()) {
											World* world = &worlds[p - worlds.begin()];
											int ySize = world->blocks.size() / 100, xSize = world->blocks.size() / ySize;
											if (pInfo(peer)->cht_plant == true) {
												for (int a_ = 0; a_ < world->blocks.size(); a_++) {
													int x_ = a_ % xSize, y_ = a_ / xSize;
													if (world->blocks[a_].fg == 0) {
														WorldBlock* block_ = &world->blocks[x_ + (y_ * world->blocks.size() / 100)];
														gamepacket_t p(0, pInfo(peer)->netID);
														p.Insert("OnSetPos");
														p.Insert(static_cast<float>(x_) * 32.f, static_cast<float>(y_) * 32.f);
														p.CreatePacket(peer);
														int adaBrp = 0;
														modify_inventory(peer, pInfo(peer)->idplant, adaBrp);
														int remove = 0;
														bool removed = true;
														if (adaBrp == 0) {
															pInfo(peer)->cht_plant = false;
															break;
														}
														autoPlace_tile(peer, x_, y_, pInfo(peer)->idplant);
														break;
													}
												}
											}
										}
									}
								}
								int adaBrp = 0;
								modify_inventory(currentPeer, pInfo(currentPeer)->Cheat_AF_PlantingTree, adaBrp);
								if (adaBrp == 0) break;
								if (!isRemote and pInfo(currentPeer)->bankireng == 1 and adaBrp < 1) break;
								if (!isRemote and pInfo(currentPeer)->bankireng == 2 and adaBrp < 2) break;
								if (!isRemote and pInfo(currentPeer)->bankireng == 3 and adaBrp < 3) break;
								if (!isRemote and pInfo(currentPeer)->bankireng == 4 and adaBrp < 4) break;
								if (!isRemote and pInfo(currentPeer)->tigapuluhfar == true and adaBrp < 30) break;

								//FOR AUTO BREAK AND AUTO PUT
								//5 FAR
								if (pInfo(currentPeer)->slave.active == 1) {
									autoPlace_tile_bot(currentPeer, pInfo(currentPeer)->slave.x + 1, pInfo(currentPeer)->slave.y, 5640);
									autoPlace_tile_bot(currentPeer, pInfo(currentPeer)->slave.x + 2, pInfo(currentPeer)->slave.y, 5640);
								}
								if (pInfo(currentPeer)->bankireng == 1) {
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
									else {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
								}
								//4 FAR
								else if (pInfo(currentPeer)->bankireng == 2) {
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 1, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
									else {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 1, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
								}
								//7 FAR
								else if (pInfo(currentPeer)->bankireng == 3) {
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 1, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 2, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
									else {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 1, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 2, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
								}
								else if (pInfo(currentPeer)->bankireng == 4) {
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 1, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 2, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 3, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
									else {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 1, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 2, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 3, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
								}

								//25 FAR
								else if (pInfo(currentPeer)->tigapuluhfar == true) { //kalau pgn di work in raymannya tinggal jadiin 9908
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 1, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 2, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 3, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 4, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 5, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 6, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 7, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 8, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 9, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 10, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 11, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 12, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 13, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 14, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 15, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 16, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 17, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 18, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 19, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 20, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 21, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 22, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 23, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 24, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
									else {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 1, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 2, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 3, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 4, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 5, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 6, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 7, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 8, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 9, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 10, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 11, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 12, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 13, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 14, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 15, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 16, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 17, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 18, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 19, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 20, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 21, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 22, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 23, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 24, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
								}
								else if (pInfo(currentPeer)->hand == 9846999) { //sama aja kek tadi tinggal jadiin 9846
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 1, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 2, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 3, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 4, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 5, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 6, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 7, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 8, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 9, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
									else {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 1, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 2, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 3, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 4, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 5, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 6, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 7, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 8, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 9, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
								}
								else if (pInfo(currentPeer)->hand == 1012699) { //10126
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 1, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 2, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 3, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 4, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 5, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 6, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 7, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 8, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 9, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
									else {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 1, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 2, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 3, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 4, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 5, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 6, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 7, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 8, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 9, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
									}

								else {
									if (!isRemote and adaBrp < 1) break;
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
									else {
										autoPlace_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY, pInfo(currentPeer)->Cheat_AF_PlantingTree);
									}
								}
							}
							else {//FOR AUTO BREAK
								//5 FAR
								if (pInfo(currentPeer)->slave.active == 1) {
									autoPunch_tile(currentPeer, pInfo(currentPeer)->slave.x + 1, pInfo(currentPeer)->slave.y);
									autoPunch_tile(currentPeer, pInfo(currentPeer)->slave.x + 2, pInfo(currentPeer)->slave.y);
								}
								if (pInfo(currentPeer)->bankireng == 1) {
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
									else {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
								}
								//4 FAR
								else if (pInfo(currentPeer)->bankireng == 2) {
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 1, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
									else {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 1, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
								}
								//7 FAR
								else if (pInfo(currentPeer)->bankireng == 3) {
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 1, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 2, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
									else {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 1, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 2, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
								}
								else if (pInfo(currentPeer)->bankireng == 4) {
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 1, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 2, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 3, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
									else {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 1, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 2, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 3, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
								}
								//25 FAR
								else if (pInfo(currentPeer)->tigapuluhfar == true) {//9908
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 1, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 2, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 3, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 4, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 5, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 6, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 7, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 8, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 9, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 10, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 11, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 12, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 13, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 14, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 15, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 16, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 17, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 18, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 19, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 20, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 21, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 22, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 23, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 24, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
									else {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 1, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 2, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 3, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 4, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 5, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 6, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 7, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 8, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 9, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 10, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 11, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 12, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 13, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 14, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 15, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 16, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 17, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 18, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 19, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 20, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 21, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 22, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 23, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 24, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
								}
								else if (pInfo(currentPeer)->hand == 989946) {//9846
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 1, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 2, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 3, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 4, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 5, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 6, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 7, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 8, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 9, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
									else {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 1, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 2, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 3, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 4, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 5, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 6, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 7, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 8, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 9, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
								}
								else if (pInfo(currentPeer)->hand == 101296) {//10126
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 1, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 2, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 3, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 4, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 5, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 6, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 7, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 8, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX - 9, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
									else {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 1, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 2, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 3, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 4, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 5, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 6, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 7, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 8, pInfo(currentPeer)->Cheat_AF_PunchY);
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX + 9, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
								}

								else {
									if (pInfo(currentPeer)->isFacingLeft) {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
									else {
										autoPunch_tile(currentPeer, pInfo(currentPeer)->Cheat_AF_PunchX, pInfo(currentPeer)->Cheat_AF_PunchY);
									}
								}
							}
						}
					}
				}
			}
		}
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world.empty() or pInfo(currentPeer)->tankIDName.empty()) continue;
			if (not has_playmod(pInfo(currentPeer), "Cheat Active: Auto Spam")) continue;
			string name_ = pInfo(currentPeer)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				if (has_playmod(pInfo(currentPeer), "Cheat Active: Auto Spam")) {
					if (duration_cast<seconds>(system_clock::now().time_since_epoch()).count() > pInfo(currentPeer)->Cheat_Last_Spam) {
						pInfo(currentPeer)->Cheat_Last_Spam = duration_cast<seconds>(system_clock::now().time_since_epoch()).count() + pInfo(currentPeer)->Cheat_Spam_Delay;
						string msg = pInfo(currentPeer)->Cheat_Spam_Text;
						if (pInfo(currentPeer)->tankIDName == "") break;
						if (msg.length() <= 0 || msg.length() > 120 || msg.empty() || std::all_of(msg.begin(), msg.end(), [](char c) {return std::isspace(c); })) continue;
						for (char c : msg) if (c < 0x20 || c > 0x7A) continue;
						space_(msg);
						if (msg[0] == '/') Sendcmd(currentPeer, msg);
						else {
							if (msg[0] == '`' and msg.size() <= 2) break;
							if (pInfo(currentPeer)->world == "") break;
							if (has_playmod(pInfo(currentPeer), "duct tape") || has_playmod(pInfo(currentPeer), "Iron MMMFF")) {
								string msg2 = "";
								for (int i = 0; i < msg.length(); i++) {
									if (isspace(msg[i])) msg2 += " ";
									else {
										if (isupper(msg[i])) msg2 += i % 2 == 0 ? "M" : "F";
										else msg2 += i % 2 == 0 ? "m" : "f";
									}
								}
								msg = msg2;
							}
							string check_ = msg;
							transform(check_.begin(), check_.end(), check_.begin(), ::tolower);
							{
								string name_ = pInfo(currentPeer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									if (world_->silence and pInfo(currentPeer)->superdev != 1 and world_->owner_name != pInfo(currentPeer)->tankIDName and find(world_->admins.begin(), world_->admins.end(), pInfo(currentPeer)->tankIDName) == world_->admins.end()) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(currentPeer)->netID), p.Insert("`1(Peasants must not speak)"), p.Insert(1), p.CreatePacket(currentPeer);
										break;
									}
								}
							}
							replaceAll(msg, "`%", "");
							string chat_color = "`$";
							if (pInfo(currentPeer)->d_name.empty()) {
								chat_color = pInfo(currentPeer)->superdev ? "`5" : pInfo(currentPeer)->dev ? "`^" : pInfo(currentPeer)->tmod ? "`^" : "`$";
							}
							if (has_playmod(pInfo(currentPeer), "Infected!")) {
								chat_color = "`2";
								if (rand() % 4 < 1) chat_color += "Brraaiinnss...";
							}
							if (pInfo(currentPeer)->face == 1170)  chat_color = "`4";
							string tag = (pInfo(currentPeer)->dev ? "`4@Dr." : "`4Dr.");
							if (pInfo(peer)->drt) pInfo(currentPeer)->name_color = tag;
							pInfo(peer)->name_color = RolePrefixName(peer);
							gamepacket_t p, p2;
							p.Insert("OnConsoleMessage");
							p.Insert("CP:_PL:0_OID:_CT:[W]_ `6<`w" + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + (pInfo(currentPeer)->is_legend ? " of Legend" : "") + "`6> " + chat_color + msg);
							p2.Insert("OnTalkBubble");
							p2.Insert(pInfo(currentPeer)->netID);
							if (check_ != ":/" and check_ != ":p" and check_ != ":*" and check_ != ";)" and check_ != ":d" and check_ != ":o" and check_ != ":'(" and check_ != ":(") {
								p2.Insert("CP:_PL:0_OID:_player_chat=" + (chat_color == "`$" ? "" : chat_color) + msg);
							}
							else p2.Insert(msg);
							for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
								if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
								if (pInfo(currentPeer2)->world == pInfo(currentPeer)->world) {
									bool muted_ = false;
									for (int c_ = 0; c_ < pInfo(currentPeer2)->friends.size(); c_++) {
										if (pInfo(currentPeer2)->friends[c_].name == pInfo(currentPeer)->tankIDName) {
											if (pInfo(currentPeer2)->friends[c_].mute) {
												muted_ = true;
												break;
											}
										}
									}
									if (not muted_ and not pInfo(currentPeer)->Cheat_HideChat) {
										p.CreatePacket(currentPeer2);
										p2.CreatePacket(currentPeer2);
									}
								}
							}
						}
						break;
					}
				}
			}
		}
	}
	catch (out_of_range& sui) {
		xItsCrims_warn(sui.what());
	}
}
void biar_jalan() {
	while (true) {
		this_thread::sleep_for(chrono::milliseconds(650));
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world != "" && pInfo(currentPeer)->Cheat_AF) {
				loop_cheat(currentPeer);
			}
		}
	}
}
void loop_worlds() {
	long long ms_time = duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count(), time_ = time(nullptr);
	{
		ifstream ifs("config/giveaway.json");
		json j;
		ifs >> j;
		ifs.close();
		if (j["active"].get<bool>() == true) {
			vector<pair<int, int>> hadiah = j["prize"].get<vector<pair<int, int>>>();
			string dialog = "";
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				//int kntls = 0;
				for (int I = 0; I < hadiah.size(); I++) { int dpt = 0, kntls = 0; modify_inventory(currentPeer, hadiah[I].first, kntls), dialog += "\nadd_textbox|Received " + setGems(hadiah[I].second) + " " + items[hadiah[I].first].name + " [ " + (kntls + hadiah[I].second > 250 ? "`4FAIL" : "`2SUCCESS") + " ]|left|", modify_inventory(currentPeer, hadiah[I].first, dpt += hadiah[I].second); }
				Algorithm::OnDialogRequest(currentPeer, dialog);
			}
			j["active"] = false;
			ofstream ofs("config/giveaway.json"); ofs << j; ofs.close();
			math_warn("Successfully Giveaway All Items In giveaway.json To All Players");
		}
	}
	if (last_hm_time - ms_time <= 0) {
		last_hm_time = ms_time + 60000;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world.empty() or pInfo(currentPeer)->tankIDName.empty()) continue;
			if (pInfo(currentPeer)->hack_ != 0) pInfo(currentPeer)->hack_ = 0;
			// Leaderboard System & Update
			int adaBrpWL = 0, adaBrpDL = 0, adaBrpBGL = 0, totalBank = 0, totalBbank = 0;
			int adaBrpGemsKeWL = pInfo(currentPeer)->gems / 2000;
			modify_inventory(currentPeer, 242, adaBrpWL), modify_inventory(currentPeer, 1796, adaBrpDL), modify_inventory(currentPeer, 7188, adaBrpBGL);
			if (adaBrpBGL != 0) adaBrpWL += adaBrpBGL * 10000;
			if (adaBrpDL != 0) adaBrpWL += adaBrpDL * 100;
			pInfo(currentPeer)->totalWls = adaBrpWL;
			pInfo(currentPeer)->totalNetWorth = adaBrpGemsKeWL + adaBrpWL + pInfo(currentPeer)->bwl;
			string find = pInfo(currentPeer)->tankIDName;
			vector<pair<long long int, string>>::iterator lb = find_if(top_richest.begin(), top_richest.end(), [find](const pair <long long int, string>& element) { return element.second == find; });
			if (lb != top_richest.end()) top_richest[lb - top_richest.begin()].first = pInfo(currentPeer)->totalNetWorth;
			else top_richest.push_back(make_pair(pInfo(currentPeer)->totalNetWorth, find));
			update_leaderboard();
			save_leaderboard();
		}
	}
	if (last_hm_time - ms_time <= 0) {
		last_hm_time = ms_time + 60000;
		for (int i = 0; i < monitors.size(); i++) {
			string name_ = monitors[i].world_name;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* monitor = &world_->blocks[monitors[i].x + (monitors[i].y * 100)];
				if (!items[monitor->fg].heart_monitor) {
					monitors.erase(monitors.begin() + i);
					i--;
					continue;
				}
				monitors[i].active = 0;
				string find_mon = monitor->heart_monitor;
				if (find_mon.size() >= 2) find_mon.resize(find_mon.size() - 2); // remove `` is galo
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName == find_mon) {
						monitors[i].active = 1;
						break;
					}
				}
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = monitors[i].x, data_.punchY = monitors[i].y, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, monitor));
				BYTE* blc = raw + 56;
				form_visual(blc, *monitor, *world_, NULL, false, false, monitors[i].x, monitors[i].y);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, monitor), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
			}
		}
	}
	if (last_time2_ - ms_time <= 0 && restart_server_status) {
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("`4Global System Message``: Restarting server for update in `4" + to_string(restart_server_time) + "`` minutes");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			packet_(currentPeer, "action|play_sfx\nfile|audio/ogg/suspended.ogg\ndelayMS|700");
			p.CreatePacket(currentPeer);
		}
		restart_server_time -= 1;
		if (restart_server_time == 0) {
			last_time2_ = ms_time + 10000, restart_server_status_seconds = true, restart_server_status = false;
			restart_server_time = 50;
		}
		else last_time2_ = ms_time + 60000;
	}
	if (restart_server_status_seconds && last_time2_ - ms_time <= 0) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert("`4Global System Message``: Restarting server for update in `4" + (restart_server_time > 0 ? to_string(restart_server_time) : "ZERO") + "`` seconds" + (restart_server_time > 0 ? "" : "! Should be back up in a minute or so. BYE!") + "");
			p.CreatePacket(currentPeer);
		}
		last_time2_ = ms_time + 10000;
		if (restart_server_time == 0) {
			restart_server_status_seconds = false;
			trigger_save_();
		}
		restart_server_time -= 10;
	}
	if (last_honors_reset - ms_time <= 0) {
		honors_reset();
		last_honors_reset = ms_time + 3600000;
	}
	if (last_world_menu - ms_time <= 0) {
		fstream newfile;
		newfile.open("database/deposit.txt", ios::in);
		if (newfile.is_open()) {
			newfile >> depositworld;
			newfile.close();
		}
		//cout << "r w " << endl;
		active_world_list = "";
		active_world_list.clear();
		sort(top_active_worlds.begin(), top_active_worlds.end());
		reverse(top_active_worlds.begin(), top_active_worlds.end());
		top_active_worlds.resize((top_active_worlds.size() >= 24 ? 24 : top_active_worlds.size()));
		for (uint8_t i = 0; i < top_active_worlds.size(); i++) {
			int w_cz = 0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != top_active_worlds[i].second) continue;
				w_cz++;
			}
			active_world_list += "\nadd_floater|" + top_active_worlds[i].second + "|" + to_string(w_cz) + "|" + to_string(0.5 - (i * 0.005)) + "|3529161471";
		}
		top_active_worlds.clear();
		if (active_world_list.empty()) active_world_list = "\nadd_floater|START|0|0.5|3529161471";
		last_world_menu = ms_time + 60000;
		//cout << "d w" << endl;
	}
	if (last_hm_time - ms_time <= 0) {
		//cout << "r g" << endl;
		vector<pair<int, string>> top_tier = top_basher;
		top_basher_list = "", top_basher_list_shop = "";
		sort(top_tier.begin(), top_tier.end());
		reverse(top_tier.begin(), top_tier.end());
		top_tier.resize((top_tier.size() >= 10 ? 10 : top_tier.size()));
		for (uint8_t i = 0; i < top_tier.size(); i++) {
			top_basher_list += "\nadd_smalltext|" + to_string(i + 1) + " : " + top_tier[i].second + " , Score: " + setGems(top_tier[i].first) + "|";
			if (i < 5) top_basher_list_shop += "<CR>" + to_string(i + 1) + " : " + top_tier[i].second + " , Score: " + setGems(top_tier[i].first) + "";
		}
		if (top_basher_list.empty()) top_basher_list = "\nadd_smalltext|The list should update in few minutes..|";
		last_hm_time = ms_time + 600000;
		//cout << "d g" << endl;
	}
	for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
		if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL || pInfo(cp_)->world.empty()) continue;
		if (pInfo(cp_)->pet_netID == 0 && pInfo(cp_)->pet_type != -1 && !pInfo(cp_)->world.empty() && pInfo(cp_)->show_pets) {
			Pet_Ai::Create(cp_);
		}
		else if (pInfo(cp_)->pet_netID != 0 && pInfo(cp_)->pet_type != -1 && !pInfo(cp_)->world.empty()) {
			if (!pInfo(cp_)->pet_ClothesUpdated && pInfo(cp_)->show_pets) {
				Pet_Ai::Update(cp_, pInfo(cp_)->pet_netID, pInfo(cp_)->pet_level, pInfo(cp_)->master_pet, pInfo(cp_)->active_bluename);
			}
		}
	}
	if (last_time - ms_time <= 0) {
		last_time = ms_time + 1300;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world.empty() or pInfo(currentPeer)->tankIDName.empty()) continue;
			if (pInfo(currentPeer)->last_fish_catch + pInfo(currentPeer)->fish_seconds < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count() && pInfo(currentPeer)->fishing_used != 0 && rand() % 100 < (pInfo(currentPeer)->hand == 3010 ? 9 : 6)) {
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 34, data_.YSpeed = 34, data_.x = pInfo(currentPeer)->f_x * 32 + 16, data_.y = pInfo(currentPeer)->f_y * 32 + 16;
				pInfo(currentPeer)->last_fish_catch = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				BYTE* raw = packPlayerMoving(&data_);
				gamepacket_t p3(0, pInfo(currentPeer)->netID);
				p3.Insert("OnPlayPositioned"), p3.Insert("audio/splash.wav");
				for (ENetPeer* currentPeer_event = server->peers; currentPeer_event < &server->peers[server->peerCount]; ++currentPeer_event) {
					if (currentPeer_event->state != ENET_PEER_STATE_CONNECTED or currentPeer_event->data == NULL or pInfo(currentPeer_event)->world != pInfo(currentPeer)->world) continue;
					send_raw(currentPeer_event, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE), p3.CreatePacket(currentPeer_event);
				}
				delete[] raw;
			}
			if (pInfo(currentPeer)->save_time + 600000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				pInfo(currentPeer)->save_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			if (pInfo(currentPeer)->PVP_Time - time(nullptr) <= 0 and pInfo(currentPeer)->PVP_Ongoing and !pInfo(currentPeer)->PVP_Deactive) {
				for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
					if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL or pInfo(currentPeer2)->world != pInfo(currentPeer)->world or pInfo(currentPeer2)->PVP_netID != pInfo(currentPeer)->netID) continue;
					if (pInfo(currentPeer)->PVP_Enemy == pInfo(currentPeer2)->tankIDName) End_PVP(currentPeer, currentPeer2);
				}
			}
			//vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name](const World& a) { return a.name == name; });
			//World* world = &worlds[p - worlds.begin()];
			//for (int i_ = 1; i_ < world->) {}
			/*if (pInfo(currentPeer)->save_time + 180000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (pInfo(currentPeer)->save_time != 0) {
					std::string filename = "./config/double_opc.json";
					// Membaca file JSON
					json jsonData;
					std::ifstream configFile(filename);
					configFile >> jsonData;
					configFile.close();
					vector<int> hand = jsonData["hand"].get<vector<int>>();
					vector<int> wing = jsonData["wing"].get<vector<int>>();
					vector<int> ance = jsonData["ances"].get<vector<int>>();
					int hands = 0, wings = 0, ances = 0;
					for (int i = 0; i < hand.size(); i++) hands = hand[i];
					for (int i = 0; i < wing.size(); i++) wings = wing[i];
					for (int i = 0; i < ance.size(); i++) ances = ance[i];
					pInfo(currentPeer)->coin++;
					string extra = "";
					if (pInfo(currentPeer)->hand == hands || pInfo(currentPeer)->back == wings || pInfo(currentPeer)->ances == ances) pInfo(currentPeer)->coin++, extra = "+1";
					add_honors(pInfo(currentPeer)->world);
					gamepacket_t p2;
					p2.Insert("OnConsoleMessage"), p2.Insert(a + ">> Received 1" + extra +" `1OPC."), p2.CreatePacket(currentPeer);
					loop_save(currentPeer);
				}
				pInfo(currentPeer)->save_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}*/
			if (pInfo(currentPeer)->save_time + 180000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (pInfo(currentPeer)->save_time != 0) {
					pInfo(currentPeer)->coin++;
					if (pInfo(currentPeer)->gp) pInfo(currentPeer)->coin++;
					string extra = "";
					if (pInfo(currentPeer)->pants == 9782) pInfo(currentPeer)->coin++, extra = "`9+1 [" + items[pInfo(currentPeer)->pants].ori_name + "]``, ";
					if (pInfo(currentPeer)->hand == 9766 || pInfo(currentPeer)->hand == 9772) pInfo(currentPeer)->coin++, extra = "`9+1 [" + items[pInfo(currentPeer)->hand].ori_name + "]``, ";
					add_honors(pInfo(currentPeer)->world);
					packet_(currentPeer, "action|play_sfx\nfile|audio/getpoint.wav\ndelayMS|0\n");
					gamepacket_t p2;
					p2.Insert("OnTextOverlay"), p2.Insert(a + "You earned 1" + (pInfo(currentPeer)->gp ? "`2+1``" : "") + extra + " `9Online Point Hub for staying `23 Minutes `9in " + server_name + ""), p2.CreatePacket(currentPeer);
					loop_save(currentPeer);
				}
				pInfo(currentPeer)->save_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			if (pInfo(currentPeer)->give_time + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (pInfo(currentPeer)->give_time != 0) {
					int dl = 0, get = 0;
					modify_inventory(currentPeer, 242, dl);
					if (dl >= 200) {
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("You Inventory are full. can't get reward from giveaway");
						p.CreatePacket(currentPeer);
						break;
					}
					if (dl < 200) {
						string text = "***Auto Giveaway System has once start again. All player received 1 World Locks*** <:zen5:1035986968678506538> ";
						modify_inventory(currentPeer, 242, get = +1);
						packet_(currentPeer, "action|play_sfx\nfile|audio/getpoint.wav\ndelayMS|0\n");
						gamepacket_t p, p1;
						p.Insert("OnTextOverlay"), p.Insert("`6You received 1 `1World Locks " + server_name + " for staying `25 Minutes `9on server");
						//p1.Insert("OnAddNotification"), p1.Insert("interface/large/special_event.rttex"), p1.Insert("`wYou received `2Diamond Locks from `2Giveaway"), p1.Insert("audio/thunderclap.wav");
						p.CreatePacket(currentPeer), p1.CreatePacket(currentPeer);
						//Auto_giveaway(text, "1 Diamond Locks Kaget <:CheckboxEnabled:1027246849897267293> ");
					}
				}
				pInfo(currentPeer)->give_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			if (pInfo(currentPeer)->lastworldcase != -1 && pInfo(currentPeer)->cd_warp + 3000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (pInfo(currentPeer)->cd_warp != 0) {
					pInfo(currentPeer)->lastworldcase = -1;
				}
				pInfo(currentPeer)->cd_warp = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			if (mtk.mtkdelay + 400000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				int quiz1 = rand() % 100 + 1;
				int quiz2 = rand() % 100 + 2;
				int operators = (rand() % 100 < 10 ? 1 : rand() % 50 < 10 ? 2 : rand() % 50 < 5 ? 3 : 4);
				mtk.quiz = (operators == 1 ? (quiz1 / quiz2) : operators == 2 ? (quiz1 * quiz2) : operators == 3 ? (quiz1 - quiz2) : (quiz1 + quiz2));
				int idds = 0;
				if (rand() % 50 < 10) idds = 242; else idds = 242;
				mtk.mtk = true;
				mtk.mtkitem = true;
				if (idds == 242)mtk.prize = rand() % 101;
				if (idds == 242) mtk.prize = rand() % 5 + 1;
				pInfo(currentPeer)->cdaily += 5;
				mtk.id = idds;
				int mmk = 0;
				modify_inventory(currentPeer, idds, mmk);
				if (mtk.mtkdelay != 0) {
					math_warn("Daily Math Started");
					gamepacket_t p2;
					p2.Insert("OnConsoleMessage"), p2.Insert("`9Daily Math SytemĨ!. `1What is `0"+to_string(quiz1) +( operators == 1 ? "/" : operators == 2 ? "x" : operators == 3 ? "-" : "+") + to_string(quiz2) + "`1. `9Use /as for answer, player who guessed with right answer will receive `9" + to_string(mtk.prize) + " " + items[idds].name), p2.CreatePacket(currentPeer);
					loop_save(currentPeer);
				}
				mtk.mtkdelay = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			//auto change crypto price #iAlfa
			//only work when player is active on some worlds
			/*if (Crypto_Update.autoprice + 3600000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
				int berapa = rand() % 100 + 5;
				if (Crypto_Update.autoprice != 0) {
					std::string filename = "./config/crypto.json";
					json jsonData;
					std::ifstream configFile(filename);
					configFile >> jsonData;
					configFile.close();
					int price_bc = jsonData["Bitcoin"].get<int>();
					int price_et = jsonData["Ethereum"].get<int>();
					int price_lt = jsonData["Litecoin"].get<int>();
					int risebc = (price_bc + berapa);
					int riseet = (price_et + berapa);
					int riselc = (price_lt + berapa);
					int dropbc = (price_bc - berapa);
					int dropet = (price_et - berapa);
					int droplc = (price_lt - berapa);
					if (rand()%50 < 5) {
						jsonData["Bitcoin"] = risebc;
						jsonData["Ethereum"] = riseet;
						jsonData["Litecoin"] = riselc;
					math_warn("Crypto Price Were Rised By System");					
					}
					else {
						jsonData["Bitcoin"] = dropbc;
						jsonData["Ethereum"] = dropet;
						jsonData["Litecoin"] = droplc;
						math_warn("Crypto Price Were Dropped By System");
					}
					loop_save(currentPeer);
					std::ofstream outFile(filename);
					outFile << std::setw(4) << jsonData;
					outFile.close();
				}
				Crypto_Update.autoprice = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			string name_ = pInfo(currentPeer)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (last_growganoth_time - ms_time <= 0 && world_->name == "GROWGANOTH") {
					last_growganoth_time = ms_time + 15000;
					for (int i_ = 0; i_ < growganoth_platform.size(); i_++) update_tile(currentPeer, growganoth_platform[i_] % 100, growganoth_platform[i_] / 100, 0, false, false);
					growganoth_platform.clear();
					for (int i_ = 0; i_ < 50; i_++) update_tile(currentPeer, rand() % 60 + 20, rand() % 32 + 20, (i_ < 40 ? 1222 : 7048), true, false);
				}
				}
					if (world_->special_event && world_->last_special_event + 30000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
						gamepacket_t p, p2;
						p.Insert("OnAddNotification"), p.Insert("interface/large/special_event.rttex"), p.Insert("`2" + items[world_->special_event_item].event_name + ":`` " + (items[world_->special_event_item].event_total == 1 ? "`oTime's up! Nobody found it!``" : "`oTime's up! " + to_string(world_->special_event_item_taken) + " of " + to_string(items[world_->special_event_item].event_total) + " items found.``") + ""), p.Insert("audio/cumbia_horns.wav"), p.Insert(0);
						p2.Insert("OnConsoleMessage"), p2.Insert("`2" + items[world_->special_event_item].event_name + ":`` " + (items[world_->special_event_item].event_total == 1 ? "`oTime's up! Nobody found it!``" : "`oTime's up! " + to_string(world_->special_event_item_taken) + " of " + to_string(items[world_->special_event_item].event_total) + " items found.``") + "");
						for (ENetPeer* currentPeer_event = server->peers; currentPeer_event < &server->peers[server->peerCount]; ++currentPeer_event) {
							if (currentPeer_event->state != ENET_PEER_STATE_CONNECTED or currentPeer_event->data == NULL or pInfo(currentPeer_event)->world != name_) continue;
							p.CreatePacket(currentPeer_event), p2.CreatePacket(currentPeer_event);
							PlayerMoving data_{};
							data_.effect_flags_check = 1, data_.packetType = 14, data_.netID = 0;
							for (int i_ = 0; i_ < world_->drop.size(); i_++) {
								if (world_->drop[i_].special == true) {
									data_.plantingTree = world_->drop[i_].uid;
									BYTE* raw = packPlayerMoving(&data_);
									send_raw(currentPeer_event, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									delete[]raw;
									world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
								}
							}
						}
						world_->last_special_event = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count(), world_->special_event_item = 0, world_->special_event_item_taken = 0, world_->special_event = false;
					}
				};*/
			if (pInfo(currentPeer)->hand == 3578 && pInfo(currentPeer)->hand_torch + 60000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (pInfo(currentPeer)->hand_torch != 0) {
					int got = 0;
					modify_inventory(currentPeer, 3578, got);
					if (got - 1 >= 1) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(currentPeer)->netID), p.Insert("`4My torch went out, but I have " + to_string(got - 1) + " more!``"), p.CreatePacket(currentPeer);
					}
					modify_inventory(currentPeer, 3578, got = -1);
				}
				pInfo(currentPeer)->hand_torch = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			if (pInfo(currentPeer)->world != "" && pInfo(currentPeer)->Cheat_AF) {
				if (pInfo(currentPeer)->isRemote == 1) {
					if (pInfo(currentPeer)->Cheat_AF_isRunning + 5 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
						if (pInfo(currentPeer)->Cheat_AF_isRunning != 0) {
							if (pInfo(currentPeer)->magnetron_id >= 1) {
								loop_cheat(currentPeer);
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(currentPeer)->netID), p.Insert("`wMagplant 5000 `4Empty``"), p.CreatePacket(currentPeer);
							}
						}
					}
					pInfo(currentPeer)->Cheat_AF_isRunning = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				}
				else {
					if (pInfo(currentPeer)->Cheat_AF_isRunning + 5 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
						if (pInfo(currentPeer)->Cheat_AF_isRunning != 0) {
							loop_cheat(currentPeer);
						}
					}
					pInfo(currentPeer)->Cheat_AF_isRunning = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				}
			}
			if (pInfo(currentPeer)->rb == 1 && pInfo(currentPeer)->name_time + 250 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				pInfo(currentPeer)->name_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				string msg2 = pInfo(currentPeer)->name_color;
				if (pInfo(currentPeer)->is_legend) msg2 = "`" + to_string(rand() % 9 + 1) + pInfo(currentPeer)->tankIDName;
				else for (int i = 0; i < pInfo(currentPeer)->tankIDName.length(); i++) msg2 += "`" + to_string(rand() % 9 + 1) + "" + pInfo(currentPeer)->tankIDName[i];
				ChangeName(currentPeer, msg2);
			}
			if (pInfo(currentPeer)->hand == 2204 and pInfo(currentPeer)->x != -1 and pInfo(currentPeer)->y != -1) {
				if (not has_playmod(pInfo(currentPeer), "Irradiated")) {
					if (pInfo(currentPeer)->geiger_x == -1 and pInfo(currentPeer)->geiger_y == -1) pInfo(currentPeer)->geiger_x = (rand() % 100) * 32, pInfo(currentPeer)->geiger_y = (rand() % 54) * 32;
					int a_ = pInfo(currentPeer)->geiger_x + ((pInfo(currentPeer)->geiger_y * 100) / 32), b_ = pInfo(currentPeer)->x + ((pInfo(currentPeer)->y * 100) / 32), diff = abs(a_ - b_) / 32;
					if (diff > 30) { // nieko

					}
					else if (diff >= 30) { // raudona
						if (pInfo(currentPeer)->geiger_time + 1500 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
							pInfo(currentPeer)->geiger_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
							PlayerMoving data_{};
							data_.packetType = 17, data_.x = pInfo(currentPeer)->x + 10, data_.y = pInfo(currentPeer)->y + 16, data_.characterState = 0x8, data_.XSpeed = 0, data_.YSpeed = 114;
							BYTE* raw = packPlayerMoving(&data_, 56);
							raw[3] = 114;
							double rotation = -4.13;
							memcpy(raw + 40, &rotation, 4);
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							delete[] raw;
						}
					}
					else if (diff >= 15) { // geltona
						if (pInfo(currentPeer)->geiger_time + 1500 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
							pInfo(currentPeer)->geiger_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
							PlayerMoving data_{};
							data_.packetType = 17, data_.x = pInfo(currentPeer)->x + 10, data_.y = pInfo(currentPeer)->y + 16, data_.characterState = 0x8, data_.XSpeed = 1, data_.YSpeed = 114;
							BYTE* raw = packPlayerMoving(&data_, 56);
							raw[3] = 114;
							double rotation = -4.13;
							memcpy(raw + 40, &rotation, 4);
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							delete[] raw;
						}
					}
					else { // zalia
						if (diff <= 1) { // surado
							{
								if (pInfo(currentPeer)->geiger_time + 2500 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
									pInfo(currentPeer)->geiger_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
									pInfo(currentPeer)->geiger_x = -1, pInfo(currentPeer)->geiger_y = -1;
									{
										int c_ = -1;
										modify_inventory(currentPeer, 2204, c_);
										int c_2 = 1;
										if (modify_inventory(currentPeer, 2286, c_2) != 0) {
											string name_ = pInfo(currentPeer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												WorldDrop drop_block_{};
												drop_block_.id = 2286, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(currentPeer)->x + rand() % 17, drop_block_.y = pInfo(currentPeer)->y + rand() % 17;
												dropas_(world_, drop_block_);
											}
										}
										PlayMods give_playmod{};
										give_playmod.id = 10;
										give_playmod.time = time(nullptr) + (thedaytoday == 3 ? 600 : 900);
										pInfo(currentPeer)->playmods.push_back(give_playmod);
										pInfo(currentPeer)->hand = 2286;
										update_clothes(currentPeer);
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert(a + "You are aglow with radiation! (`$Irradiated`` mod added, `$" + (thedaytoday == 3 ? "10" : "15") + " mins`` left)");
										p.CreatePacket(currentPeer);
										packet_(currentPeer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
									}
									int chanced = 0;
									if (thedaytoday == 3) chanced = 3;
									add_geiger_xp(currentPeer, 1);
									vector<int> geiger_items = { 2242,2244,2246,2248,2250,242,1796,10014 };
									vector<int> rare_cr = { 9488 };
									vector<int> rarest = { 1458 , 9902 , 9770, 10002 };
									int item_ = geiger_items[rand() % geiger_items.size()];
									if (rand() % 100 < 5 + chanced) item_ = rare_cr[rand() % rare_cr.size()];
									if (rand() % 200 < 3 + chanced) item_ = rarest[rand() % rarest.size()];
									int c_ = 1;
									if (modify_inventory(currentPeer, item_, c_) != 0) {
										string name_ = pInfo(currentPeer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											World* world_ = &worlds[p - worlds.begin()];
											WorldDrop drop_block_{};
											drop_block_.id = item_, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(currentPeer)->x + rand() % 17, drop_block_.y = pInfo(currentPeer)->y + rand() % 17;
											dropas_(world_, drop_block_);
										}
									}
									gamepacket_t p;
									p.Insert("OnParticleEffect");
									p.Insert(48);
									p.Insert((float)pInfo(currentPeer)->x + 10, (float)pInfo(currentPeer)->y + 16);
									p.CreatePacket(currentPeer);
									{
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(currentPeer)->netID);
										p.Insert("I found `21 " + items[item_].name + "``!");
										p.Insert(0);
										p.CreatePacket(currentPeer);
										gamepacket_t p2;
										p2.Insert("OnConsoleMessage");
										p2.Insert(pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` found `21 " + items[item_].name + "``!");
										PlayerMoving data_{};
										data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
										data_.punchX = item_;
										data_.x = pInfo(currentPeer)->x + 10, data_.y = pInfo(currentPeer)->y + 16;
										int32_t to_netid = pInfo(currentPeer)->netID;
										BYTE* raw = packPlayerMoving(&data_);
										raw[3] = 5;
										memcpy(raw + 8, &to_netid, 4);
										for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
											if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
											if (pInfo(currentPeer2)->world == pInfo(currentPeer)->world) {
												send_raw(currentPeer2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												p2.CreatePacket(currentPeer2);
											}
										}
										delete[]raw;
									}
								}
							}
						}
						else {
							int t_ = 0;
							if (diff >= 6) t_ = 1350;
							else t_ = 1000;
							if (pInfo(currentPeer)->geiger_time + t_ < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
								pInfo(currentPeer)->geiger_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
								PlayerMoving data_{};
								data_.packetType = 17, data_.x = pInfo(currentPeer)->x + 10, data_.y = pInfo(currentPeer)->y + 16, data_.characterState = 0x8;
								data_.XSpeed = 2, data_.YSpeed = 114;
								BYTE* raw = packPlayerMoving(&data_, 56);
								raw[3] = 114;
								double rotation = -4.13;
								memcpy(raw + 40, &rotation, 4);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[] raw;
							}
						}
					}
				}
			}
			long long time_ = time(nullptr);
			for (int i_ = 0; i_ < pInfo(currentPeer)->playmods.size(); i_++) {
				if (pInfo(currentPeer)->playmods[i_].id == 12) {
					if (pInfo(currentPeer)->valentine_time + 2500 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
						pInfo(currentPeer)->valentine_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
						for (ENetPeer* valentine = server->peers; valentine < &server->peers[server->peerCount]; ++valentine) {
							if (valentine->state != ENET_PEER_STATE_CONNECTED or valentine->data == NULL) continue;
							if (pInfo(valentine)->world == pInfo(currentPeer)->world and pInfo(valentine)->tankIDName == pInfo(currentPeer)->playmods[i_].user) {
								if (not pInfo(valentine)->invis and not pInfo(currentPeer)->invis and pInfo(currentPeer)->x != -1 and pInfo(currentPeer)->y != -1 and pInfo(valentine)->x != -1 and pInfo(valentine)->y != -1) {
									gamepacket_t p;
									p.Insert("OnParticleEffect");
									p.Insert(13);
									p.Insert((float)pInfo(valentine)->x + 10, (float)pInfo(valentine)->y + 16);
									p.Insert((float)0), p.Insert((float)pInfo(currentPeer)->netID);
									bool double_send = false;
									for (int i_2 = 0; i_2 < pInfo(valentine)->playmods.size(); i_2++) {
										if (pInfo(valentine)->playmods[i_2].id == 12 and pInfo(valentine)->playmods[i_2].user == pInfo(currentPeer)->tankIDName) {
											double_send = true;
											break;
										}
									}
									gamepacket_t p2;
									p2.Insert("OnParticleEffect");
									p2.Insert(13);
									p2.Insert((float)pInfo(currentPeer)->x + 10, (float)pInfo(currentPeer)->y + 16);
									p2.Insert((float)0), p2.Insert((float)pInfo(valentine)->netID);
									for (ENetPeer* valentine_bc = server->peers; valentine_bc < &server->peers[server->peerCount]; ++valentine_bc) {
										if (valentine_bc->state != ENET_PEER_STATE_CONNECTED or valentine_bc->data == NULL) continue;
										if (pInfo(valentine_bc)->world == pInfo(currentPeer)->world) {
											p.CreatePacket(valentine_bc);
											if (double_send) p2.CreatePacket(valentine_bc);
										}
									}
								}
								break;
							}
						}
					}
				}
				if (pInfo(currentPeer)->playmods[i_].time - time_ < 0) {
					for (vector<string> get_ : info_about_playmods) {
						uint32_t playmod_id = atoi(get_[0].c_str());
						if (playmod_id == pInfo(currentPeer)->playmods[i_].id) {
							string playmod_name = get_[2];
							string playmod_on_remove = get_[4];
							pInfo(currentPeer)->playmods.erase(pInfo(currentPeer)->playmods.begin() + i_);
							packet_(currentPeer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert(playmod_on_remove + " (`$" + playmod_name + "`` mod removed)");
							p.CreatePacket(currentPeer);
							update_clothes(currentPeer);
							break;
						}
					}
				}
			}
		}
	}

	if (last_time_ - ms_time <= 0) {
		last_time_ = ms_time + 10;
		for (int a = 0; a < t_worlds.size(); a++) {
			string name = t_worlds[a];
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name](const World& a) { return a.name == name; });
			if (p != worlds.end()) {
				World* world = &worlds[p - worlds.begin()];
				if (world->machines.size() == 0 and world->npc.size() == 0) {
					t_worlds.erase(t_worlds.begin() + a);
					a--;
					continue;
				}
				int ySize = world->blocks.size() / 100, xSize = world->blocks.size() / ySize;
				vector<int> alr_done;
				for (int i_ = 0; i_ < world->machines.size(); i_++) {
					WorldMachines* machine = &world->machines[i_];
					if (not machine->enabled or machine->target_item == 0) continue;
					if (machine->last_ - ms_time > 0) continue;
					machine->last_ = ms_time + 10;
					WorldBlock* itemas = &world->blocks[machine->x + (machine->y * 100)];
					if (itemas->pr <= 0 or find(alr_done.begin(), alr_done.end(), itemas->fg) != alr_done.end()) continue;
					switch (itemas->fg) {
					case 6952:
					{
						for (int a_ = 0; a_ < world->blocks.size(); a_++) {
							if (world->blocks[a_].fg == machine->target_item or world->blocks[a_].bg == machine->target_item) {
								if (items[machine->target_item].blockType == BlockTypes::CLOTHING and world->blocks[a_].fg != 0) continue;
								int x_ = a_ % xSize, y_ = a_ / xSize;
								WorldBlock* block_ = &world->blocks[x_ + (y_ * 100)];
								PlayerMoving data_{};
								data_.packetType = 17, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.characterState = 0x8;
								data_.XSpeed = 32, data_.YSpeed = 16;
								BYTE* raw = packPlayerMoving(&data_);
								float rotation = 2;
								memcpy(raw + 40, &rotation, 4);
								PlayerMoving extended_particle_data_{};
								extended_particle_data_.packetType = 36, extended_particle_data_.x = x_ * 32 + 16, extended_particle_data_.y = y_ * 32 + 16, extended_particle_data_.characterState = 0x8;
								extended_particle_data_.netID = 110;
								BYTE* ex_raw = packPlayerMoving(&extended_particle_data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world->name) {
										send_raw(currentPeer, 4, ex_raw, 56, ENET_PACKET_FLAG_RELIABLE);
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, ex_raw;
								itemas->pr--;
								if (itemas->pr <= 0) {
									PlayerMoving data_{};
									data_.packetType = 5, data_.punchX = machine->x, data_.punchY = machine->y, data_.characterState = 0x8;
									BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world, itemas));
									BYTE* blc = raw + 56;
									form_visual(blc, *itemas, *world, NULL, false);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world->name) {
											send_raw(currentPeer, 4, raw, 112 + alloc_(world, itemas), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, blc;
								}
								if (block_->hp == -1) {
									block_->hp = items[machine->target_item].breakHits / 6;
									block_->lp = time_;
								}
								block_->hp -= 1;
								if (block_->hp == 0) {
									if (items[machine->target_item].max_gems != 0) {
										int maxgems = items[machine->target_item].max_gems;
										if (machine->target_item == 120) maxgems = 50;
										int c_ = rand() % (maxgems + 1);
										if (c_ != 0) {
											bool no_seed = false, no_gems = false, no_block = false;
											if (machine->target_item == 2242 or machine->target_item == 9816 or machine->target_item == 9872 or machine->target_item == 2248 or machine->target_item == 2250 or machine->target_item == 542) no_seed = true, no_block = true;
											else {
												for (int i_ = 0; i_ < world->drop.size(); i_++) {
													if (abs(world->drop[i_].y - y_ * 32) <= 16 and abs(world->drop[i_].x - x_ * 32) <= 16) {
														if (world->drop[i_].id == 112 and items[machine->target_item].rarity < 8) {
															no_gems = true;
														}
														else {
															no_seed = true, no_block = true;
														}
													}
												}
											}
											int chanced = 0;
											if (thedaytoday == 2) chanced = 5;
											if (rand() % 100 < 7) {
												WorldDrop drop_block_{};
												drop_block_.id = machine->target_item, drop_block_.count = 1, drop_block_.uid = uint16_t(world->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
												if (not use_mag(world, drop_block_, x_, y_) and not no_block) {
													dropas_(world, drop_block_);
												}
											}
											else if (rand() % 10 < 5, (items[machine->target_item].newdropchance + chanced)) {
												WorldDrop drop_seed_{};
												drop_seed_.id = machine->target_item + 1, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
												if (not use_mag(world, drop_seed_, x_, y_) and not no_seed) {
													dropas_(world, drop_seed_);
												}
											}
											else if (not no_gems) {
												drop_rare_item(world, NULL, machine->target_item, x_, y_, false);
												gems_(NULL, world, c_, x_ * 32, y_ * 32, machine->target_item);
											}
										}
									}
									reset_(block_, x_, y_, world);
									PlayerMoving data_{};
									data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
									BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world, block_));
									BYTE* blc = raw + 56;
									form_visual(blc, *block_, *world, NULL, false);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world->name) {
											send_raw(currentPeer, 4, raw, 112 + alloc_(world, block_), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, blc;
								}
								else {
									PlayerMoving break_data{ -1, 0, 0x8, 0x0, 6, x_, y_, 0, (float)x_, (float)y_, 0, 0 };
									BYTE* p_ = packPlayerMoving(&break_data);
									p_[2] = 0, p_[3] = 0;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world->name) {
											send_raw(currentPeer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] p_;
								}
								break;
							}
						}
						break;
					}
					case 6950:
					{
						for (int a_ = 0; a_ < world->blocks.size(); a_++) {
							if (world->blocks[a_].fg == machine->target_item) {
								int x_ = a_ % xSize, y_ = a_ / xSize;
								WorldBlock* block_ = &world->blocks[x_ + (y_ * 100)];
								uint32_t laikas = uint32_t((time_ - block_->planted <= items[block_->fg].growTime ? time_ - block_->planted : items[block_->fg].growTime));
								if (laikas == items[block_->fg].growTime) {
									int drop_count = items[block_->fg - 1].rarity == 1 ? (items[block_->fg - 1].farmable ? (rand() % 9) + 4 : (rand() % block_->fruit) + 1) : items[block_->fg - 1].farmable ? (rand() % 5) + 4 : (rand() % block_->fruit) + 1;
									if (harvest_seed(world, block_, x_, y_, drop_count, -1)) {

									}
									else if (world->weather == 8 and rand() % 300 < 2) {
										WorldDrop drop_block_{};
										drop_block_.id = 3722, drop_block_.count = 1, drop_block_.uid = uint16_t(world->drop.size()) + 1, drop_block_.x = x_ * 32 + rand() % 17, drop_block_.y = y_ * 32 + rand() % 17;
										dropas_(world, drop_block_);
										PlayerMoving data_2{};
										data_2.packetType = 0x11, data_2.x = drop_block_.x, data_2.y = drop_block_.y, data_2.YSpeed = 108;
										BYTE* raw2 = packPlayerMoving(&data_2);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world->name) continue;
											send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
										}
										delete[] raw2;
									}
									if (drop_count != 0) drop_rare_item(world, NULL, machine->target_item - 1, x_, y_, true);
									{
										PlayerMoving data_{};
										data_.packetType = 17, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.characterState = 0x8;
										data_.XSpeed = 2, data_.YSpeed = 1;
										BYTE* raw = packPlayerMoving(&data_, 56);
										float rotation = 2;
										memcpy(raw + 40, &rotation, 4);
										PlayerMoving extended_particle_data_{};
										extended_particle_data_.packetType = 36, extended_particle_data_.x = x_ * 32 + 16, extended_particle_data_.y = y_ * 32 + 16, extended_particle_data_.characterState = 0x8;
										extended_particle_data_.netID = 109;
										BYTE* ex_raw = packPlayerMoving(&extended_particle_data_, 56);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world->name) {
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												send_raw(currentPeer, 4, ex_raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, ex_raw;
									}
									itemas->pr--;
									if (itemas->pr <= 0) {
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = machine->x, data_.punchY = machine->y, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world, itemas));
										BYTE* blc = raw + 56;
										form_visual(blc, *itemas, *world, NULL, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world->name) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world, itemas), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
									}
								}
								break;
							}
						}
						break;
					}
					}
					alr_done.push_back(itemas->fg);
				}
				for (int i_ = 0; i_ < world->npc.size(); i_++) {
					WorldNPC* npc = &world->npc[i_];
					if (not npc->enabled) continue;
					if (npc->last_ - time_ > 0) continue;
					int active = 0;
					map<string, vector<WorldNPC>>::iterator it;
					for (it = active_npc.begin(); it != active_npc.end(); it++) {
						if (it->first == world->name) {
							for (int i_ = 0; i_ < it->second.size(); i_++) {
								if (it->second[i_].uid != -1) active++;
								if (active > 10) break;
							}
							break;
						}
					}
					if (active > 10) continue;
					npc->last_ = time_ + npc->rate_of_fire;
					WorldBlock* itemas = &world->blocks[npc->x + (npc->y * 100)];
					if (not itemas->enabled) continue;
					switch (itemas->fg) {
					case 8020: case 4344:
					{
						uint16_t projectile_speed = npc->projectile_speed;
						PlayerMoving data_{};
						data_.packetType = 34;
						data_.x = npc->x * 32 + 16; //nuo x
						data_.y = npc->y * 32 + (itemas->fg == 8020 ? 6 : 16); //nuo y
						data_.XSpeed = npc->x * 32 + 16; // iki x
						data_.YSpeed = npc->y * 32 + (itemas->fg == 8020 ? 6 : 16); // iki y
						data_.punchY = npc->projectile_speed;
						BYTE* raw = packPlayerMoving(&data_);
						uint16_t uid = (active_npc.find(world->name) != active_npc.end() ? active_npc[world->name].size() : 0);
						raw[1] = (itemas->fg == 8020 ? 15 : 8);
						raw[2] = uid; // npc uid turi buti unique
						raw[3] = 2; // 2 yra spawn o 7 yra despawn
						memcpy(raw + 40, &npc->kryptis, 4);
						npc->uid = uid;
						npc->started_moving = ms_time;
						if (active_npc.find(world->name) != active_npc.end()) {
							active_npc[world->name].push_back(*npc);
						}
						else {
							vector<WorldNPC> list_;
							list_.push_back(*npc);
							active_npc.insert({ world->name, list_ });
						}
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world->name and pInfo(currentPeer)->x != -1) {
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw;
						break;
					}
					default:
					{
						bool cant_del = false;
						map<string, vector<WorldNPC>>::iterator it;
						for (it = active_npc.begin(); it != active_npc.end(); it++) {
							if (cant_del) break;
							if (it->first == world->name) {
								for (int i_ = 0; i_ < it->second.size(); i_++) {
									WorldNPC* npc_ = &it->second[i_];
									if (npc->uid == npc_->uid) {
										cant_del = true;
										break;
									}
								}
							}
						}
						if (not cant_del) {
							world->npc.erase(world->npc.begin() + i_);
						}
						break;
					}
					}
				}
				map<string, vector<WorldNPC>>::iterator it;
				for (it = active_npc.begin(); it != active_npc.end(); it++) {
					if (it->first == world->name) {
						for (int i_ = 0; i_ < it->second.size(); i_++) {
							WorldNPC* npc_ = &it->second[i_];
							if (npc_->uid == -1) continue;
							double per_sekunde_praeina_bloku = (double)npc_->projectile_speed / 32;
							double praejo_laiko = (double)(ms_time - npc_->started_moving) / 1000;
							double praejo_distancija = (double)per_sekunde_praeina_bloku * (double)praejo_laiko;
							double current_x = ((int)npc_->kryptis == 180 ? (((double)npc_->x - (double)praejo_distancija) * 32) + 16 : (((double)npc_->x + (double)praejo_distancija) * 32) + 16);
							double current_y = (double)npc_->y * 32;
							if (current_x / 32 < 0 or current_x / 32 >= 100 or current_y / 32 < 0 or current_y / 32 >= 60)
							{
								PlayerMoving data_{};
								data_.packetType = 34;
								data_.x = (current_x); //nuo x
								data_.y = (current_y + (npc_->id == 8020 ? 6 : 16)); //nuo y
								data_.XSpeed = (current_x); // iki x
								data_.YSpeed = (current_y + (npc_->id == 8020 ? 6 : 16)); // iki y
								data_.punchY = npc_->projectile_speed;
								BYTE* raw = packPlayerMoving(&data_);
								raw[1] = 15;
								raw[2] = npc_->uid;
								raw[3] = 7;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world->name and pInfo(currentPeer)->x != -1) {
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[]raw;
								npc_->uid = -1;
								continue;
							}
							try {
								WorldBlock* block_ = &world->blocks[current_x / 32 + (current_y / 32 * 100)];
								if (items[block_->fg].collisionType == 1 or (current_x / 32) > 100 or (current_x / 32) < 0) {
									PlayerMoving data_{};
									data_.packetType = 34;
									data_.x = (current_x); //nuo x
									data_.y = (current_y + (npc_->id == 8020 ? 6 : 16)); //nuo y
									data_.XSpeed = (current_x); // iki x
									data_.YSpeed = (current_y + (npc_->id == 8020 ? 6 : 16)); // iki y
									data_.punchY = npc_->projectile_speed;
									BYTE* raw = packPlayerMoving(&data_);
									raw[1] = 15;
									raw[2] = npc_->uid;
									raw[3] = 7;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world->name and pInfo(currentPeer)->x != -1) {
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[]raw;
									npc_->uid = -1;
								}
							}
							catch (out_of_range) {
								continue;
							}
						}
						break;
					}
				}
			}
		}
	}
}

int main(int argc, char* argv[]) {
	BOOL ret = SetConsoleCtrlHandler(ConsoleHandler, TRUE);
	srand(unsigned int(time(nullptr)));
	//system("COLOR B");
	system("TITLE Development By @iAlfa");
	cout << "ENet Server" << endl;
	cout << "Loading saved guild data" << endl;
	for (const auto& entry : fs::directory_iterator("database/guilds")) {
		if (!fs::is_directory(entry.path())) {
			string guild_id = explode(".", entry.path().filename().string())[0];
			json guild_read;
			ifstream read_guild(entry.path(), ifstream::binary);
			read_guild >> guild_read;
			read_guild.close();
			Guild new_guild{};
			new_guild.guild_id = atoi(guild_id.c_str());
			new_guild.guild_name = guild_read["guild_name"].get<string>();
			new_guild.guild_description = guild_read["guild_description"].get<string>();
			new_guild.guild_mascot = guild_read["guild_mascot"].get<vector<uint16_t>>();
			new_guild.guild_level = guild_read["guild_level"].get<uint16_t>();
			new_guild.guild_xp = guild_read["guild_xp"].get<uint32_t>();
			new_guild.coleader_access = guild_read["coleader_access"].get<bool>();
			new_guild.coleader_elder_access = guild_read["coleader_elder_access"].get<bool>();
			new_guild.all_access = guild_read["all_access"].get<bool>();
			new_guild.guild_world = guild_read["guild_world"].get<string>();
			json a_ = guild_read["guild_members"].get<json>();
			for (int i_ = 0; i_ < a_.size(); i_++) {
				GuildMember new_member{};
				new_member.member_name = a_[i_]["member_name"].get<string>();
				new_member.role_id = a_[i_]["role_id"].get<int>();
				new_member.public_location = a_[i_]["public_location"].get<bool>();
				new_member.show_notifications = a_[i_]["show_notifications"].get<bool>();
				new_member.last_online = a_[i_]["last_online"].get<long long>();
				new_guild.guild_members.push_back(new_member);
			}
			json b_ = guild_read["guild_logs"].get<json>();
			for (int i_ = 0; i_ < b_.size(); i_++) {
				GuildLog new_log{};
				new_log.info = b_[i_]["info"].get<string>();
				new_log.display_id = b_[i_]["display_id"].get<uint16_t>();
				new_log.date = b_[i_]["date"].get<long long>();
				new_guild.guild_logs.push_back(new_log);
			}
			guilds.push_back(new_guild);
		}
	}
	/*ifstream bkp("./config/color_role.json");
	if (!bkp.is_open()) {
		json j;
		bkp >> j;
		j["umod_color"] = smod_color;
		j["developer_color"] = own_color;
		j["supermod_color"] = supermod_color;
		j["mods_color"] = royal_color;
		j["mvp_color"] = mod_color;
		j["vip_color"] = vip_color;
		j["investor_color"] = investor_color;
		j["clist_color"] = clist_color;
		bkp.close();
		smod_color = j["umod_color"].get<string>();
		own_color = j["developer_color"].get<string>();
		supermod_color = j["supermod_color"].get<string>();
		royal_color = j["mods_color"].get<string>();
		mod_color = j["mvp_color"].get<string>();
		vip_color = j["vip_color"].get<string>();
		investor_color = j["investor_color"].get<string>();
		clist_color = j["clist_color"].get<string>();
	}
	ifstream cabul("./config/community_link.json");
	if (!cabul.is_open()) {
		json j;
		cabul >> j;
		whatsapp_link = j["walink"].get<string>();
		discord_link = j["discordlink"].get<string>();
		cabul.close();
	}
	ifstream anj("./config/worlds.json");
	if (!anj.is_open()) {
		json j;
		anj >> j;
		j["foregroundsetting"] = fgset;
		j["weathersetting"] = dweatherset;
		anj.close();
		fgset = j["foregroundsetting"].get<int>();
		dweatherset = j["weathersetting"].get<int>();
	}
	ifstream pler("./config/events.json");
	if (!pler.is_open()) {
		json j;
		pler >> j;
	    j["halloween"] = Halloween;
		j["blackfriday"] = Blackfriday;
		j["valentine"] = Valentine;
		j["winter"] = Winterfest;
		j["mining"] = miningevent;
		j["gemevent"] = gem_;
		pler.close();
		Halloween = j["halloween"].get<bool>();
		Blackfriday = j["blackfriday"].get<bool>();
		Valentine = j["valentine"].get<bool>();
		Winterfest = j["winter"].get<bool>();
		miningevent = j["mining"].get<bool>();
		gem_ = j["gemevent"].get<int>();
	}*/
	bool itscrime = false;
	ifstream lol("./config/config.json");
	if (!lol.is_open()) {
		cout << "enter server port : ";
		cin >> server_port;
		cout << "enter server name : ";
		cin >> server_name;
		cout << "enter clist name  : ";
		cin >> clist1;
		cout << "Osm Www/Kayak www.growtopia1.com : ";
		cin >> osm_link;
		cout << "Osm Cache/Kayak cache/ : ";
		cin >> osm_path;
		ofstream le("./config/config.json");
		json j;
		j["port"] = server_port;
		j["name"] = server_name;
		j["clist1"] = clist1;
		j["clist4"] = clist4;
		j["clist5"] = clist5;
		j["clist6"] = clist6;
		j["clist7"] = clist7;
		j["clist8"] = clist8;
		j["clist9"] = clist9;
		j["clist10"] = clist10;
		j["clist11"] = clist11;
		j["clist12"] = clist12;
		j["Onsupermain"] = osm_link;
		j["CdnCache"] = osm_path;
		j["Proto"] = proto;
		le << j;
		le.close();
	}
	json j;
	lol >> j;
	lol.close();
	server_port = j["port"].get<int>();
	server_name = j["name"].get<string>();
	clist1 = j["clist1"].get<string>();
	clist4 = j["clist4"].get<string>();
	clist5 = j["clist5"].get<string>();
	clist6 = j["clist6"].get<string>();
	clist7 = j["clist7"].get<string>();
	clist8 = j["clist8"].get<string>();
	clist9 = j["clist9"].get<string>();
	clist10 = j["clist10"].get<string>();
	clist11 = j["clist11"].get<string>();
	clist12 = j["clist12"].get<string>();
	osm_link = j["Onsupermain"].get<string>();
	osm_path = j["CdnCache"].get<string>();
	proto = j["Proto"].get<string>();
	if (atexit(trigger_save_))
		cout << "Saving...\n";

	if (items_dat() == -1)
		cout << "items.dat klaida maybe missing or moved" << endl;
	else {
		cout << setGems(items.size()) << " items loaded" << endl;
	}
	server_port = 17091;
	if (init_enet(server_port) == -1) //17099
		cout << "enet klaida or already listen on port 17091" << endl;
	else
	system("CLS");
	infowarn("Successfully loaded all Databases");
	cout << "[===] Server Up! Current time: " + currentDateTime() + "" << endl;
	cout << "[===] Remaked by iAlfa !!" << endl;
	cout << "[===] Found Bug? Contact : +62895-4228-55227 <==" << endl;
	cout << "[===] Leak CPP / RESELL, Moga mati ngentot puki" << endl;
	cout << "" << endl;
	infowarn("items loaded: "+ setGems(items.size()));
	infowarn("Current Server Name : " +server_name);
	infowarn("Now Listening On Port : " + to_string(server_port));
	infowarn("Current Owner Server : " + clist1);
	load_markets();
	load_market_item(true);
	itemsjson("load");
	blockjson("load");
	storegemjson("load", true);
	load_dr(); infowarn("Successfully Load Daily Reward Databases");
	cout << "" << endl;
	//system("COLOR 7");
	std::thread runautosave(autosave);
	if (runautosave.joinable()) {
		runautosave.detach();
	}
	daily_quest();
	load_color_role();
	load_community();
	//load_buttonshop();
	load_defaultworld();
	load_eventss(); //mailbox_json("load");
	//load_roleprice();
	thread a__(biar_jalan);
	a__.detach();
	{
		ifstream ifs("database/server_events.json");
		if (ifs.is_open()) {
			json j;
			ifs >> j;
			{
				json load = j["mails"].get<json>();
				for (int i = 0; i < load.size(); i++) {
					Mailbox_Player ld{};
					ld.unread = load[i]["unread"].get<bool>(), ld.message = load[i]["msg"].get<string>(), ld.sender = load[i]["sender"].get<string>(), ld.receiver = load[i]["receiver"].get<string>();
					Mail.push_back(ld);
				}
			}
			{
				json load = j["UIDS"].get<json>();
				for (int i = 0; i < load.size(); i++) {
					UID_To_Name uid_{};
					uid_.uid = load[i]["uid"].get<int>(), uid_.name = load[i]["name"].get<string>();
					UIDList.push_back(uid_);
				}
			}
			UIDcreated = j["UIDcreated"].get<int>();
			top_basher = (!(j.find("2") != j.end()) ? top_basher : j["2"].get<vector<pair<int, string>>>());
			mails = (!(j.find("mboxx") != j.end()) ? mails : j["mboxx"].get<vector<pair<string, string>>>());
			top_basher_winners = (!(j.find("3") != j.end()) ? top_basher_winners : j["3"].get<vector<pair<int, string>>>());
			top_old_winners = (!(j.find("4") != j.end()) ? top_old_winners : j["4"].get<string>());
			ridbans = (!(j.find("rid") != j.end()) ? ridbans : j["rid"].get<vector<string>>());
			recomendedworld = (!(j.find("rekomended") != j.end()) ? recomendedworld : j["rekomended"].get<vector<string>>());
			Chat_Update.mencariitem = (!(j.find("srch_item") != j.end()) ? Chat_Update.mencariitem : j["srch_item"].get<vector<string>>());
			Chat_Update.menjualitem = (!(j.find("srchs_item") != j.end()) ? Chat_Update.menjualitem : j["srchs_item"].get<vector<string>>());
			Chat_Update.publicchat = (!(j.find("public") != j.end()) ? Chat_Update.publicchat : j["public"].get<vector<string>>());
			top_points = (!(j.find("h" + to_string(today_day)) != j.end()) ? top_points : j["h" + to_string(today_day)].get<vector<pair<int, string>>>());
			top_yesterday = (!(j.find("h" + to_string(today_day - 1)) != j.end()) ? top_yesterday : j["h" + to_string(today_day - 1)].get<vector<pair<int, string>>>());
			top_overall = (!(j.find("m" + to_string(today_month)) != j.end()) ? top_overall : j["m" + to_string(today_month)].get<vector<pair<int, string>>>());
			Crypto_Update.crypto_history = (!(j.find("crypto_logs") != j.end()) ? Crypto_Update.crypto_history : j["crypto_logs"].get<vector<string>>());
			Growch_Update.s4tb = (!(j.find("s4tb") != j.end()) ? Growch_Update.s4tb : j["s4tb"].get<int>());
			Growch_Update.total_s4tb = (!(j.find("recycle_wl") != j.end()) ? Growch_Update.total_s4tb : j["recycle_wl"].get<int>());
		}
	}
	honors_reset();
	//load_markets();
	/*ifstream ifs("db/volcanic_capes.json");
	if (ifs.is_open()) {
		json j;
		ifs >> j;
		volcanic_cape = j["v1"].get<int>();
		volcanic_wings = j["v2"].get<int>();
		if (today_day != j["v3"].get<int>()) {
			volcanic_cape = 0;
			volcanic_wings = 0;
		}
	}*/
	// {
	{
	ifstream ifs("database/rich_player.json");
	if (ifs.is_open()) {
		json j;
		ifs >> j;
		vector<pair<long long int, string>> richPlayer = j["list"];
		top_richest = richPlayer;
	}
	ifs.close();
	}
		ifstream ifs("news.json");
		if (ifs.is_open()) {
			json j;
			ifs >> j;
			news_text = j["news"].get<string>();
		}
	// }
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	thedaytoday = newtime.tm_wday;
	{
		const char* months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
		string month = months[newtime.tm_mon], translated = "", str = to_string(today_day), locke = "";
		if (str == "01" || str == "21") translated = "st";
		else if (str == "02" || str == "22") translated = "nd";
		else if (str == "03") translated = "rd";
		else translated = "th";
		if (thedaytoday == 5 or thedaytoday == 6 or thedaytoday == 0 or thedaytoday == 1) locke = "\nadd_spacer|small|\nadd_textbox|`oToday Growtopia is being paid a visit by `5Locke`` the traveling salesman! He comes one day a month to hawk his fabulous wares, though this time he'll stick around a day and a half to introduce himself. Checkout the world `5LOCKETOWN``!``|left|";
		news_texture = "set_default_color|`o\nadd_label_with_icon|big|`6 " + server_name + " Server``|left|12436|\nadd_spacer|small|\nadd_image_button||interface/large/wtr_lvl7_qucnem.rttex|bannerlayout|||\nadd_spacer|small|\nadd_image_button|iotm_layout|interface/gtps/discord.rttex|3imageslayout||" + discord_link + "|Do you want to join our discord server?|\nadd_image_button|rules_jawa|interface/gtps/rules.rttex|3imageslayout|||\nadd_image_button|jawa_jawir|interface/gtps/features.rttex|3imageslayout|||\nadd_spacer|small|\nadd_textbox|" + server_name + " Gacor Parah Kang|\nadd_textbox|`9Enjoy With Our Server Gan!|\nadd_spacer|small|\nadd_image_button||interface/large/gazette/gtps_1.rttex|3imageslayout|||\nadd_image_button||interface/large/gazette/gtps_2.rttex|3imageslayout|||\nadd_image_button||interface/large/gazette/gtps_3.rttex|3imageslayout|||\nadd_spacer|small|\nadd_image_button|news_324|interface/large/gtps_continue.rttex|3imageslayout|||\nend_dialog|gazette|";
	}
	if (thedaytoday == 1) theitemtoday = 5040;
	else if (thedaytoday == 2) theitemtoday = 5042;
	else if (thedaytoday == 3) theitemtoday = 5044;
	else if (thedaytoday == 4) theitemtoday = 5032;
	else if (thedaytoday == 5)theitemtoday = 5034;
	else if (thedaytoday == 6) theitemtoday = 5036;
	else if (thedaytoday == 0)theitemtoday = 5038;
	ENetEvent event;
	while (true) {
		while (enet_host_service(server, &event, 1000) > 0) {
			ENetPeer* peer = event.peer;
			switch (event.type) {
				case ENET_EVENT_TYPE_CONNECT:
				{
					char clientConnection[16];
					enet_address_get_host_ip(&peer->address, clientConnection, 16);
					send_(peer, 1, nullptr, 0);
					gamepacket_t p4, p5;
					//p.Insert("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");			
					//p4.Insert("OnAddNotification"), p4.Insert("interface/large/special_event.rttex"), p4.Insert("`4Please wait `9Connecting `8to the server..."), p4.Insert("audio/hub_open.wav"), p4.Insert(0), p4.CreatePacket(peer);
					p4.Insert("OnConsoleMessage"), p4.Insert("`0Your Ping: " + to_string(peer->roundTripTime) + " `2ms"), p4.CreatePacket(peer);
					p5.Insert("OnConsoleMessage"), p5.Insert("Connected to `2" + server_name + " (UP)"), p5.CreatePacket(peer);
					peer->data = new Player;
					pInfo(peer)->id = peer->connectID, pInfo(peer)->ip = clientConnection;
					string error = "";
					int logged = 0;
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->ip != pInfo(currentPeer)->ip) continue;
						logged++;
					}
					if (logged > 4) error = "`4OOPS:`` Too many people logging in at once. Please press `5CANCEL`` and try again in a few seconds.";
					//for (int i = 0; i < ipbans.size(); i++) if (pInfo(peer)->ip == ipbans[i]) error = "action|log\nmsg|CT:[S]_ `4Sorry, you are not allowed to enter the game from this location. Contact `5Discord Staff Team `4if you have any questions.";
					if (pInfo(peer)->ip != pInfo(peer)->meta and pInfo(peer)->meta != "") error = "action|log\nmsg|CT:[S]_ `4Can not make new account!`` Sorry, but IP " + pInfo(peer)->ip + " is not permitted to create NEW Growtopia accounts at this time. (This can be because there is an open proxy/VPN here or abuse has from this IP) Please try again from another IP address.";
					//if (pInfo(peer)->gameVersion != "4,17") error = "action|log\nmsg|CT:[S]_ `5Update Required: `oNow version Growtopia is 4,17, Please update your growtopia.";
					if (error != "") packet_(peer, error, ""), enet_peer_disconnect_later(peer, 0);
					
					break;
				}
				case ENET_EVENT_TYPE_RECEIVE: // change
				{
					ENetPeer* peer = event.peer;
					if (peer->data == NULL) continue;
					Player* p_ = pInfo(peer);
					if (p_->lpps1 + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
						p_->pps1 = 0;
						p_->lpps1 = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
					}
					else {
						p_->pps1++;
						if (p_->pps1 >= 80) {
							break;
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
							}
						}
					}
				}
				{
					loop_worlds();
					//loop_save(peer);
					switch (message_(event.packet)) {
					case 2:
					{
						string cch = text_(event.packet);
						if (debugmode = true)
							Server_pktdebug(pInfo(peer)->tankIDName + ")\n" + cch);
						if (cch.size() > 1024) break;
						if (cch == "action|getDRAnimations\n" || cch == "action|refresh_player_tribute_data\n") break;
						if (pInfo(peer)->bypass == false) {
							if (cch == "action|enter_game\n" || cch.find("requestedName|") != string::npos || cch.find("tankIDName|") != string::npos || cch.find("action|dialog_return\ndialog_name|puzzle_captcha_submit\n") != string::npos || cch == "action|getDRAnimations\n" || cch == "action|refresh_player_tribute_data\n" || cch.find("action|dialog_return\ndialog_name|f2a|") != string::npos) {

							}
							else {
								if (!cchLogs) {
									//cout << "\n(action logs disabled)" << endl;
								}
								else {
									//cout << pInfo(peer)->tankIDName + " in " + pInfo(peer)->world << "\n" << cch << endl;
								}
							}
						}
						if (pInfo(peer)->lpps + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
							pInfo(peer)->pps = 0;
							pInfo(peer)->lpps = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
						}
						else {
							pInfo(peer)->pps++;
							if (pInfo(peer)->pps >= 10) {
								enet_peer_disconnect_later(peer, 0);
								break;
							}
						}
						if (pInfo(peer)->requestedName.empty()) {
							replaceAll(cch, "/p", "\n");
							if (pInfo(peer)->enter_game != 0 || pInfo(peer)->world != "") enet_peer_disconnect_later(peer, 0);
							else player_login(peer, cch);
						}
						add_packet_logs(" [" + pInfo(peer)->ip + "] (" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + " | World: " + pInfo(peer)->world == "" ? "EXIT" : pInfo(peer)->world + ") " + cch);
						if (pInfo(peer)->requestedName.empty()) {
							if (pInfo(peer)->enter_game != 0 || pInfo(peer)->world != "") {
								if (not pInfo(peer)->tankIDName.empty())
									if (pInfo(peer)->trading_with != -1) {
										cancel_trade(peer, false);
									}
								enet_peer_disconnect_later(peer, 0);
								save_player(pInfo(peer), false);
								delete peer->data;
								peer->data = NULL;
							}
							else player_login(peer, cch);
						}
					else if (cch.find("action|input") != string::npos) {
							vector<string> t_ = explode("|", cch);
							if (t_.size() < 4) break;
							string msg = explode("\n", t_[3])[0];
							if (pInfo(peer)->tankIDName == "") break;
							if (msg.length() <= 0 || msg.length() > 120 || msg.empty() || std::all_of(msg.begin(), msg.end(), [](char c) {return std::isspace(c); })) continue;
							for (char c : msg) if (c < 0x20 || c>0x7A) continue;
							space_(msg);
							if (pInfo(peer)->tankIDName.empty() || pInfo(peer)->world.empty() || msg[0] == '`' and msg.size() <= 2) break;
							if (msg[0] == '/') Sendcmd(peer, msg);
							else {
								if (pInfo(peer)->world == "") break;
								if (pInfo(peer)->tut_sb == false) tutorial_(peer, "tut_sb");
								if (has_playmod(pInfo(peer), "duct tape") || has_playmod(pInfo(peer), "`4KONTOL")) {
									string msg2 = "";
									for (int i = 0; i < msg.length(); i++) {
										if (isspace(msg[i])) msg2 += " ";
										else {
											if (isupper(msg[i])) msg2 += i % 2 == 0 ? "`4KON" : "`4TOL";
											else msg2 += i % 2 == 0 ? "`4kon" : "`4tol";
										}
									}
									msg = msg2;
								}
								string check_ = msg;
								transform(check_.begin(), check_.end(), check_.begin(), ::tolower);
								{
									string name_ = pInfo(peer)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										World* world_ = &worlds[p - worlds.begin()];
										if (world_->silence and pInfo(peer)->coown != 1 and world_->owner_name != pInfo(peer)->tankIDName and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end()) {
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`1(Peasants must not speak)"), p.Insert(1), p.CreatePacket(peer);
											break;
										}
									}
								}
								bool warned = false;
								pInfo(peer)->not_same++;
								if (pInfo(peer)->last_input_text == msg) pInfo(peer)->same_input++;
								pInfo(peer)->last_input_text = msg;
								if (pInfo(peer)->last_spam_detection + 100 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) pInfo(peer)->last_spam_detection = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count(), pInfo(peer)->same_input = 0, pInfo(peer)->not_same = 0;
								if (pInfo(peer)->same_input >= 3 || pInfo(peer)->not_same >= 5) {
									gamepacket_t p;
									p.Insert("OnConsoleMessage"), p.Insert("`6>>`4Spam detected! ``Please wait a bit before typing anything else.  Please note, any form of bot/macro/auto-paste will get all your accounts banned, so don't do it!"), p.CreatePacket(peer);
								}
								else {
									gamepacket_t p, p2;
									p.Insert("OnConsoleMessage");
									p.Insert("CP:_PL:0_OID:_CT:[W]_ `6<`w" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "`6> `$" + (has_playmod(pInfo(peer), "Infected!") ? "`2" : "") + "" + ((pInfo(peer)->superdev == 1 and pInfo(peer)->d_name.empty()) ? "`5" : (pInfo(peer)->dev == 1 and pInfo(peer)->d_name.empty()) ? "`1" : (pInfo(peer)->tmod == 1 and pInfo(peer)->d_name.empty()) ? "`^" : "`$") + msg + "`````");
									p2.Insert("OnTalkBubble");
									p2.Insert(pInfo(peer)->netID);
									if (check_ != ":/" and check_ != ":p" and check_ != ":*" and check_ != ";)" and check_ != ":d" and check_ != ":o" and check_ != ":'(" and check_ != ":(") {
										p2.Insert("CP:_PL:0_OID:_player_chat=" + a + ((pInfo(peer)->owner == 1 and pInfo(peer)->d_name.empty()) ? own_chat : (pInfo(peer)->superdev == 1 and pInfo(peer)->d_name.empty()) ? smod_chat : (pInfo(peer)->dev == 1 and pInfo(peer)->d_name.empty()) ? royal_chat : (pInfo(peer)->vip == 1 and pInfo(peer)->d_name.empty()) ? vip_chat : ((pInfo(peer)->tmod == 1 and pInfo(peer)->d_name.empty())) ? "`^" : "`0") + msg);
									}
									else p2.Insert(msg);
									if (pInfo(peer)->green_bubble == true) p2.Insert(2);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(peer)->world) {
											bool muted_ = false;
											for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
												if (pInfo(currentPeer)->friends[c_].name == pInfo(peer)->tankIDName) {
													if (pInfo(currentPeer)->friends[c_].mute) {
														muted_ = true;
														break;
													}
												}
											} if (not muted_ and not pInfo(currentPeer)->Cheat_HideChat) {
												p.CreatePacket(currentPeer);
												p2.CreatePacket(currentPeer);
											}
										}
									}
								}
							}
							break;
						}
						else if (cch.find("action|mod_trade") != string::npos or cch.find("action|rem_trade") != string::npos) {
							vector<string> t_ = explode("|", cch);
							if (t_.size() < 3) break;
							int item_id = atoi(explode("\n", t_[2])[0].c_str()), c_ = 0;
							modify_inventory(peer, item_id, c_);
							if (c_ == 0) break;
							if (c_ == 1 or cch.find("action|rem_trade") != string::npos) {
								mod_trade(peer, item_id, c_, (cch.find("action|rem_trade") != string::npos ? true : false));
								break;
							}
							if (cch.find("action|rem_trade") == string::npos) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`2Trade`` `w" + items[item_id].name + "``|left|" + to_string(item_id) + "|\nadd_textbox|`2Trade how many?``|left|\nadd_text_input|count||" + to_string(c_) + "|5|\nembed_data|itemID|" + to_string(item_id) + "\nend_dialog|trade_item|Cancel|OK|");
								p.CreatePacket(peer);
							}
							break;
						}
						else if (cch.find("action|trade_accept") != string::npos) {//
							if (pInfo(peer)->trading_with != -1) {
								vector<string> t_ = explode("|", cch);
								if (t_.size() < 3) break;
								string status_ = explode("\n", t_[2])[0];
								if (status_ != "1" and status_ != "0") break;
								bool f_ = false;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(peer)->world) {
										if (pInfo(currentPeer)->netID == pInfo(peer)->trading_with and pInfo(peer)->netID == pInfo(currentPeer)->trading_with) {
											string name_ = pInfo(peer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												if (status_ == "1")
													pInfo(peer)->trade_accept = 1;
												else
													pInfo(peer)->trade_accept = 0;
												if (pInfo(peer)->trade_accept and pInfo(currentPeer)->trade_accept) {
													// check inv space   
													if (not trade_space_check(peer, currentPeer)) {
														pInfo(peer)->trade_accept = 0, pInfo(currentPeer)->trade_accept = 0;
														gamepacket_t p;
														p.Insert("OnTradeStatus");
														p.Insert(pInfo(peer)->netID);
														p.Insert("");
														p.Insert("`o" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "``'s offer.``");
														p.Insert(make_trade_offer(pInfo(peer), true) + "locked|0\naccepted|0");
														p.CreatePacket(peer);
														{
															gamepacket_t p;
															p.Insert("OnTradeStatus");
															p.Insert(pInfo(peer)->netID);
															p.Insert("");
															p.Insert("`o" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "``'s offer.``");
															p.Insert(make_trade_offer(pInfo(peer), true) + "locked|0\nreset_locks|1\naccepted|0");
															p.CreatePacket(currentPeer);
														}
														f_ = true;
														break;
													}
													else if (not trade_space_check(currentPeer, peer)) {
														pInfo(peer)->trade_accept = 0, pInfo(currentPeer)->trade_accept = 0;
														gamepacket_t p;
														p.Insert("OnTradeStatus");
														p.Insert(pInfo(currentPeer)->netID);
														p.Insert("");
														p.Insert("`o" + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + "``'s offer.``");
														p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\naccepted|0");
														p.CreatePacket(currentPeer);
														{
															gamepacket_t p;
															p.Insert("OnTradeStatus");
															p.Insert(pInfo(currentPeer)->netID);
															p.Insert("");
															p.Insert("`o" + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + "``'s offer.``");
															p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
															p.CreatePacket(peer);
														}
														f_ = true;
														break;
													}
													{
														gamepacket_t p;
														p.Insert("OnForceTradeEnd");
														p.CreatePacket(peer);
													}
													send_trade_confirm_dialog(peer, currentPeer);
													break;
												}
												gamepacket_t p;
												p.Insert("OnTradeStatus");
												p.Insert(pInfo(peer)->netID);
												p.Insert("");
												p.Insert("`o" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "``'s offer.``");
												p.Insert(make_trade_offer(pInfo(peer), true) + "locked|0\naccepted|" + status_);
												p.CreatePacket(peer);
												{
													{
														gamepacket_t p;
														p.Insert("OnTradeStatus");
														p.Insert(pInfo(currentPeer)->netID);
														p.Insert("");
														p.Insert("`o" + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + "``'s offer.``");
														p.Insert("locked|0\nreset_locks|1\naccepted|0");
														p.CreatePacket(currentPeer);
													}
													gamepacket_t p;
													p.Insert("OnTradeStatus");
													p.Insert(pInfo(currentPeer)->netID);
													p.Insert("");
													p.Insert("`o" + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + "``'s offer.``");
													p.Insert("locked|0\naccepted|1");
													p.CreatePacket(currentPeer);
													{
														gamepacket_t p;
														p.Insert("OnTradeStatus");
														p.Insert(pInfo(currentPeer)->netID);
														p.Insert("");
														p.Insert("`o" + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + "``'s offer.``");
														p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
														p.CreatePacket(currentPeer);
													}
													{
														gamepacket_t p;
														p.Insert("OnTradeStatus");
														p.Insert(pInfo(peer)->netID);
														p.Insert("");
														p.Insert("`o" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "``'s offer.``");
														p.Insert(make_trade_offer(pInfo(peer), true) + "locked|0\nreset_locks|1\naccepted|" + status_);
														p.CreatePacket(currentPeer);
													}
												}
											}
											f_ = true;
											break;
										}
									}
								} if (not f_) {
									if (status_ == "1")
										pInfo(peer)->trade_accept = 1;
									else
										pInfo(peer)->trade_accept = 0;
								}
							}
							break;
						}
						/*if (cch.find("buttonClicked|claim_1") != string::npos) {
	if (pInfo(peer)->claimnewget == false) {
		int got1 = 0, got2 = 0, got3 = 0, got4 = 0, got5 = 0;
		modify_inventory(peer, 9928, got1 += 200), modify_inventory(peer, 340, got2 += 200), modify_inventory(peer, 5666, got3 += 200), modify_inventory(peer, 98, got4 += 1), modify_inventory(peer, 1796, got5 += 50);
		pInfo(peer)->claimnewget = true;
		Algorithm::send_overlay(peer, "`2Successfully Claim Farmer Pack");
		break;
	}
}
if (cch.find("buttonClicked|claim_2") != string::npos) {
	if (pInfo(peer)->claimnewget == false) {
		int got1 = 0, got2 = 0, got3 = 0, got4 = 0, got5 = 0;
		modify_inventory(peer, 9816, got1 += 50), modify_inventory(peer, 9872, got2 += 50), modify_inventory(peer, 2204, got3 += 1), modify_inventory(peer, 4654, got4 += 1), modify_inventory(peer, 1796, got5 += 100);
		pInfo(peer)->claimnewget = true;
		Algorithm::send_overlay(peer, "`2Successfully Claim Radioactive Hunter Pack");
		break;
	}
}
if (cch.find("buttonClicked|claim_3") != string::npos) {
	if (pInfo(peer)->claimnewget == false) {
		int got1 = 0, got2 = 0, got3 = 0;
		modify_inventory(peer, 9950, got1 += 1), modify_inventory(peer, 7188, got2 += 2), modify_inventory(peer, 1796, got3 += 50);
		pInfo(peer)->bitcoin += 20;
		pInfo(peer)->gems += 50000;
		pInfo(peer)->claimnewget = true;
		gamepacket_t p, p1;
		p.Insert("OnSetBux");
		p1.Insert("OnTextOverlay");
		p.Insert(pInfo(peer)->gems), p.Insert(0);
		p1.Insert("`2Successfully Claim Investor Pack");
		p.CreatePacket(peer), p1.CreatePacket(peer);
		break;
	}
}*/

						else if (cch.find("action|dialog_return\ndialog_name|claimnewget\nbuttonClicked|claim_") != string::npos) {
							if (pInfo(peer)->claimnewget == true) break;
							int type = atoi(cch.substr(65, cch.length() - 65).c_str());
							ifstream p("./config/newget.json");
							p >> j;
							p.close();
							string jmk = "code-" + setGems(type);
							if (j.find(jmk) != j.end()) {
								vector<pair<int, int>>newget = j[jmk]["prize"].get<vector<pair<int, int>>>();
								for (int i = 0; i < newget.size(); i++) {
									int dapat = 0;
									modify_inventory(peer, newget[i].first, dapat = newget[i].second);														
								}
								Algorithm::send_overlay(peer, "`2Successfully Claim " + j[jmk]["name"].get<string>() + " Pack");
								math_warn(pInfo(peer)->tankIDName + " just choosed a starter pack");
								pInfo(peer)->claimnewget = true;
							}
							break;
						}
						else if (cch.find("action|dialog_return\ndialog_name|textSpammer") != string::npos) {

							string text = explode("\n", explode("textBot|", cch)[1])[0];
							if (text.length() > 120) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wText Spam Max 120 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else if (text.length() < 1) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wText Spam Min 1 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								pInfo(peer)->npc_text = "";
								break;
							}
							pInfo(peer)->npc_text = text;
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							p.Insert("`wSetting Updated.");
							p.Insert(0), p.Insert(1), p.CreatePacket(peer);

					}
						else if (cch.find("action|dialog_return\ndialog_name|ngefind") != string::npos) {
							string text = explode("\n", explode("ygmaudifind|", cch)[1])[0];
							if (text.length() <= 2) {
								Algorithm::send_console(peer, "");
								break;
							}
							else if (text.length() > 50) {
								Algorithm::send_console(peer, "Its has no item with that long name");
								break;
							}
							else {
								Sendcmd(peer, "/find " + text, true);
								break;
							}
		}
						else if (cch.find("action|dialog_return\ndialog_name|giveroles") != string::npos) {
							if (pInfo(peer)->tankIDName != clist1) break;
							bool vip = false, mvp = false, cheat = false, nick = false, ghost = false, mod = false, smod = false, umod = false, dev = false, udev = false, find = false, helper = false, co = false, clist = false;
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (to_lower(pInfo(peer)->lastgivenrole) == to_lower(pInfo(currentPeer)->tankIDName)) {
									pInfo(currentPeer)->vip = atoi(explode("\n", explode("checkbox_vip|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->mod = atoi(explode("\n", explode("checkbox_mvp|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->cheater = atoi(explode("\n", explode("checkbox_cheat|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									nick = atoi(explode("\n", explode("checkbox_nick|", cch)[1])[0].c_str()) == 1 ? true : false;
									ghost = atoi(explode("\n", explode("checkbox_ghost|", cch)[1])[0].c_str()) == 1 ? true : false;
									mod = atoi(explode("\n", explode("checkbox_mod|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->admin = atoi(explode("\n", explode("checkbox_smod|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->superdev = atoi(explode("\n", explode("checkbox_umod|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->owner = atoi(explode("\n", explode("checkbox_dev|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->udev = atoi(explode("\n", explode("checkbox_udev|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									find = atoi(explode("\n", explode("checkbox_find|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(currentPeer)->helper = atoi(explode("\n", explode("checkbox_helper|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->coown = atoi(explode("\n", explode("checkbox_co|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->creatorlist = atoi(explode("\n", explode("checkbox_clist|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->permadev = (mod ? 1 : 0), pInfo(currentPeer)->dev = (mod ? 1 : 0);
									{
										if (ghost == true) { if (!cmdacc(currentPeer, "ghost")) pInfo(currentPeer)->role_cmd.push_back("ghost"); }
										if (ghost == false) { if (cmdacc(currentPeer, "ghost") == true) erasecmdacc(currentPeer, "ghost"); }
										if (nick == true) { if (!cmdacc(currentPeer, "nick")) pInfo(currentPeer)->role_cmd.push_back("nick"); }
										if (nick == false) { if (cmdacc(currentPeer, "nick") == true) erasecmdacc(currentPeer, "nick"); }
										if (find == true) { if (!cmdacc(currentPeer, "find")) pInfo(currentPeer)->role_cmd.push_back("find"); }
										if (find == false) { if (cmdacc(currentPeer, "find") == true) erasecmdacc(currentPeer, "find"); }

									}
									Algorithm::send_overlay(currentPeer, "`4[ Warning ] `9Your role was modified by Owner Server");
									sendmessage(peer, "overlay", "`^Successfully Set " + pInfo(currentPeer)->tankIDName + " Role Status");
									update_clothes(currentPeer);
									update_nick(currentPeer);
								}
							}
						}
						else if (cch.find("action|dialog_return\ndialog_name|createworld") != string::npos ||
							cch.find("action|dialog_return\ndialog_name|createworld_purchase_confirm") != string::npos) {
								if (cch.find("action|dialog_return\ndialog_name|createworld_purchase_confirm") != string::npos) {
									string data_embed = explode("idCWorld|", cch)[1];
									replace_str(data_embed, "\n", "");
									int idWorld = atoi(data_embed.c_str());
									string nameWorld = pInfo(peer)->world;

									auto it = find_if(createWorld.begin(), createWorld.end(), [idWorld](const CreateWorld& my_item) {
										return my_item.idCWorld == idWorld;
										});

									string typeWorld;
									string copyWorld;
									int price = 0;

									if (it == createWorld.end()) break;
									for (int i = 0; i < createWorld.size(); i++) {
										if (createWorld[i].idCWorld == idWorld) {
											typeWorld = createWorld[i].type;
											copyWorld = createWorld[i].copy;
											price = createWorld[i].price;
											break;
										}
									}
									vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [nameWorld](const World& a) { return a.name == nameWorld; });
									if (paa != worlds.end()) {
										World* world_ = &worlds[paa - worlds.begin()];
										if (pInfo(peer)->gems <= price) {
											Algorithm::send_console(peer, "`4you dont have enough gems for that");
											Algorithm::send_console(peer, "`4you dont have enough gems for that");
											break;
										}

										if (world_->owner_name == pInfo(peer)->tankIDName) {
											World world_s;
											world_s = get_world(copyWorld);
											world_s.name = nameWorld;
											worlds.push_back(world_s);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == world_->name) {
													exit_(currentPeer);
												}
											}
											pInfo(peer)->gems -= price;
											gemsUpdate(peer, 0);
											Algorithm::send_console(peer, "success purchase createworld type `2" + typeWorld);
											Algorithm::send_console(peer, "success purchase createworld type `2" + typeWorld);
										}
										else {
											Algorithm::send_console(peer, "`4you not own this world");
											Algorithm::send_console(peer, "`4you not own this world");
										}
									}
								}

								if (cch.find("action|dialog_return\ndialog_name|createworld") != string::npos) {
									size_t idCWorld_pos = cch.find("world_");
									if (idCWorld_pos == string::npos) break;

									int idCreate = atoi(explode("_", explode("world_", cch.substr(idCWorld_pos))[1])[0].c_str());

									auto it = find_if(createWorld.begin(), createWorld.end(), [idCreate](const CreateWorld& my_item) {
										return my_item.idCWorld == idCreate;
										});

									if (it == createWorld.end()) break;

									string typeWorld;
									string copyWorld;
									int price = 0;

									for (size_t i = 0; i < createWorld.size(); i++) {
										if (createWorld[i].idCWorld == idCreate) {
											typeWorld = createWorld[i].type;
											copyWorld = createWorld[i].copy;
											price = createWorld[i].price;
											break;
										}
									}
									if (price <= 0) break;
									get_createworld(peer, idCreate, typeWorld, copyWorld, price);
									break;
								}
								break;
								}
						else if (cch.find("action|dialog_return\ndialog_name|givetittle") != string::npos) {
							if (pInfo(peer)->creatorlist) break;
							bool drt = false, gp = false, is_legend = false, accttbadge = false, accCcbadge = false;
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (to_lower(pInfo(peer)->lastgiventitle) == to_lower(pInfo(currentPeer)->tankIDName)) {
									pInfo(currentPeer)->drt = atoi(explode("\n", explode("checkbox_drt|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->gp = atoi(explode("\n", explode("checkbox_gp|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->is_legend = atoi(explode("\n", explode("checkbox_legend|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->accttbadge = atoi(explode("\n", explode("checkbox_tt|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									pInfo(currentPeer)->accCcbadge = atoi(explode("\n", explode("checkbox_cc|", cch)[1])[0].c_str()) == 1 ? 1 : 0;
									Algorithm::send_overlay(currentPeer, "`4[ Warning ] `9Your title was modified by Owner Server");
									sendmessage(peer, "overlay", "`^Successfully Set " + pInfo(currentPeer)->tankIDName + " Title Status");
									update_clothes(currentPeer);
									update_nick(currentPeer);
								}
							}
						}
						else if (cch.find("action|dialog_return\ndialog_name|textcolorown") != string::npos) {
							if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
							string text = explode("\n", explode("textBots|", cch)[1])[0];
							std::string filename = "./config/color_role.json";
							// Membaca file JSON
							json jsonData;
							std::ifstream configFile(filename);
							configFile >> jsonData;
							configFile.close();
							if (text.length() > 20) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMax 20 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else if (text.length() < 1) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMin 1 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								own_color = "";
								break;
							}
							own_color = text;
							// Mengubah nilai "far" dengan menggunakan itemid sebagai kunci
							jsonData["developer_color"] = text;
							// Menulis kembali ke file JSON
							std::ofstream outFile(filename);
							outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
							outFile.close();
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							p.Insert("`wSetting Updated.");
							p.Insert(0), p.Insert(1), p.CreatePacket(peer);

					}
						else if (cch.find("action|dialog_return\ndialog_name|fakeonlinemode") != string::npos) {
							if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
							string text = explode("\n", explode("textBots|", cch)[1])[0];
							if (text.length() > 20) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMax 20 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else if (text.length() < 1) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMin 1 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								own_color = "";
								break;
							}
							fakeonlen = text;
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							p.Insert("`wFake Online Updated.");
							p.Insert(0), p.Insert(1), p.CreatePacket(peer);

					}
						else if (cch.find("action|dialog_return\ndialog_name|textcolorumod") != string::npos) {
							if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
							string text = explode("\n", explode("textBotss|", cch)[1])[0];
							std::string filename = "./config/color_role.json";
							// Membaca file JSON
							json jsonData;
							std::ifstream configFile(filename);
							configFile >> jsonData;
							configFile.close();
							if (text.length() > 20) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMax 20 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else if (text.length() < 1) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMin 1 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								smod_color = "";
								break;
							}
							smod_color = text;
							// Mengubah nilai "far" dengan menggunakan itemid sebagai kunci
							jsonData["umod_color"] = text;
							// Menulis kembali ke file JSON
							std::ofstream outFile(filename);
							outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
							outFile.close();
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							p.Insert("`wSetting Updated.");
							p.Insert(0), p.Insert(1), p.CreatePacket(peer);

					}
						else if (cch.find("action|dialog_return\ndialog_name|mailbox") != string::npos) {
							if (cch.find("buttonClicked|send_mail") != string::npos) {
								if (has_playmod(pInfo(peer), "Mailbox cooldown")) sendmessage(peer, "console", "Please wait until your cooldown removed");
								else sendmessage(peer, "dialog", "add_label_with_icon|big|Send mail to player|left|12436|\nadd_spacer|small|\nadd_text_input|player|GrowID: ||10|\nadd_text_input|msg|Message: ||30|\nadd_button|csend_mail|Send|left|\nadd_quick_exit|\nend_dialog|mailbox|Nevermind||");
							}
							else if (cch.find("buttonClicked|csend_mail") != string::npos) {
								if (has_playmod(pInfo(peer), "Mailbox cooldown")) { sendmessage(peer, "console", "Please wait until your cooldown removed"); break; }
								string message = explode("\n", explode("msg|", cch)[1])[0].c_str(), growid = explode("\n", explode("player|", cch)[1])[0].c_str();
								if (message.empty() && growid.empty()) { sendmessage(peer, "console", "Message or GrowID must be filled with a letter"); break; }
								transform(growid.begin(), growid.end(), growid.begin(), ::toupper); string path = "database/players/" + growid + "_.json";
								if (_access_s(path.c_str(), 0) == 0) {
									Mailbox_Player mail_{};
									mail_.message = message, mail_.sender = pInfo(peer)->tankIDName, mail_.receiver = growid, mail_.unread = true;
									Mail.push_back(mail_);
									mailbox_json("save");
									PlayMods npm{}; npm.id = 114, npm.time = time(nullptr) + 1800; pInfo(peer)->playmods.push_back(npm);
									sendmessage(peer, "console", "Success send a mail to " + growid); sendmessage(peer, "console", "Mailbox cooldown active (30mins left)");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (to_lower(growid) == to_lower(pInfo(currentPeer)->tankIDName)) {
											sendmessage(currentPeer, "console", "`c[MSG] `0You receive a Mail from player, check it in your Mailbox");
										}
									}
								}
								else sendmessage(peer, "console", "There is no player with name " + growid);
							}
							break;
						}
						else if (cch.find("action|dialog_return\ndialog_name|textcolorsmod") != string::npos) {
						if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
							string text = explode("\n", explode("textBotss|", cch)[1])[0];
							std::string filename = "./config/color_role.json";
							// Membaca file JSON
							json jsonData;
							std::ifstream configFile(filename);
							configFile >> jsonData;
							configFile.close();
							if (text.length() > 20) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMax 20 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else if (text.length() < 1) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMin 1 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								supermod_color = "";
								break;
							}
							supermod_color = text;
							// Mengubah nilai "far" dengan menggunakan itemid sebagai kunci
							jsonData["supermod_color"] = text;
							// Menulis kembali ke file JSON
							std::ofstream outFile(filename);
							outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
							outFile.close();
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							p.Insert("`wSetting Updated.");
							p.Insert(0), p.Insert(1), p.CreatePacket(peer);

							}
						else if (cch.find("action|dialog_return\ndialog_name|textcolormod") != string::npos) {
								if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
								string text = explode("\n", explode("textBotss|", cch)[1])[0];
								std::string filename = "./config/color_role.json";
								// Membaca file JSON
								json jsonData;
								std::ifstream configFile(filename);
								configFile >> jsonData;
								configFile.close();
								if (text.length() > 20) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									p.Insert("`wMax 20 Characters.");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									break;
								}
								else if (text.length() < 1) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									p.Insert("`wMin 1 Characters.");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									royal_color = "";
									break;
								}
								royal_color = text;
								// Mengubah nilai "far" dengan menggunakan itemid sebagai kunci
								jsonData["mods_color"] = text;
								// Menulis kembali ke file JSON
								std::ofstream outFile(filename);
								outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
								outFile.close();
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wSetting Updated.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);

								}
						else if (cch.find("action|dialog_return\ndialog_name|textcolormvp") != string::npos) {
							if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
									string text = explode("\n", explode("textBotss|", cch)[1])[0];
									std::string filename = "./config/color_role.json";
									// Membaca file JSON
									json jsonData;
									std::ifstream configFile(filename);
									configFile >> jsonData;
									configFile.close();
									if (text.length() > 20) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										p.Insert("`wMax 20 Characters.");
										p.Insert(0), p.Insert(1), p.CreatePacket(peer);
										break;
									}
									else if (text.length() < 1) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										p.Insert("`wMin 1 Characters.");
										p.Insert(0), p.Insert(1), p.CreatePacket(peer);
										mod_color = "";
										break;
									}
									mod_color = text;
									// Mengubah nilai "far" dengan menggunakan itemid sebagai kunci
									jsonData["mvp_color"] = text;
									// Menulis kembali ke file JSON
									std::ofstream outFile(filename);
									outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
									outFile.close();
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									p.Insert("`wSetting Updated.");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);

									}
						else if (cch.find("action|dialog_return\ndialog_name|textcolorvip") != string::npos) {//
							if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
										string text = explode("\n", explode("textBotss|", cch)[1])[0];
										std::string filename = "./config/color_role.json";
										// Membaca file JSON
										json jsonData;
										std::ifstream configFile(filename);
										configFile >> jsonData;
										configFile.close();
										if (text.length() > 20) {
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
											p.Insert("`wMax 20 Characters.");
											p.Insert(0), p.Insert(1), p.CreatePacket(peer);
											break;
										}
										else if (text.length() < 1) {
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
											p.Insert("`wMin 1 Characters.");
											p.Insert(0), p.Insert(1), p.CreatePacket(peer);
											vip_color = "";
											break;
										}
										vip_color = text;
										// Mengubah nilai "far" dengan menggunakan itemid sebagai kunci
										jsonData["vip_color"] = text;
										// Menulis kembali ke file JSON
										std::ofstream outFile(filename);
										outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
										outFile.close();
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										p.Insert("`wSetting Updated.");
										p.Insert(0), p.Insert(1), p.CreatePacket(peer);

										}
						else if (cch.find("action|dialog_return\ndialog_name|textcolorhelper") != string::npos) {//
							if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
							string text = explode("\n", explode("textBotss|", cch)[1])[0];
							std::string filename = "./config/color_role.json";
							// Membaca file JSON
							json jsonData;
							std::ifstream configFile(filename);
							configFile >> jsonData;
							configFile.close();
							if (text.length() > 20) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMax 20 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else if (text.length() < 1) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMin 1 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								helper_color = "";
								break;
							}
							helper_color = text;
							// Mengubah nilai "far" dengan menggunakan itemid sebagai kunci
							jsonData["helper_color"] = text;
							// Menulis kembali ke file JSON
							std::ofstream outFile(filename);
							outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
							outFile.close();
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							p.Insert("`wSetting Updated.");
							p.Insert(0), p.Insert(1), p.CreatePacket(peer);

							}
						else if (cch.find("action|dialog_return\ndialog_name|textcolorudev") != string::npos) {//
							if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
							string text = explode("\n", explode("textBotss|", cch)[1])[0];
							std::string filename = "./config/color_role.json";
							// Membaca file JSON
							json jsonData;
							std::ifstream configFile(filename);
							configFile >> jsonData;
							configFile.close();
							if (text.length() > 20) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMax 20 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else if (text.length() < 1) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMin 1 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								udev_color = "";
								break;
							}
							udev_color = text;
							// Mengubah nilai "far" dengan menggunakan itemid sebagai kunci
							jsonData["udev_color"] = text;
							// Menulis kembali ke file JSON
							std::ofstream outFile(filename);
							outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
							outFile.close();
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							p.Insert("`wSetting Updated.");
							p.Insert(0), p.Insert(1), p.CreatePacket(peer);

						    }
						else if (cch.find("action|dialog_return\ndialog_name|textcolorcoown") != string::npos) {//
							if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
							string text = explode("\n", explode("textBotss|", cch)[1])[0];
							std::string filename = "./config/color_role.json";
							// Membaca file JSON
							json jsonData;
							std::ifstream configFile(filename);
							configFile >> jsonData;
							configFile.close();
							if (text.length() > 20) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMax 20 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else if (text.length() < 1) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wMin 1 Characters.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								coown_color = "";
								break;
							}
							coown_color = text;
							// Mengubah nilai "far" dengan menggunakan itemid sebagai kunci
							jsonData["coown_color"] = text;
							// Menulis kembali ke file JSON
							std::ofstream outFile(filename);
							outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
							outFile.close();
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							p.Insert("`wSetting Updated.");
							p.Insert(0), p.Insert(1), p.CreatePacket(peer);

							}
						else if (cch.find("action|dialog_return\ndialog_name|changeservername") != string::npos) {
							if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
											string text = explode("\n", explode("textBotss|", cch)[1])[0];
											std::string filename = "./config/config.json";
											// Membaca file JSON
											json jsonData;
											std::ifstream configFile(filename);
											configFile >> jsonData;
											configFile.close();
											if (text.length() > 20) {
												gamepacket_t p;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
												p.Insert("`wMax 20 Characters.");
												p.Insert(0), p.Insert(1), p.CreatePacket(peer);
												break;
											}
											else if (text.length() < 1) {
												gamepacket_t p;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
												p.Insert("`wMin 1 Characters.");
												p.Insert(0), p.Insert(1), p.CreatePacket(peer);
												server_name = "";
												break;
											}
											server_name = "";
											// Mengubah nilai "far" dengan menggunakan itemid sebagai kunci
											jsonData["name"] = text;
											// Menulis kembali ke file JSON
											std::ofstream outFile(filename);
											outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
											outFile.close();
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
											p.Insert("`wSetting Updated.");
											p.Insert(0), p.Insert(1), p.CreatePacket(peer);

											}
						else if (cch.find("action|dialog_return\ndialog_name|linkdc") != string::npos) {
							if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
											string text = explode("\n", explode("textBotss|", cch)[1])[0];
											std::string filename = "./config/community_link.json";
											// Membaca file JSON
											json jsonData;
											std::ifstream configFile(filename);
											configFile >> jsonData;
											configFile.close();
											if (text.length() > 80) {
												gamepacket_t p;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
												p.Insert("`wMax 80 Characters.");
												p.Insert(0), p.Insert(1), p.CreatePacket(peer);
												break;
											}
											else if (text.length() < 1) {
												gamepacket_t p;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
												p.Insert("`wMin 1 Characters.");
												p.Insert(0), p.Insert(1), p.CreatePacket(peer);
												discord_link = "";
												break;
											}
											discord_link = "";
											// Mengubah nilai "far" dengan menggunakan itemid sebagai kunci
											jsonData["discordlink"] = text;
											// Menulis kembali ke file JSON
											std::ofstream outFile(filename);
											outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
											outFile.close();
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
											p.Insert("`wSetting Updated.");
											p.Insert(0), p.Insert(1), p.CreatePacket(peer);

											}
						else if (cch.find("action|dialog_return\ndialog_name|linkwa") != string::npos) {
							if (pInfo(peer)->tankIDName != clist1 && pInfo(peer)->tankIDName != "iAlfa") break;
												string text = explode("\n", explode("textBotss|", cch)[1])[0];
												std::string filename = "./config/community_link.json";
												// Membaca file JSON
												json jsonData;
												std::ifstream configFile(filename);
												configFile >> jsonData;
												configFile.close();
												if (text.length() > 80) {
													gamepacket_t p;
													p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
													p.Insert("`wMax 80 Characters.");
													p.Insert(0), p.Insert(1), p.CreatePacket(peer);
													break;
												}
												else if (text.length() < 1) {
													gamepacket_t p;
													p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
													p.Insert("`wMin 1 Characters.");
													p.Insert(0), p.Insert(1), p.CreatePacket(peer);
													whatsapp_link = "";
													break;
												}
												whatsapp_link = text;
												// Mengubah nilai "far" dengan menggunakan itemid sebagai kunci
												jsonData["walink"] = text;
												// Menulis kembali ke file JSON
												std::ofstream outFile(filename);
												outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
												outFile.close();
												gamepacket_t p;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
												p.Insert("`wSetting Updated.");
												p.Insert(0), p.Insert(1), p.CreatePacket(peer);

												}
										else if (cch.find("action|dialog_return\ndialog_name|start_ray") != string::npos) {
											if (!(pInfo(peer)->ray)) {
												pInfo(peer)->ray = 1;
												Algorithm::send_overlay(peer, "Registration Succesfull");
											}
										}
										if (cch.find("buttonClicked|cda_1") != string::npos) {
											c_daily(peer, true, "tab_1", 0);
										}
										if (cch.find("buttonClicked|cda_2") != string::npos) {
											c_daily(peer, true, "tab_2", 0);
										}
										else if (cch.find("action|dialog_return\ndialog_name|punch_event\n") != string::npos) {
											if (cch.find("buttonClicked|event_1") != string::npos) {
												if (!(pInfo(peer)->punch_count >= 500)) {
													gamepacket_t p;
													p.Insert("OnTextOverlay");
													p.Insert("Hey! Go break again, slave!");
													p.CreatePacket(peer);
												}
												else if (pInfo(peer)->udah2 >= 1) {
													gamepacket_t p;
													p.Insert("OnTextOverlay");
													p.Insert("Hey! You have already claimed the reward!");
													p.CreatePacket(peer);
												}
												else if (pInfo(peer)->punch_count >= 500) {
													int got = 2;
													pInfo(peer)->gems += 10000;
													pInfo(peer)->udah2 = 1;
													modify_inventory(peer, 1796, got);
													gamepacket_t px;
													px.Insert("OnAddNotification");
													px.Insert("interface/large/anni_plu.rttex");
													px.Insert("`wYou claimed the 1 reward!!");
													px.CreatePacket(peer);
												}
											}
											else if (cch.find("buttonClicked|event_2") != string::npos) {
												if (!(pInfo(peer)->punch_count >= 5000)) {
													gamepacket_t p;
													p.Insert("OnTextOverlay");
													p.Insert("Hey! Go break again, slave!");
													p.CreatePacket(peer);
												}
												else if (pInfo(peer)->udah3 >= 1) {
													gamepacket_t p;
													p.Insert("OnTextOverlay");
													p.Insert("Hey! You have already claimed the reward!");
													p.CreatePacket(peer);
												}
												else if (pInfo(peer)->punch_count >= 5000) {
													int got = 10, got2 = 5;
													pInfo(peer)->gems += 100000;
													pInfo(peer)->udah3 = 1;
													modify_inventory(peer, 1796, got);
													modify_inventory(peer, 9814, got2);
													gamepacket_t px;
													px.Insert("OnAddNotification");
													px.Insert("interface/large/anni_plu.rttex");
													px.Insert("`wYou claimed the 2 reward!!");
													px.CreatePacket(peer);
												}
											}
										}
										else if (cch.find("buttonClicked|gems_takes") != string::npos) {
											int gemsInBank = pInfo(peer)->currentGemsInBank;
											int gemsInput = 0;
											if (gemsInBank > 2147483647) {
												gemsInput = 2147483647;
											}
											else {
												gemsInput = pInfo(peer)->currentGemsInBank;
											}
											if (gemsInBank == 0 || gemsInBank <= 0) break;
											gamepacket_t p;//withdraw
											p.Insert("OnDialogRequest");
											p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWithdraw Gems````|left|112|\nadd_label|small|Withdraw how many? (you have " + setGems(gemsInBank) + " in the bank)|left|\nadd_text_input|gems_withdraw|Amount:|" + to_string(gemsInput) + "|10|\nadd_spacer|small|\nadd_button|112w_gems|`wWithdraw!|noflags|0|0|\nend_dialog|gems_deposit|Nevermind.||");
											p.CreatePacket(peer);
											break;
										}

										if (cch.find("buttonClicked|gems_depo") != string::npos) {
											int gemsInacc = 0;
											if (pInfo(peer)->gems <= 0) break;
											gamepacket_t p;
											p.Insert("OnDialogRequest");
											p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDeposit Gems``|left|112|\nadd_label|small|Deposit how many? (you have " + to_string(pInfo(peer)->gems) + ")|left|\nadd_text_input|gems_count|Amount:|" + to_string(pInfo(peer)->gems) + "|10|\nadd_spacer|small|\nadd_button|deposit_gems|Deposit|noflags|0|0|\nend_dialog|gems_deposit|Nevermind.||");
											p.CreatePacket(peer);
											break;
										}

										// Deposit Gems Bank
										else if (cch.find("buttonClicked|deposit_gems") != string::npos) {
											try {
												int count = atoi(explode("\n", explode("gems_count|", cch)[1])[0].c_str());
												int receive = 0;
												int gemsInBank = pInfo(peer)->currentGemsInBank;
												if (count <= 0 || count > pInfo(peer)->gems) {
													gamepacket_t p;
													p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
												}
												else if (pInfo(peer)->gems == 0) {
													gamepacket_t p;
													p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
												}
												else {
													int totalBank = 0;
													totalBank += gemsInBank - count;
													string name_ = pInfo(peer)->world;
													vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });

													if (p != worlds.end()) {
														pInfo(peer)->currentGemsInBank += count;
														packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
														gamepacket_t p5;
														p5.Insert("OnSetBux");
														p5.Insert(pInfo(peer)->gems -= count);
														p5.Insert(0);
														p5.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
														if (pInfo(peer)->supp >= 2) {
															p5.Insert((float)33796, (float)1, (float)0);
														}
														p5.CreatePacket(peer);
														gamepacket_t p1, p2;
														p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("`wDeposited `$" + to_string(count) + "`` Gems! You have `$" + to_string(pInfo(peer)->currentGemsInBank) + "`` in the bank now."), p1.CreatePacket(peer);

													}
												}
											}
											catch (...) {
												break;
											}
										}

										// Withdraw Gems Bank (FIXED DUPE)
										else if (cch.find("buttonClicked|112w_gems") != string::npos) {
											try {
												int count = atoi(explode("\n", explode("gems_withdraw|", cch)[1])[0].c_str());
												int got = 0, receive = 0, itemID = 0;
												int bank = pInfo(peer)->currentGemsInBank;

												if (count <= 0 || count > pInfo(peer)->currentGemsInBank) {
													gamepacket_t p;
													p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
												}
												else if (pInfo(peer)->currentGemsInBank == 0) {
													gamepacket_t p;
													p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
												}
												else {
													if (pInfo(peer)->gems < 2147483647) {
														pInfo(peer)->currentGemsInBank -= count;
														packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
														gamepacket_t p5;
														p5.Insert("OnSetBux");
														p5.Insert(pInfo(peer)->gems += count);
														p5.Insert(0);
														p5.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
														if (pInfo(peer)->supp >= 2) {
															p5.Insert((float)33796, (float)1, (float)0);
														}
														p5.CreatePacket(peer);
														gamepacket_t p1, p2, p3;
														p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("`2You Withdraw " + to_string(count) + " Gems!`` You have " + to_string(pInfo(peer)->currentGemsInBank) + " in the bank now."), p1.CreatePacket(peer);
													}
												}
											}
											catch (...) {
												break;
											}
											break;
										}
										else if (cch.find("action|dialog_return\ndialog_name|khodam_end") != string::npos) {
											if (cch.find("buttonClicked|cek_khodam") != string::npos) {
												gamepacket_t p;
												p.Insert("OnTextOverlay");
												p.Insert("`2Your `3Khodam `4Ambaruwo");
												p.Insert(9);
												p.CreatePacket(peer);
											}
										}
										else if (cch.find("action|dialog_return\ndialog_name|items_end") != string::npos) {
											if (cch.find("buttonClicked|items_price") != string::npos) {
												ifstream ifs("config/items_price.json");
												json j = json::parse(ifs);
												Algorithm::OnDialogRequest(peer, "set_default_color|`o\n"
													"add_label_with_icon|big|Items Price's|left|1340|\n"
													"add_spacer|small|\n"
													"add_textbox|`9Legendary Wizard: " + j["lwiz_price"].get<string>() + "|left|\n"
													"add_textbox|`9Legendary Wings: " + j["lwing_price"].get<string>() + "|left|\n"
													"add_textbox|`9Golden Legendary Wings: " + j["glwing_price"].get<string>() + "|left|\n"
													"add_textbox|`9Legendary Dragon Knight Wings: " + j["ldkw_price"].get<string>() + "|left|\n"
													"add_textbox|`9Whip of Truth: " + j["whip_price"].get<string>() + "|left|\n"
													"add_textbox|`#Legendary Rayman's Fist: " + j["lray_price"].get<string>() + "|left|\n"
													"add_textbox|`bMythical Rayman's Fist: " + j["mray_price"].get<string>() + "|left|\n"
													"add_textbox|`7Lightning Rayman's Fist: " + j["light_price"].get<string>() + "|left|\n"
													"add_textbox|`2The Serpent: " + j["serpent_price"].get<string>() + "|left|\n"
													"add_textbox|`5Kitsune Mask: " + j["kitsune_price"].get<string>() + "|left|\n"
													"add_textbox|`$Apocalypse Rayman's Fist: " + j["apocal_price"].get<string>() + "|left|\n"
													"add_textbox|`#Galaxy Magplant: " + j["galaxy_price"].get<string>() + "|left|\n"
													"add_textbox|`6Golden Heart Crystal: " + j["ghc_price"].get<string>() + "|left|\n"
													"add_textbox|`4Cheater Role 7 Day: " + j["7day_price"].get<string>() + "|left|\n"
													"add_textbox|`cUltra World Spray: " + j["uws_price"].get<string>() + "|left|\n"
													"add_textbox|`$IOTM Mystery Box: " + j["iotm_price"].get<string>() + "|left|\n"
													"add_textbox|`5The Dark Stone: " + j["tds_price"].get<string>() + "|left|\n"
													"add_textbox|`9Legendary Katana: " + j["lkat_price"].get<string>() + "|left|\n"
													"add_spacer|small|\n"
													"\nend_dialog|gazette|CLOSE|\n"
												);
											}
										}
										else if (cch.find("action|dialog_return\ndialog_name|role_end") != string::npos) {
											if (cch.find("buttonClicked|role_price") != string::npos) {
												ifstream ifs("config/role_price.json");
												json j = json::parse(ifs);
												Algorithm::OnDialogRequest(peer, "set_default_color|`o\n"
													"add_label_with_icon|big|Role Price's|left|9852|\n"
													"add_spacer|small|\n"
													"add_textbox|VIP: " + j["vip_price"].get<string>() + "|left|\n"
													"add_textbox|MVP: " + j["mvp_price"].get<string>() + "|left|\n"
													"add_textbox|Nick Role: " + j["nick_price"].get<string>() + "|left|\n"
													"add_textbox|Ghost Role: " + j["ghost_price"].get<string>() + "|left|\n"
													"add_textbox|Cheater: " + j["cheat_price"].get<string>() + "|left|\n"
													"add_textbox|Moderator: " + j["mod_price"].get<string>() + "|left|\n"
													"add_textbox|Super-Mod: " + j["smod_price"].get<string>() + "|left|\n"
													"add_textbox|Ultra Mod: " + j["umod_price"].get<string>() + "|left|\n"
													"add_textbox|Developer: " + j["dev_price"].get<string>() + "|left|\n"
													"add_textbox|Find Role `9[ `4SPECIAL `9]`o: " + j["find_price"].get<string>() + "|left|\n"
													"add_textbox|Ultra Developer: " + j["udev_price"].get<string>() + "|left|\n"
													"add_textbox|Helper: " + j["helper_price"].get<string>() + "|left|\n"
													"add_textbox|Co Own: " + j["co_price"].get<string>() + "|left|\n"
													"add_textbox|Creator: " + j["clist_price"].get<string>() + "|left|\n"
													"add_textbox|Give Role: " + j["give_price"].get<string>() + "|left|\n"
													"add_spacer|small|\nadd_smalltext|Want to buy a role? Press the button below|left|\nadd_url_button|comment|Purchase Role||" + j["link"].get<string>() + "|Press launch button if you want to purchase role|0|0|\nadd_quick_exit|\nend_dialog|gazette|CLOSE||"
												);
											}
											}
										else if (cch.find("action|dialog_return\ndialog_name|battle_pvp") != string::npos) {
											try {
												int bet = 0, netID = 0, Opponent = 0;
												bool Found = false;
												if (cch.find("bet|") != string::npos) bet = atoi(explode("\n", explode("bet|", cch)[1])[0].c_str());
												if (cch.find("netID|") != string::npos) netID = atoi(explode("\n", explode("netID|", cch)[1])[0].c_str());
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world or pInfo(currentPeer)->PVP_Enemy != pInfo(peer)->tankIDName) continue;
													Found = true;
													Opponent = pInfo(currentPeer)->PVP_Bet;
													break;
												}
												gamepacket_t p;
												p.Insert("OnTalkBubble"); p.Insert(pInfo(peer)->netID);
												if (bet < 100 or bet > 5000) p.Insert("You can only bet between 100 - 5000 gems!");
												else if (bet > pInfo(peer)->gems) p.Insert("You doesn't have enough gems!");
												else if (Found and bet != Opponent) p.Insert("Your opponent bet is " + setGems(Opponent) + ", you can only bet at the same amount!");
												else if (pInfo(peer)->PVP_netID != -1) p.Insert("You already request a PVP battle with someone!");
												else {
													{
														pInfo(peer)->gems -= bet;
														gamepacket_t p;
														p.Insert("OnSetBux"); p.Insert(pInfo(peer)->gems); p.Insert(0); p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
														if (pInfo(peer)->supp >= 2) p.Insert((float)GetServerTime(), (float)1, (float)0);
														p.CreatePacket(peer);
													}
													p.Insert("Succesfully asking for battle!");
													pInfo(peer)->PVP_netID = netID; pInfo(peer)->PVP_Bet = bet;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world or pInfo(currentPeer)->netID != pInfo(peer)->PVP_netID) continue;
														pInfo(peer)->PVP_Enemy = pInfo(currentPeer)->tankIDName;
														if (pInfo(peer)->PVP_Enemy == pInfo(currentPeer)->tankIDName and Found) Start_PVP(peer, currentPeer);
														else {
															gamepacket_t p;
															p.Insert("OnConsoleMessage");
															p.Insert("`2BATTLE PVP``: " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` asking you for a PVP battle for " + setGems(bet) + " gems! Wrench him/her to accept the battle.");
															p.CreatePacket(currentPeer);
															packet_(currentPeer, "action|play_sfx\nfile|audio/siren.wav\ndelayMS|0");
														}
													}
												}
												p.Insert(0), p.Insert(1);
												p.CreatePacket(peer);
											}
											catch (...) {
												break;
											}
											break;
											}
							else if (cch.find("action|dialog_return\ndialog_name|kalkulator") != string::npos) {
							int angkaPertama = atoi(explode("\n", explode("angkaPertama|", cch)[1])[0].c_str());
							int angkaKedua = atoi(explode("\n", explode("angkaKedua|", cch)[1])[0].c_str());
							string type = explode("\n", explode("type|", cch)[1])[0];
							if (type.length() > 1 or type.length() < 1) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wPlease fill Type With Symbol!!");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							if (type.find_first_not_of("x:+-") != string::npos) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								p.Insert("`wType can only be filled with symbols +/-/:/x");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else {
								int result = 0;
								if (type == "x") {
									result = (angkaPertama * angkaKedua);
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("`9Result >> `2" + to_string(result) + "");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(peer);
								}
								if (type == ":") {
									result = (angkaPertama / angkaKedua);
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("`9Result >> `2" + to_string(result) + "");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(peer);
								}
								else if (type == "-") {
									result = (angkaPertama - angkaKedua);
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("`9Result >> `2" + to_string(result) + "");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(peer);
								}
								else if (type == "+") {
									result = (angkaPertama + angkaKedua);
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("`9Result >> `2" + to_string(result) + "");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(peer);
								}
							}
						}
							else if (cch.find("action|dialog_return\ndialog_name|mathquiz") != string::npos) {
								int angkaPertama = atoi(explode("\n", explode("angkaPertama|", cch)[1])[0].c_str());
								int angkaKedua = atoi(explode("\n", explode("angkaKedua|", cch)[1])[0].c_str());
								int hadiah = atoi(explode("\n", explode("prize|", cch)[1])[0].c_str());
								string type = explode("\n", explode("type|", cch)[1])[0];
								if (not pInfo(peer)->creatorlist) break;
								if (type.length() > 1 or type.length() < 1) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									p.Insert("`wPlease fill Type With Symbol!!");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									break;
								}
								if (type.find_first_not_of("x:+-") != string::npos) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									p.Insert("`wType can only be filled with symbols +/-/:/x");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									break;
								}
								if (angkaPertama < 1 || angkaKedua < 1) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									p.Insert("`wWho the hell will make quiz like that?");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									break;
								}
								else {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									int result = 0;
									mtk.prize = hadiah;
									mathlogs(pInfo(peer)->tankIDName + " Using /setmath with prize " + to_string(hadiah) + " Gems");
									if (type == "x") {
										mtk.quiz = (angkaPertama * angkaKedua);
										mtk.mtk = true;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`9Limited Math Quiz!Ĩ What is `0" + to_string(angkaPertama) + type + to_string(angkaKedua) + "`9.`1Use /as for answer the math and you will receive "+to_string(mtk.prize) + "ė");
										p.CreatePacket(currentPeer);
									}
									if (type == ":") {
										mtk.quiz = (angkaPertama / angkaKedua);
										mtk.mtk = true;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`9Limited Math Quiz!Ĩ What is `0" + to_string(angkaPertama) + type + to_string(angkaKedua) + "`9.`1Use /as for answer the math and you will receive " + to_string(mtk.prize) + "ė");
										p.CreatePacket(currentPeer);
									}
									else if (type == "-") {
										mtk.quiz = (angkaPertama - angkaKedua);
										mtk.mtk = true;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`9Limited Math Quiz!Ĩ What is `0" + to_string(angkaPertama) + type + to_string(angkaKedua) + "`9.`1Use /as for answer the math and you will receive " + to_string(mtk.prize) + "ė");
										p.CreatePacket(currentPeer);
									}
									else if (type == "+") {
										mtk.quiz = (angkaPertama + angkaKedua);
										mtk.mtk = true;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`9Limited Math Quiz!Ĩ What is `0" + to_string(angkaPertama) + type + to_string(angkaKedua) + "`9.`1Use /as for answer the math and you will receive " + to_string(mtk.prize) + "ė");
										p.CreatePacket(currentPeer);
									}
								}
							}
						}
							else if (cch.find("action|dialog_return\ndialog_name|itemmath") != string::npos) {
								int angkaPertama = atoi(explode("\n", explode("angkaPertama|", cch)[1])[0].c_str());
								int angkaKedua = atoi(explode("\n", explode("angkaKedua|", cch)[1])[0].c_str());
								int hadiah = atoi(explode("\n", explode("prize|", cch)[1])[0].c_str());
								int berapa = atoi(explode("\n", explode("count|", cch)[1])[0].c_str());
								string type = explode("\n", explode("type|", cch)[1])[0];
								if (not pInfo(peer)->creatorlist) break;
								if (type.length() > 1 or type.length() < 1) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									p.Insert("`wPlease fill Type With Symbol!!");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									break;
								}
								if (type.find_first_not_of("x:+-") != string::npos) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									p.Insert("`wType can only be filled with symbols +/-/:/x");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									break;
								}
								if (angkaPertama < 1 || angkaKedua < 1) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									p.Insert("`wWho the hell will make quiz like that?");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									break;
								}
								else {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										int item = 0;
										mtk.prize = berapa;
										mtk.id = hadiah;
										modify_inventory(peer, mtk.id, item);
										packet_(currentPeer, "action|play_sfx\nfile|audio/snd037.wav\ndelayMS|0");
										mathlogs(pInfo(peer)->tankIDName + " Using /setmaths with prize " + to_string(berapa) + items[mtk.id].name + "");
										if (type == "x") {
											mtk.quiz = (angkaPertama * angkaKedua);
											mtk.mtk = true;
											mtk.mtkitem = true;
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`9Limited Math Quiz!Ĩ What is `0" + to_string(angkaPertama) + type + to_string(angkaKedua) + "`9.`1Use /as for answer the math and you will receive `1"+ to_string(berapa) + " " + items[mtk.id].name + "");
											p.CreatePacket(currentPeer);
										}
										if (type == ":") {
											mtk.quiz = (angkaPertama / angkaKedua);
											mtk.mtk = true;
											mtk.mtkitem = true;
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`9Limited Math Quiz!Ĩ What is `0" + to_string(angkaPertama) + type + to_string(angkaKedua) + "`9.`1Use /as for answer the math and you will receive `1" + to_string(berapa) + " " + items[mtk.id].name + "");
											p.CreatePacket(currentPeer);
										}
										else if (type == "-") {
											mtk.quiz = (angkaPertama - angkaKedua);
											mtk.mtk = true;
											mtk.mtkitem = true;
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`9Limited Math Quiz!Ĩ What is `0" + to_string(angkaPertama) + type + to_string(angkaKedua) + "`9.`1Use /as for answer the math and you will receive `1" + to_string(berapa) + " " + items[mtk.id].name + "");
											p.CreatePacket(currentPeer);
										}
										else if (type == "+") {
											mtk.quiz = (angkaPertama + angkaKedua);
											mtk.mtk = true;
											mtk.mtkitem = true;
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`9Limited Math Quiz!Ĩ What is `0" + to_string(angkaPertama) + type + to_string(angkaKedua) + "`9.`1Use /as for answer the math and you will receive `1" + to_string(berapa) + " " + items[mtk.id].name + "");
											p.CreatePacket(currentPeer);
										}
									}
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|quizzs") != string::npos) {
								int hadiah = atoi(explode("\n", explode("prize|", cch)[1])[0].c_str());
								int berapa = atoi(explode("\n", explode("count|", cch)[1])[0].c_str());
								string type = explode("\n", explode("ask|", cch)[1])[0];
								string jawaban = explode("\n", explode("jwb|", cch)[1])[0];
								if (not pInfo(peer)->creatorlist) break;
								if (type.length() < 1) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									p.Insert("`wPlease fill it with any questions!!");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									break;
								}
								if (jawaban.length() < 1) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									p.Insert("`wPlease fill it with an answer!!");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									break;
								}
								else {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										int item = 0;
										quiz.prize = berapa;
										quiz.id = hadiah;
										quiz.jawaban = jawaban;
										modify_inventory(peer, mtk.id, item);
										packet_(currentPeer, "action|play_sfx\nfile|audio/snd037.wav\ndelayMS|0");
										mathlogs(pInfo(peer)->tankIDName + " Using /setquiz with prize " + to_string(berapa) + items[quiz.id].name + "");
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`9Limited Quiz!Ĩ `0" + type + "`9.`1Use /ans for answer the math and you will receive `2" + to_string(berapa) + " " + items[quiz.id].name + "");
										p.CreatePacket(currentPeer);
									}
								}
							}
				        if (cch.find("action|dialog_return\ndialog_name|growdice_dialog") != string::npos) {
							if (cch.find("buttonClicked|casinogem") != string::npos) {
								Sendcmd(peer, "/casino", true);
								break;
							}
							else if (cch.find("buttonClicked|slotgem") != string::npos) {
								growdice_game(peer, "grow_menu");
								break;
							}
							else if (cch.find("buttonClicked|limbogem") != string::npos) {
								growdice_game(peer, "limbo");
								break;
							}
						}
						if (cch.find("action|dialog_return\ndialog_name|game_slot\nbuttonClicked|limbo") != string::npos) {
							int count = atoi(explode("\n", explode("bet_slot|", cch)[1])[0].c_str());
							int kali = atoi(explode("\n", explode("dikali|", cch)[1])[0].c_str());
							string type = explode("\n", explode("type|", cch)[1])[0];
							int randomm = kali * 10;
							int kalah = kali / 2;
							int rands = kali - kalah;
							int got = pInfo(peer)->bank_p;
							int gots = pInfo(peer)->bbbgl;
							if (type.length() < 1) {
								Algorithm::send_console(peer, "`4INVALID TYPE");
								break;
							}
							if (type == "BGL") {
								if (count < 1) {
									Algorithm::send_overlay(peer, "`4INVALID COUNT");
									break;
								}
								else if (kali < 2) {
									Algorithm::send_overlay(peer, "`4INVALID MULTIPLIES");
									break;
								}
								else if (got < count) {
									Algorithm::send_bubble(peer, pInfo(peer)->netID, "You don't have that much Blue Gem Lock");
									break;
								}
								else if (rand() % randomm < 2) {
									pInfo(peer)->bank_p -= count;
									pInfo(peer)->bank_p += count * kali;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|You Won on Limbo Game!|left|7188|\nadd_spacer|small|\nadd_textbox|The Limbo Stopped at " + to_string(kali) + " and your Bet now Multiplied "+to_string(kali) + "X|left|\nend_dialog|game_slot|Back||");
									p.CreatePacket(peer);
									break;
								}
								else {
									pInfo(peer)->bank_p -= count;
									Algorithm::send_overlay(peer, "`4You Lose");
									Algorithm::send_console(peer, "You Lose on Limbo Game, the Limbo stopped at "+to_string(rands)+"X, Better Luck Next time!");
									break;
								}
							}
							if (type == "GGL") {
								if (count < 1) {
									Algorithm::send_overlay(peer, "`4INVALID COUNT");
									break;
								}
								else if (kali < 2) {
									Algorithm::send_overlay(peer, "`4INVALID MULTIPLIES");
									break;
								}
								else if (gots < count) {
									Algorithm::send_bubble(peer, pInfo(peer)->netID, "You don't have that much Golden Gem Lock");
									break;
								}
								else if (rand() % randomm < 2) {
									pInfo(peer)->bbbgl -= count;
									pInfo(peer)->bbbgl += count * kali;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|You Won on Limbo Game!|left|8470|\nadd_spacer|small|\nadd_textbox|The Limbo Stopped at " + to_string(kali) + " and your Bet now Multiplied " + to_string(kali) + "X|left|\nend_dialog|game_slot|Back||");
									p.CreatePacket(peer);
									break;
								}
								else {
									pInfo(peer)->bbbgl -= count;
									Algorithm::send_overlay(peer, "`4You Lose");
									Algorithm::send_console(peer, "You Lose on Limbo Game, the Limbo stopped at " + to_string(rands) + "X, Better Luck Next time!");
									break;
								}
							}
						}
						if (cch.find("action|dialog_return\ndialog_name|game_slot") != string::npos) {
							if (cch.find("buttonClicked|playagain") != string::npos) {
								srand((unsigned)time(NULL));
								int count = atoi(explode("\n", explode("bet_slot|", cch)[1])[0].c_str());
								int xas = rand() % 8 + 1;
								int got = 0;
								got = pInfo(peer)->bank_p;
								
								if (count < 0 or count > got) goto menu_slot;
								else if (got < 0 or got < count) goto menu_slot;
								else if (got == 0 or count == 0) goto menu_slot;
								else if (count > 10) goto menu_slot;
								else {
									if (xas == 1 or xas == 3 or xas == 5 or xas == 7) {
										if (got > 100000) goto menu_slot;
										if (got == 0) goto menu_slot;
										int gota = 0;
										gota = count * 2;
										pInfo(peer)->bank_p += gota;
										DialogBuilder dialog;
										dialog.add_image_button("", "slot_win.rttex", "OPENDIALOG", "")
											.add_smalltext(format("`2Nice to see you back`` {}``, <CR>`0To play this game you need `cBgl(Blue Gem Lock)`` which is in the bank and make sure you have more than 1 Bgl!", pInfo(peer)->name_color + pInfo(peer)->tankIDName))
											.add_smalltext("`5Please remember! `0If you `4lose`0, you will lose your Bgl to how many Bet you placed and If you `2win`0, you will get back Bgl 2X according to how many Bet you placed!")
											.add_spacer(false)
											.add_label_icon(false, 7188, format("`$You have : `3{}`` in the bank.", setGems(pInfo(peer)->bank_p)))
											.add_label_icon(false, 7188, format("`$You win (`2+x{} Bgl``) from placing a bet (`9{}``)", fixint(gota), std::to_string(count)))
											.add_textbox("`2Playing!``")
											.add_text_input(3, "bet_slot", "`0Put your bet:``", "1")
											.add_static_icon_button("playagain", 758, "`2Playing Game", "`2Playing Game``")
											.end_list()
											//.add_smalltext("`0Good luck!``")
											.add_spacer(false)
											.end_dialog("game_slot", "Cancel", "");
										enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(dialog.to_string()).pack());
										packet_(peer, "action|play_sfx\nfile|audio/slot_win.wav\ndelayMS|0");
									}
									else if (xas == 2 or xas == 4 or xas == 6 or xas == 8 or xas == 5) {
										if (got == 0) goto menu_slot;
										int lose = count * 2;
										pInfo(peer)->bank_p -= lose;
										DialogBuilder dialog;
										dialog.add_image_button("", "slot_lose.rttex", "OPENDIALOG", "")
											.add_smalltext(format("`2Nice to see you back`` {}``, <CR>`0To play this game you need `cBgl(Blue Gem Lock)`` which is in the bank and make sure you have more than 1 Bgl!", pInfo(peer)->name_color + pInfo(peer)->tankIDName))
											.add_smalltext("`5Please remember! `0If you `4lose`0, you will lose your Bgl to how many Bet you placed and If you `2win`0, you will get back Bgl 2X according to how many Bet you placed!")
											.add_spacer(false)
											.add_label_icon(false, 7188, format("`$You have : `3{}`` in the bank.", setGems(pInfo(peer)->bank_p)))
											.add_label_icon(false, 7188, format("`$You lose (`4-x{}``) from placing a bet (`9{}``)", fixint(lose), std::to_string(count)))
											.add_textbox("`2Playing!``")
											.add_text_input(3, "bet_slot", "`0Put your bet:``", "1")
											.add_static_icon_button("playagain", 758, "`2Playing Game", "`2Playing Game``")
											.end_list()
											//.add_smalltext("`0Good luck!``")
											.add_spacer(false)
											.end_dialog("game_slot", "Cancel", "");
										enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(dialog.to_string()).pack());
										packet_(peer, "action|play_sfx\nfile|audio/slot_lose.wav\ndelayMS|0");
									}
								}
								menu_slot:
								DialogBuilder fail;
								fail.add_image_button("", "slot_banner.rttex", "OPENDIALOG", "")
									.add_smalltext(format("`2Nice to see you back`` {}``, <CR>`0To play this game you need `cBgl(Blue Gem Lock)`` which is in the bank and make sure you have more than 1 Bgl!", pInfo(peer)->name_color + pInfo(peer)->tankIDName))
									.add_smalltext("`5Please remember! `0If you `4lose`0, you will lose your Bgl to how many Bet you placed and If you `2win`0, you will get back Bgl 2X according to how many Bet you placed!")
									.add_spacer(false)
									.add_smalltext("`4Try Again! Please enter the correct number!")
									.add_label_icon(false, 7188, format("`$You have : `3{}`` in the bank.", setGems(pInfo(peer)->bank_p)))
									.add_textbox("`2Playing!``")
									.add_text_input(3, "bet_slot", "`0Put your bet:``", "")
									.add_static_icon_button("playagain", 758, "`2Playing Game", "`2Playing Game``")
									.end_list()
									//.add_smalltext("`0Good luck!``")
									.add_spacer(false)
									.end_dialog("game_slot", "Cancel", "");
								enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(fail.to_string()).pack());
							}
							break;
						}			
						if (cch.find("action|dialog_return\ndialog_name|kit_pass") != string::npos) {
							std::string filename = "./config/kit_prize.json";
							// Membaca file JSON
							json jsonData;
							std::ifstream configFile(filename);
							configFile >> jsonData;
							configFile.close();
							int kit1 = jsonData["prize_1"].get<int>();
							int kit2 = jsonData["prize_2"].get<int>();
							int kit3 = jsonData["prize_3"].get<int>();
							int kit4 = jsonData["prize_4"].get<int>();
							int kit5 = jsonData["prize_5"].get<int>();
							int kit6 = jsonData["prize_6"].get<int>();
							int kit7 = jsonData["prize_7"].get<int>();
							if (cch.find("buttonClicked|tab_1") != string::npos) kit_Pass(peer, true, "tab_1", 0);
							else if (cch.find("buttonClicked|tab_2") != string::npos) kit_Pass(peer, true, "tab_2", 0);
							//kit1
							else if (cch.find("buttonClicked|info_5480") != string::npos) {
								string pass = "";
								if (pInfo(peer)->Kit_Poin >= 499 && pInfo(peer)->claim_kit == false) pass += "\nadd_button|claim-5480|`wClaim Rewards``|noflags|0|0|";
								else  pass += "\nadd_button||`wRewards Locked``|off|0|0|";
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|\nadd_label_with_icon|small|Claim `3" + items[kit1].ori_name + "`` |left|"+to_string(kit1)+"|"
									"\nadd_spacer|small|"
									"\nadd_textbox|`5" + items[kit1].description + "`` from KitPass lvl 1 & `2500 points!``|left|"
									"\nadd_spacer|small|" + pass + "\nadd_spacer|small|\nadd_button|tab_1|`wBack to Menu``|noflags|0|0|\nend_dialog|kit_pass|||");
								p.CreatePacket(peer);
							}
							else if (cch.find("buttonClicked|claim-5480") != string::npos) {
								//int item = atoi(cch.substr(57, cch.length() - 57).c_str());
								if (pInfo(peer)->claim_kit == false) {
									int count = 1, itemID = 0;
									if (modify_inventory(peer, kit1, count) == 0) {
										pInfo(peer)->claim_kit = true;
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("Congratulations! You have received 1 `8" + items[kit1].ori_name + "`` from KitPass Reward!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
										PlayerMoving data_{};
										data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
										BYTE* raw = packPlayerMoving(&data_);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
										delete[] raw;
										kit_Pass(peer, true, "tab_1", 0);
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("You have full inventory space!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(peer);
									}
								}
							}
							//kit2
							else if (cch.find("buttonClicked|info_12868") != string::npos) {
								string pass = "";
								if (pInfo(peer)->Kit_Poin >= 999 && pInfo(peer)->claim_kit1 == false) pass += "\nadd_button|claim-12868|`wClaim Rewards``|noflags|0|0|";
								else  pass += "\nadd_button||`wRewards Locked``|off|0|0|";
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|\nadd_label_with_icon|big|Claim `3" + items[kit2].ori_name + "`` |left|"+to_string(kit2) + "|"
									"\nadd_spacer|small|"
									"\nadd_textbox|`wYou can claim `5" + items[kit2].ori_name + "`` If Your KitPass lvl 2 & point `21000!``|left|"
									"\nadd_spacer|small|" + pass + "\nadd_spacer|small|\nadd_button|tab_1|`wBack to Menu``|noflags|0|0|\nend_dialog|kit_pass|||");
								p.CreatePacket(peer);
							}
							else if (cch.find("buttonClicked|claim-12868") != string::npos) {
								//int item = atoi(cch.substr(57, cch.length() - 57).c_str());
								if (pInfo(peer)->claim_kit1 == false) {
									int count = 1, itemID = 0;
									if (modify_inventory(peer, kit2, count) == 0) {//11118, 6312, 2592, 1782
										pInfo(peer)->claim_kit1 = true;
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("Congratulations! You have received 1 `8" + items[kit2].ori_name + "`` from KitPass Reward!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
										PlayerMoving data_{};
										data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
										BYTE* raw = packPlayerMoving(&data_);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
										delete[] raw;
										kit_Pass(peer, true, "tab_1", 0);
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("You have full inventory space!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(peer);
									}
								}
							}
							//kit3
							else if (cch.find("buttonClicked|info_11118") != string::npos) {
								string pass = "";
								if (pInfo(peer)->Kit_Poin >= 1999 && pInfo(peer)->claim_kit2 == false) pass += "\nadd_button|claim-11118|`wClaim Rewards``|noflags|0|0|";
								else  pass += "\nadd_button||`wRewards Locked``|off|0|0|";
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|\nadd_label_with_icon|big|Claim `3" + items[kit3].ori_name + "`` |left|"+to_string(kit3) + "|"
									"\nadd_spacer|small|"
									"\nadd_textbox|`wYou can claim `5" + items[kit3].ori_name + "`` If Your KitPass lvl 3 & point `22000!``|left|"
									"\nadd_spacer|small|" + pass + "\nadd_spacer|small|\nadd_button|tab_1|`wBack to Menu``|noflags|0|0|\nend_dialog|kit_pass|||");
								p.CreatePacket(peer);
							}
							else if (cch.find("buttonClicked|claim-11118") != string::npos) {
								//int item = atoi(cch.substr(57, cch.length() - 57).c_str());  
								if (pInfo(peer)->claim_kit2 == false) {
									int count = 2, itemID = 0;
									if (modify_inventory(peer, kit3, count) == 0) {//, 6312, 2592, 1782
										pInfo(peer)->claim_kit2 = true;
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("Congratulations! You have received 1 `8" + items[kit3].ori_name + "`` from KitPass Reward!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
										PlayerMoving data_{};
										data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
										BYTE* raw = packPlayerMoving(&data_);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
										delete[] raw;
										kit_Pass(peer, true, "tab_1", 0);
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("You have full inventory space!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(peer);
									}
								}
							}
							//kit4
							else if (cch.find("buttonClicked|info_6312") != string::npos) {
								string pass = "";
								if (pInfo(peer)->Kit_Poin >= 2999 && pInfo(peer)->claim_kit3 == false) pass += "\nadd_button|claim-6312|`wClaim Rewards``|noflags|0|0|";
								else  pass += "\nadd_button||`wRewards Locked``|off|0|0|";
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|\nadd_label_with_icon|big|Claim `3" + items[kit4].ori_name + "`` |left|"+to_string(kit4) + "|"
									"\nadd_spacer|small|"
									"\nadd_textbox|`wYou can claim `5" + items[kit4].ori_name + "`` If Your KitPass lvl 4 & point `23000!``|left|"
									"\nadd_spacer|small|" + pass + "\nadd_spacer|small|\nadd_button|tab_1|`wBack to Menu``|noflags|0|0|\nend_dialog|kit_pass|||");
								p.CreatePacket(peer);
							}
							else if (cch.find("buttonClicked|claim-6312") != string::npos) {
									//int item = atoi(cch.substr(57, cch.length() - 57).c_str());
									if (pInfo(peer)->claim_kit3 == false) {
										int count = 1, itemID = 0;
										if (modify_inventory(peer, kit4, count) == 0) {//, 2592, 1782
											pInfo(peer)->claim_kit3 = true;
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											{
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert("Congratulations! You have received " + to_string(count) + " `8" + items[kit4].ori_name + "`` from KitPass Reward!");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(peer);
											}
											PlayerMoving data_{};
											data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
											delete[] raw;
											kit_Pass(peer, true, "tab_1", 0);
										}
										else {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("You have full inventory space!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
									}
									}
							//kit5
							else if (cch.find("buttonClicked|info_2592") != string::npos) {
								string pass = "";
								if (pInfo(peer)->Kit_Poin >= 3999 && pInfo(peer)->claim_kit4 == false) pass += "\nadd_button|claim-2592|`wClaim Rewards``|noflags|0|0|";
								else  pass += "\nadd_button||`wRewards Locked``|off|0|0|";
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|\nadd_label_with_icon|big|Claim `3" + items[kit5].ori_name + "`` |left|"+to_string(kit5) + "|"
									"\nadd_spacer|small|"
									"\nadd_textbox|`wYou can claim `5" + items[kit5].ori_name + "`` If Your KitPass lvl 5 & point `24000!``|left|"
									"\nadd_spacer|small|" + pass + "\nadd_spacer|small|\nadd_button|tab_1|`wBack to Menu``|noflags|0|0|\nend_dialog|kit_pass|||");
								p.CreatePacket(peer);
							}
							else if (cch.find("buttonClicked|claim-2592") != string::npos) {
									//int item = atoi(cch.substr(57, cch.length() - 57).c_str());
									if (pInfo(peer)->claim_kit4 == false) {
										int count = 1, itemID = 0;
										if (modify_inventory(peer, kit5, count) == 0) {//, 1782
											pInfo(peer)->claim_kit4 = true;
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											{
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert("Congratulations! You have received " + to_string(count) + " `8" + items[kit5].ori_name + "`` from KitPass Reward!");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(peer);
											}
											PlayerMoving data_{};
											data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
											delete[] raw;
											kit_Pass(peer, true, "tab_1", 0);
										}
										else {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("You have full inventory space!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
									}
								}
							//kit6
							else if (cch.find("buttonClicked|info_7188") != string::npos) {
								string pass = "";
								if (pInfo(peer)->Kit_Poin >= 4999 && pInfo(peer)->claim_kit5 == false) pass += "\nadd_button|claim-7188|`wClaim Rewards``|noflags|0|0|";
								else  pass += "\nadd_button||`wRewards Locked``|off|0|0|";
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|\nadd_label_with_icon|big|Claim `3" + items[kit6].ori_name + "`` |left|"+to_string(kit6) + "|"
									"\nadd_spacer|small|"
									"\nadd_textbox|`wYou can claim `5" + items[kit6].ori_name + "`` If Your KitPass lvl 6 & point `25000!``|left|"
									"\nadd_spacer|small|" + pass + "\nadd_spacer|small|\nadd_button|tab_1|`wBack to Menu``|noflags|0|0|\nend_dialog|kit_pass|||");
								p.CreatePacket(peer);
								}
							else if (cch.find("buttonClicked|claim-7188") != string::npos) {
									if (pInfo(peer)->claim_kit5 == false) {
										int count = 1, itemID = 0;
										if (modify_inventory(peer, kit6, count) == 0) {
											pInfo(peer)->claim_kit5 = true;
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											{
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert("Congratulations! You have received " + to_string(count) + " `8" + items[kit6].ori_name + "`` from KitPass Reward!");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(peer);
											}
											PlayerMoving data_{};
											data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
											delete[] raw;
											kit_Pass(peer, true, "tab_1", 0);
										}
										else {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("You have full inventory space!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
									}
								}
							else if (cch.find("buttonClicked|info_7") != string::npos) {
								string pass = "";
								if (pInfo(peer)->Kit_Poin >= 5999 && pInfo(peer)->claim_kit6 == false) pass += "\nadd_button|claim-7|`wClaim Rewards``|noflags|0|0|";
								else  pass += "\nadd_button||`wRewards Locked``|off|0|0|";
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|\nadd_label_with_icon|big|Claim `3" + items[kit7].ori_name + "`` |left|" + to_string(kit7) + "|"
									"\nadd_spacer|small|"
									"\nadd_textbox|`wYou can claim `5" + items[kit7].ori_name + "`` If Your KitPass lvl 7 & point `26000!``|left|"
									"\nadd_spacer|small|" + pass + "\nadd_spacer|small|\nadd_button|tab_1|`wBack to Menu``|noflags|0|0|\nend_dialog|kit_pass|||");
								p.CreatePacket(peer);
								}
							else if (cch.find("buttonClicked|claim-7") != string::npos) {
									if (pInfo(peer)->claim_kit6 == false) {
										int count = 1, itemID = 0;
										if (modify_inventory(peer, kit7, count) == 0) {
											pInfo(peer)->claim_kit6 = true;
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											{
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert("Congratulations! You have received " + to_string(count) + " `8" + items[kit7].ori_name + "`` from KitPass Reward!");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(peer);
											}
											PlayerMoving data_{};
											data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
											delete[] raw;
											kit_Pass(peer, true, "tab_1", 0);
										}
										else {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("You have full inventory space!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
									}
								}
									break;
						}					
						else if (cch == "action|trade_cancel\n") cancel_trade(peer);
						if (pInfo(peer)->trading_with == -1) {
							if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|newbie\n\n") {
								{
									gamepacket_t p(7500), p2, p3;
									p.Insert("OnClearNPCMessage"), p.CreatePacket(peer);
									p2.Insert("OnAddNotification"), p2.Insert("interface/tutorial/tut07_create_world.rttex"), p2.Insert("`wLet's create a worlds! You can create a worlds by enter a random worlds and lock it!``"), p2.Insert("audio/tip_start.wav"), p2.Insert(1), p2.CreatePacket(peer);
									p3.Insert("OnPersistentNPCMessage"), p3.Insert(4032), p3.Insert("Welcome to Growtopia Private Server! Type /help to see all commands.\n`2Pickup`` your newbie rewards and start the journey!"), p3.Insert(1), p3.CreatePacket(peer);
								}
								pInfo(peer)->n = 1;
								if (pInfo(peer)->cc == 0) {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`oYou has been received `9Starter Pack`o, do /niuber before play this server. enjoy(love)");
									p.CreatePacket(peer);
									cout << "A new account has been created, name " + pInfo(peer)->tankIDName + " clicked starter pack" << endl;
									pInfo(peer)->cc = 1;
								}
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|confirm_settopp") != string::npos) {
								string name = explode("\n", explode("name_p|", cch)[1])[0].c_str();
								std::string lol = "config/topactiveplayer.json";
								nlohmann::json j;
								j["player"] = name;
								std::ofstream file(lol);
								if (file.is_open()) {
									file << std::setw(4) << j << std::endl; // Prettify JSON with indentation
									file.close();
									std::cout << "Data ditulis ke file: " << lol << std::endl;
								}
								topactivep = name;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									packet_(currentPeer, "action|play_sfx\nfile|audio/levelup.wav\ndelayMS|0");
									Algorithm::send_console(currentPeer, "Nick: " + name + " Has Been A Top Active Player Of The Week!");
								}
							}
							if (cch.find("action|dialog_return\ndialog_name|confirm_settopw") != string::npos) {
								string name = explode("\n", explode("name_w|", cch)[1])[0].c_str();
								std::string lol = "config/topworldday.json";
								nlohmann::json j;
								j["world"] = name;
								std::ofstream file(lol);
								if (file.is_open()) {
									file << std::setw(4) << j << std::endl; // Prettify JSON with indentation
									file.close();
									std::cout << "Data ditulis ke file: " << lol << std::endl;
								}
								topactivew = name;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									packet_(currentPeer, "action|play_sfx\nfile|audio/levelup.wav\ndelayMS|0");
									Algorithm::send_console(currentPeer, "World: " + name + " Has Been A Top Active World Of The Day!");
								}
							}
							if (cch.find("action|dialog_return\ndialog_name|bannerbandolier") != std::string::npos) {
								if (cch.find("buttonClicked|patternpicker") != std::string::npos) {
									string dialog = "";
									if (pInfo(peer)->Banner_Flag == 0) dialog += "set_default_color|`o\nadd_label_with_icon|big|`wBanner Bandolier``|left|5838|";
									else if (pInfo(peer)->Banner_Flag == 1) dialog += "set_default_color|`o\nadd_label_with_icon|big|`wBanner Bandolier``|left|5844|";
									else if (pInfo(peer)->Banner_Flag == 2) dialog += "set_default_color|`o\nadd_label_with_icon|big|`wBanner Bandolier``|left|5848|";
									else if (pInfo(peer)->Banner_Flag == 3) dialog += "set_default_color|`o\nadd_label_with_icon|big|`wBanner Bandolier``|left|5846|";
									else if (pInfo(peer)->Banner_Flag == 4) dialog += "set_default_color|`o\nadd_label_with_icon|big|`wBanner Bandolier``|left|5842|";
									dialog += "\nadd_spacer|small|\nadd_textbox|Pick a pattern for your banner.|left|\nadd_spacer|small|";
									dialog += "\nadd_label_with_icon_button|big|Harlequin|left|5838|pattern_1|\nadd_spacer|small|";
									dialog += "\nadd_label_with_icon_button|big|Slant|left|5844|pattern_2|\nadd_spacer|small|";
									dialog += "\nadd_label_with_icon_button|big|Stripe|left|5848|pattern_3|\nadd_spacer|small|";
									dialog += "\nadd_label_with_icon_button|big|Panel|left|5846|pattern_4|\nadd_spacer|small|";
									dialog += "\nadd_label_with_icon_button|big|Cross|left|5842|pattern_5|\nadd_spacer|small|";
									dialog += "\nend_dialog|bannerbandolier|Cancel||\nadd_quick_exit|";
									gamepacket_t p;
									p.Insert("OnDialogRequest"), p.Insert(dialog), p.CreatePacket(peer);
									break;
								}
								else if (cch.find("buttonClicked|pattern_") != std::string::npos) {
									int Pattern = atoi(cch.substr(49 + 22, cch.length() - 49 + 22).c_str());
									pInfo(peer)->CBanner_Item = pInfo(peer)->Banner_Item;
									pInfo(peer)->CBanner_Flag = Pattern - 1;
									SendBannerBandolier2(peer);
									break;
								}
								else if (cch.find("buttonClicked|reset") != std::string::npos) {
									pInfo(peer)->CBanner_Item = 0; pInfo(peer)->CBanner_Flag = 0; pInfo(peer)->Banner_Item = 0; pInfo(peer)->Banner_Flag = 0;
									SendBannerBandolier2(peer);
									break;
								}
								else if (!(cch.find("buttonClicked|patternpicker") != std::string::npos || cch.find("buttonClicked|pattern_") != std::string::npos || cch.find("\nbanneritem|") != std::string::npos)) {
									if (pInfo(peer)->CBanner_Item != 0) pInfo(peer)->Banner_Item = pInfo(peer)->CBanner_Item;
									if (pInfo(peer)->CBanner_Flag != 0) pInfo(peer)->Banner_Flag = pInfo(peer)->CBanner_Flag;
									pInfo(peer)->CBanner_Item = 0; pInfo(peer)->CBanner_Flag = 0;
									update_clothes(peer);
									break;
								}
								else {
									pInfo(peer)->CBanner_Flag = pInfo(peer)->CBanner_Flag;
									pInfo(peer)->CBanner_Item = atoi(explode("\n", explode("banneritem|", cch)[1])[0].c_str());
									SendBannerBandolier2(peer);
									break;
								}
								break;
							}
							else if (cch.find("action|itemfavourite") != string::npos) {
								vector<string> t_ = explode("|", cch);
								if (t_.size() < 4) break;
								uint16_t itemId = atoi(explode("\n", t_[3])[0].c_str());
								if (itemId >= 0 && itemId < items.size()) {
									if (itemId != 0) {
										vector<int>& favList = pInfo(peer)->fav_list;
										auto it = find(favList.begin(), favList.end(), itemId);
										if (it == favList.end()) {
											favList.push_back(itemId);
											gamepacket_t p;
											p.Insert("OnFavItemUpdated"), p.Insert(itemId), p.Insert(1), p.CreatePacket(peer);
										}
										else {
											favList.erase(it);
											gamepacket_t p;
											p.Insert("OnFavItemUpdated"), p.Insert(itemId), p.Insert(0), p.CreatePacket(peer);
										}
									}
								}
								break;
							}
							else if (cch == "action|inventoryfavuitrigger\n") {
								std::string fav_dialog = "set_default_color|`o\nadd_label_with_icon|big|`wFavorited Items``|left|13814|\nadd_spacer|small|\nadd_textbox|You have not favorited any item yet.|left|\nadd_spacer|small|\nend_dialog|unfavorite_items_dialog|Close||";
								std::string have_fav = "set_default_color|`o\nadd_label_with_icon|big|`wFavorited Items``|left|13814|\nadd_spacer|small|\nadd_textbox|All favorited items are currently in your inventory. They can be unfavorited by tapping on the UNFAV button while having the item selected in your inventory.|left|\nadd_spacer|small|\nend_dialog|unfavorite_items_dialog|Close||";
								vz::OnDialogRequest(peer, (pInfo(peer)->fav_list.empty()) ? fav_dialog : have_fav);
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|punish_view\nbuttonClicked|warp_to_") != string::npos) {
								if (pInfo(peer)->admin == 1 || pInfo(peer)->dev == 1) {
									string world_name = cch.substr(67, cch.length() - 67);
									replace_str(world_name, "\n", "");
									replace_str(world_name, "reason|", "");
									join_world(peer, world_name);
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|top_richest\nbuttonClicked|userinfo_") != string::npos) {
							string username = cch.substr(68, cch.length() - 68);
							replace_str(username, "\n", "");
							bool foundacc = true;
							pInfo(peer)->last_wrenched = username;
							string bans = "", logs = "", mac = "", worlds_owned_ = "";
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
									time_t s__;
									s__ = time(NULL);
									int days_ = int(s__) / (60 * 60 * 24);
									double hours_ = (double)((s__ - pInfo(currentPeer)->playtime) + pInfo(currentPeer)->seconds) / 3600;
									string num_text = to_string(hours_);
									string rounded = num_text.substr(0, num_text.find(".") + 3);
									foundacc = false;
									int adaBrpGems = 0, totalNetWorth = 0, totalWls = 0, totalBank = 0, totalBbank = 0;
									totalWls = pInfo(currentPeer)->totalWls;
									totalNetWorth = pInfo(currentPeer)->totalNetWorth;
									totalBank = pInfo(currentPeer)->bank_p;
									totalBbank = pInfo(currentPeer)->bbbgl;
									int dls = 0, wls = 0, bgl = 0;
									dls = pInfo(currentPeer)->totalWls / 100;
									wls = pInfo(currentPeer)->totalWls - (dls * 100);
									if (dls >= 100) {
										bgl = pInfo(currentPeer)->totalWls / 10000;
										dls -= 100 * bgl;
									}
									string clothes = "", WorldLock = "";
									if (wls != 0) WorldLock += "\nadd_smalltext|Locks in backpack:|\nadd_label_with_icon|small|" + to_string(wls) + " " + items[242].ori_name + "|left|242|";
									if (dls != 0) WorldLock += "\nadd_label_with_icon|small|" + to_string(dls) + " " + items[1796].ori_name + "|left|1796|";
									if (bgl != 0) WorldLock += "\nadd_label_with_icon|small|" + to_string(bgl) + " " + items[7188].ori_name + "|left|7188|";
									// int hair = 0, shirt = 0, pants = 0, feet = 0, face = 0, hand = 0, back = 0, mask = 0, necklace = 0, ances = 0;
									if (pInfo(currentPeer)->mask != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(currentPeer)->mask].ori_name + "|left|" + to_string(pInfo(currentPeer)->mask) + "|";
									if (pInfo(currentPeer)->face != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(currentPeer)->face].ori_name + "|left|" + to_string(pInfo(currentPeer)->face) + "|";
									if (pInfo(currentPeer)->hair != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(currentPeer)->hair].ori_name + "|left|" + to_string(pInfo(currentPeer)->hair) + "|";
									if (pInfo(currentPeer)->necklace != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(currentPeer)->necklace].ori_name + "|left|" + to_string(pInfo(currentPeer)->necklace) + "|";
									if (pInfo(currentPeer)->shirt != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(currentPeer)->shirt].ori_name + "|left|" + to_string(pInfo(currentPeer)->shirt) + "|";
									if (pInfo(currentPeer)->back != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(currentPeer)->back].ori_name + "|left|" + to_string(pInfo(currentPeer)->back) + "|";
									if (pInfo(currentPeer)->pants != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(currentPeer)->pants].ori_name + "|left|" + to_string(pInfo(currentPeer)->pants) + "|";
									if (pInfo(currentPeer)->feet != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(currentPeer)->feet].ori_name + "|left|" + to_string(pInfo(currentPeer)->feet) + "|";
									if (pInfo(currentPeer)->hand != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(currentPeer)->hand].ori_name + "|left|" + to_string(pInfo(currentPeer)->hand) + "|";
									if (pInfo(currentPeer)->ances != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(currentPeer)->ances].ori_name + "|left|" + to_string(pInfo(currentPeer)->ances) + "|";

									string lbdialog = "`o\n\nadd_player_info|`0" + pInfo(currentPeer)->modName + "``|" + (pInfo(currentPeer)->level >= 125 ? "125|5001000|5001000|" : "") + "" + (pInfo(currentPeer)->level <= 125 ? to_string(pInfo(currentPeer)->level) + "|" + to_string(pInfo(currentPeer)->xp) + "|" + to_string(50 * ((pInfo(currentPeer)->level * pInfo(currentPeer)->level) + 2)) : "") + "\nadd_spacer|small|\nadd_textbox|Account Net. Worth: `w" + fixint(totalNetWorth) + " `9World Locks|\nadd_textbox|Account Playtime: `5" + rounded + " ``Hours|\nadd_spacer|small|\nadd_spacer|small|\nadd_label_with_icon|small|Total Bgl in the bank: " + fixint(totalBank) + "|left|7188|\nadd_label_with_icon|small|Total Golden Gem Lock in the bank: " + fixint(pInfo(currentPeer)->bbbgl) + "|left|8470|\nadd_label_with_icon|small|Total Gems: " + fixint(pInfo(currentPeer)->gems) + "|left|9438|\nadd_spacer|small|\nadd_spacer|small|\nadd_label_with_icon|small|Total World Locks: " + fixint(totalWls) + "|left|242|" + WorldLock + "\nadd_spacer|small|\nadd_label_with_icon|small|Total Worlds Owned: " + fixint(pInfo(currentPeer)->worlds_owned.size()) + "|left|3802|\nadd_smalltext|Total Inventory Space: " + fixint(pInfo(currentPeer)->inv.size()) + "|\nadd_spacer|small|\nadd_smalltext|Clothing (Set):|" + clothes + "\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|`5(User information refresh every minute in real-time)``|\nadd_button|backtolb|Back|noflags|0|0|\nend_dialog|userinfo|Exit||\nadd_quick_exit|\n";
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|" + lbdialog);
									p.CreatePacket(peer);
								}
							}
							if (foundacc) {
								try {
									int playerLevel = 0, playerXp = 0, adaBrpGems = 0, gemsToWl = 0, totalNetWorth = 0, totalWls = 0, totalBank = 0, totalBbank = 0, aspectOwned = 0, aspectPurchased = 0, clothHair = 0, clothMask = 0, clothFace = 0, clothNeck = 0, clothBack = 0, clothShirt = 0, clothPants = 0, clothFeet = 0, clothAnces = 0, clothHand = 0;
									string clothes = "", modName = "";
									ifstream ifs("database/players/" + username + "_.json");
									if (ifs.is_open()) {
										json j;
										ifs >> j;
										// get data
										modName = (!(j.find("modname") != j.end()) ? username : j["modname"].get<string>());
										playerLevel = j["level"].get<int>();
										playerXp = j["xp"].get<int>();
										clothHair = j["hair"].get<int>();
										clothMask = j["mask"].get<int>();
										clothFace = j["face"].get<int>();
										clothNeck = j["necklace"].get<int>();
										clothBack = j["back"].get<int>();
										clothShirt = j["shirt"].get<int>();
										clothPants = j["pants"].get<int>();
										clothFeet = j["feet"].get<int>();
										clothAnces = j["ances"].get<int>();
										clothHand = j["hand"].get<int>();
										aspectOwned = j["gtwl"].get<int>();
										aspectPurchased = (!(j.find("Total_TopUp") != j.end()) ? 0 : j["Total_TopUp"].get<int>());
										adaBrpGems = j["gems"].get<int>();
										totalWls = (!(j.find("Total_Wls") != j.end()) ? 0 : j["Total_Wls"].get<int>());
										totalBank = j["bank_c"].get<uint8_t>();
										totalBbank = j["bbbgl"].get<int>();
									}
									if (clothMask != 0) clothes += "\nadd_label_with_icon|small|" + items[clothMask].ori_name + "|left|" + to_string(clothMask) + "|";
									if (clothHair != 0) clothes += "\nadd_label_with_icon|small|" + items[clothHair].ori_name + "|left|" + to_string(clothHair) + "|";
									if (clothFace != 0) clothes += "\nadd_label_with_icon|small|" + items[clothFace].ori_name + "|left|" + to_string(clothFace) + "|";
									if (clothNeck != 0) clothes += "\nadd_label_with_icon|small|" + items[clothNeck].ori_name + "|left|" + to_string(clothNeck) + "|";
									if (clothBack != 0) clothes += "\nadd_label_with_icon|small|" + items[clothBack].ori_name + "|left|" + to_string(clothBack) + "|";
									if (clothShirt != 0) clothes += "\nadd_label_with_icon|small|" + items[clothShirt].ori_name + "|left|" + to_string(clothShirt) + "|";
									if (clothPants != 0) clothes += "\nadd_label_with_icon|small|" + items[clothPants].ori_name + "|left|" + to_string(clothPants) + "|";
									if (clothFeet != 0) clothes += "\nadd_label_with_icon|small|" + items[clothFeet].ori_name + "|left|" + to_string(clothFeet) + "|";
									if (clothAnces != 0) clothes += "\nadd_label_with_icon|small|" + items[clothAnces].ori_name + "|left|" + to_string(clothAnces) + "|";
									if (clothHand != 0) clothes += "\nadd_label_with_icon|small|" + items[clothHand].ori_name + "|left|" + to_string(clothHand) + "|";
									if (adaBrpGems >= 2000) adaBrpGems = gemsToWl / 2000;
									totalNetWorth = adaBrpGems + totalWls;
									string lbdialog = "`o\n\nadd_player_info|`0" + modName + "``|" + (playerLevel >= 999 ? "999|5001000|5001000|" : "") + "" + (playerLevel <= 999 ? to_string(playerLevel) + "|" + to_string(playerXp) + "|" + to_string(50 * ((playerLevel * playerXp) + 2)) : "") + "\nadd_spacer|small|\nadd_textbox|Account Net. Worth: `w" + fixint(totalNetWorth) + " `9World Locks|\nadd_textbox|The user is currently `4OFFLINE``|\nadd_spacer|small|\nadd_spacer|small|\nadd_label_with_icon|small|Total Bgl in the bank: " + fixint(totalBank) + "|left|7188|\nadd_label_with_icon|small|Total Golden Gem Lock in the bank: " + fixint(totalBbank) + "|left|8470|\nadd_label_with_icon|small|Total Gems: " + fixint(adaBrpGems) + "|left|9438|\nadd_label_with_icon|small|Total World Locks: " + fixint(totalWls) + "|left|242|\nadd_spacer|small|\nadd_smalltext|Clothing (Set):|" + clothes + "\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|`5(User information refresh every minute in real-time)``|\nadd_button|backtolb|Back|noflags|0|0|\nend_dialog|userinfo|Exit||\nadd_quick_exit|\n";
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|" + lbdialog);
									p.CreatePacket(peer);
								}//back here
								catch (exception& e) {
									xItsCrims_warn(e.what());
									break;
								}
							}
							break;
						}
						else if (cch == "action|dialog_return\ndialog_name|userinfo\nbuttonClicked|backtolb\n\n") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`wTop Richest Leaderboard``|left|10864|\nadd_spacer|" + top_rich_list + "\nadd_button|\nend_dialog|top_richest|Close||\n");
								p.CreatePacket(peer);
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|top_richest\nbuttonClicked|socialportal\n\n") {
								send_social(peer);
								break;
						    }
							else if (cch.find("action|dialog_return\ndialog_name|blast\nitemID|") != string::npos) {
							string world = cch.substr(57, cch.length() - 57).c_str();
								vector<string> t_ = explode("|", cch);
								if (t_.size() < 4) break;
								int blast = atoi(explode("\n", t_[3])[0].c_str()), got = 0;
								modify_inventory(peer, blast, got);
								if (got == 0) break;
								replace_str(world, "\n", "");
								transform(world.begin(), world.end(), world.begin(), ::toupper);
								if (find_if(worlds.begin(), worlds.end(), [world](const World& a) { return a.name == world; }) != worlds.end() || not check_blast(world) || _access_s(("database/worlds/" + world + "_.json").c_str(), 0) == 0) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("That world name already exists. You'll have to be more original. Maybe add some numbers after it?"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								}
								else {
									if (modify_inventory(peer, blast, got = -1) == 0) {
										create_world_blast(world, blast);
										if (blast == 830) modify_inventory(peer, 834, got = -100);
										join_world(peer, world);
										gamepacket_t p(750), p2(750);
										p.Insert("OnConsoleMessage"), p.Insert("** `5"+pInfo(peer)->tankIDName + " activates a " + items[blast].name + "! ``**"), p.CreatePacket(peer);
										p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("** `5" + pInfo(peer)->tankIDName + " activates a " + items[blast].name + "! ``**"), p2.Insert(0), p2.Insert(1), p2.CreatePacket(peer);
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|consumehgem\nitemID|6200|\ncount|") != string::npos) {
								string itemCount = cch.substr(64, cch.length() - 64).c_str();
								int intItemCount = atoi(itemCount.c_str());
								if (intItemCount <= 0) break;
								int got = 0;
								int remove = -intItemCount;
								modify_inventory(peer, 4490, got);
								if (got < intItemCount) break;
								if (got == 0) break;
								if (modify_inventory(peer, 4490, remove) == 0) {
									int total = intItemCount * 1000;
									pInfo(peer)->gems += total;
									{
										gamepacket_t p;
										p.Insert("OnSetBux");
										p.Insert(pInfo(peer)->gems);
										p.Insert(0);
										p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
										if (pInfo(peer)->supp >= 2) {
											p.Insert((float)33796, (float)1, (float)0);
										}
										p.CreatePacket(peer);
									}
								}
								break;
						}
						else if (cch.find("action|dialog_return\ndialog_name|megaphone\nitemID|2480|\nwords|") != string::npos) {
								string text = cch.substr(62, cch.length() - 62).c_str();
								bool cansb = true;
								int c_ = 0;
								modify_inventory(peer, 2480, c_);
								if (c_ == 0) continue;
								if (has_playmod(pInfo(peer), "duct tape")) {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`6>> That's sort of hard to do while duct-taped.``");
									p.CreatePacket(peer);
									cansb = false;
									continue;
								}
								if (has_playmod(pInfo(peer), "megaphone!")) {
									int time_ = 0;
									for (PlayMods peer_playmod : pInfo(peer)->playmods) {
										if (peer_playmod.id == 13) {
											time_ = peer_playmod.time - time(nullptr);
											break;
										}
									}
									packet_(peer, "action|log\nmsg|>> (" + to_playmod_time(time_) + "before you can broadcast again)", "");
									break;
								}
								if (cansb) {
									replace_str(text, "\n", "");
									pInfo(peer)->usedmegaphone = 1;
									Sendcmd(peer, "/sb " + text, false);
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|notebook_edit\nbuttonClicked|cancel") != string::npos || cch.find("action|dialog_return\ndialog_name|notebook_edit\nbuttonClicked|clear") != string::npos) {
								if (cch.find("action|dialog_return\ndialog_name|notebook_edit\nbuttonClicked|clear") != string::npos) 	pInfo(peer)->note = "";
								//send_wrench_self(peer);
								pelerbiji(peer, true, "kerucim", 0);
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|popup\nbuttonClicked|quests\n\n") {
								farmer_gacha(peer);
							}
							else if (cch == "action|dialog_return\ndialog_name|gazette\nbuttonClicked|ruless\n\n") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wHelp & Rules``|left|18|\nadd_spacer|small|\naadd_textbox|`w`2World or Accounts`` may be deleted after long periods of inactivity if a world is not visited regularly. `2Item function and prices are subject to change`` at anytime and without warning as we are constantly trying to balance different aspects of the game.``|left|\nadd_spacer|small|\nadd_textbox|`wProtect your worlds and the items by using Doors, Locks, and Blocks wisely, `2never share your login credentials`` with anyone, and be aware of `2fake system messages and phishing websites``.``|left|\nadd_spacer|small|\nadd_textbox|`w`2Inappropriate behavior`` (profanity, racist, sexist or sexual content, abusive behavior, and bullying); any form of scam game such as Drop Game, Dirt Game, etc.; `2buying, selling, or trading " + server_name + " `oaccounts, items, or worlds`` for real money; `2purchase fraud``; and usage of `2third party software``, including, but not limited to, client-side manipulation, auto-clickers, speed hacks, clock manipulation, bots, macroing, and auto-farming, will be sanctioned and may result in a permanent suspension.``|left|\nadd_spacer|small|\nadd_textbox|`wTo report a world, type `2/report`` and exit the world immediately. To report a player, `2wrench and report`` them, or contact us directly. For any issues and questions you may have, please visit our discord server`` `2https://dsc.gg/GTVR``|left|\nadd_spacer|small|\nadd_textbox|`wAdvertising another `2Private servers or any social medias`` is `4not allowed``.|left|\nadd_spacer|small|\nadd_textbox|`wThere is account creation limit,creating mass account might get you `4banned``.Punishment might applied to you alternative accounts or account that have the same ip address.|left|\nadd_spacer|small|\nadd_textbox|`wAny kind of abusing behaviour is not tolerated such as abusing commands, bugs or glitches will result a `4permanent`` suspension.|left|\nadd_spacer|small|\nadd_textbox|`wPlayers that faking `2System`` messages will be punished.Stolen/Scammed item will never be restored.|left|\nadd_spacer|small|\nadd_textbox|`wBugs and Glitches are bound to happen.if you lost item/rollback it will always happen we will do anything in our power to prevent this sort thing to happen.|left|\nadd_spacer|small|\nadd_button|news|`wI accept these rules!``|noflags|0|0|end_dialog|generic|||");
								p.CreatePacket(peer);
								break;
								}
							if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|info\n\n") {
								//send_wrench_self(peer);
								pelerbiji(peer, true, "kerucim", 0);
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|level\n\n") {
								send_level(peer);
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|skills\n\n") {
								send_skill(peer);
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|cheat_menunew\n\n") {
								cheat_show(peer);
								break;
							}
							if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|quests\n\n") {
								farmer_gacha(peer);
								break;
							}
							if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|mod\n\n") {
								if (not pInfo(peer)->dev) {
									Algorithm::send_overlay(peer, "`4ACCESS DENIED");
									break;
								}
								else {
									send_mod_tool(peer);
									break;
								}
							}
							if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|badges\n\n") {
								send_badges(peer);
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|gazette\nbuttonClicked|features\n\n") {
								news(peer);
								break;
						}
							else if (cch == "action|dialog_return\ndialog_name|gazette\nbuttonClicked|discord\n\n") {
								gamepacket_t p(500);
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_smalltext|to join our discord community press this button below|left|add_url_button|comment|`wJoin WhatsApp Group.||" + discord_link + "|Open WhatsApp Link Group?|0|0|\nend_dialog|gazette|Nevermind||");
									p.CreatePacket(peer);
								break;
							}
							if (cch == "action|discord\n\n") {
								gamepacket_t p(500);
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_smalltext|to join our discord community press this button below|left|add_url_button|comment|`wJoin WhatsApp Group.||" + discord_link + "|Open WhatsApp Link Group?|0|0|\nend_dialog|gazette|Nevermind||");
								p.CreatePacket(peer);
								break;
							}
							if (cch == "action|depoo\n\n") {
								news(peer);
								break;
							}
							if (cch == "action|features\n\n") {
								news(peer);
								break;
							}
							if (cch == "action|ruless\n\n") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wHelp & Rules``|left|18|\nadd_spacer|small|\naadd_textbox|`w`2World or Accounts`` may be deleted after long periods of inactivity if a world is not visited regularly. `2Item function and prices are subject to change`` at anytime and without warning as we are constantly trying to balance different aspects of the game.``|left|\nadd_spacer|small|\nadd_textbox|`wProtect your worlds and the items by using Doors, Locks, and Blocks wisely, `2never share your login credentials`` with anyone, and be aware of `2fake system messages and phishing websites``.``|left|\nadd_spacer|small|\nadd_textbox|`w`2Inappropriate behavior`` (profanity, racist, sexist or sexual content, abusive behavior, and bullying); any form of scam game such as Drop Game, Dirt Game, etc.; `2buying, selling, or trading " + server_name + " `oaccounts, items, or worlds`` for real money; `2purchase fraud``; and usage of `2third party software``, including, but not limited to, client-side manipulation, auto-clickers, speed hacks, clock manipulation, bots, macroing, and auto-farming, will be sanctioned and may result in a permanent suspension.``|left|\nadd_spacer|small|\nadd_textbox|`wTo report a world, type `2/report`` and exit the world immediately. To report a player, `2wrench and report`` them, or contact us directly. For any issues and questions you may have, please visit our discord server`` `2https://dsc.gg/GTVR``|left|\nadd_spacer|small|\nadd_textbox|`wAdvertising another `2Private servers or any social medias`` is `4not allowed``.|left|\nadd_spacer|small|\nadd_textbox|`wThere is account creation limit,creating mass account might get you `4banned``.Punishment might applied to you alternative accounts or account that have the same ip address.|left|\nadd_spacer|small|\nadd_textbox|`wAny kind of abusing behaviour is not tolerated such as abusing commands, bugs or glitches will result a `4permanent`` suspension.|left|\nadd_spacer|small|\nadd_textbox|`wPlayers that faking `2System`` messages will be punished.Stolen/Scammed item will never be restored.|left|\nadd_spacer|small|\nadd_textbox|`wBugs and Glitches are bound to happen.if you lost item/rollback it will always happen we will do anything in our power to prevent this sort thing to happen.|left|\nadd_spacer|small|\nadd_button|news|`wI accept these rules!``|noflags|0|0|end_dialog|generic|||");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|notebook_edit\nbuttonClicked|save\n\npersonal_note|") != string::npos) {
								string btn = cch.substr(81, cch.length() - 81).c_str();
								replace_str(btn, "\n", "");
								if (btn.length() > 128) continue;
								pInfo(peer)->note = btn;
								//send_wrench_self(peer);
								pelerbiji(peer, true, "kerucim", 0);
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|popup\nbuttonClicked|dailyr") != string::npos) {
								if (not pInfo(peer)->dev) break;
								if (today_day != pInfo(peer)->dailym) {
									pInfo(peer)->dailym = today_day;
									int dapat = 1;
									vector<int> list {408, 276, 274, 278};
									if (rand() % 1000 < 1) list = {1784, 10684};
									int item = list[rand() % list.size()];
									if (item == 276 || item == 274) dapat = 5;
									modify_inventory(peer, item, dapat);
									Algorithm::send_console(peer, "You received your daily mod reward, you can get more daily items next day!");
									Algorithm::send_bubble(peer, pInfo(peer)->netID, "You received "+to_string(dapat)+" "+items[item].name+"");
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|3898\nbuttonClicked|") != string::npos|| cch == "action|dialog_return\ndialog_name|zurgery_back\nbuttonClicked|53785\n\n" || cch == "action|dialog_return\ndialog_name|zombie_back\nbuttonClicked|81235\n\n" || cch == "action|dialog_return\ndialog_name|lite_back\nbuttonClicked|81235\n\n") {
								string btn = cch.substr(52, cch.length() - 52).c_str();
								if (cch == "action|dialog_return\ndialog_name|zurgery_back\nbuttonClicked|53785\n\n" || cch == "action|dialog_return\ndialog_name|zombie_back\nbuttonClicked|81235\n\n") btn = "53785";
								replace_str(btn, "\n", "");
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								if (btn == "12345") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wCrazy Jim's Quest Emporium``|left|3902|\nadd_textbox|HEEEEYYY there Growtopian! I'm Crazy Jim, and my quests are so crazy they're KERRRRAAAAZZY!! And that is clearly very crazy, so please, be cautious around them. What can I do ya for, partner?|left|\nadd_button|chc1_1|Daily Quest|left\nadd_button|cvgtg|Convert Credit Gems To Growtoken|left|\nadd_label_with_icon|small|`wCurrent Credit Gems: " + setGems(pInfo(peer)->creditgems) +"``|left|112|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
								else if (btn == "53785") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|It is I, Sales-Man, savior of the wealthy! Let me rescue you from your riches. What would you like to buy today?|left|\nadd_button|chc4_1|Surgery Items|noflags|0|0|\nadd_button|chc2_1|Blue Gem Lock|noflags|0|0|\nadd_button|chc0_1|Diamond Lock|noflags|0|0|\nadd_button|convert_bgl|Gems To Blue Gem Lock|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
								else if (btn == "chc1_1") {
									if (today_day != pInfo(peer)->dd) {
										int haveitem1 = 0, haveitem2 = 0, received = 0;
										modify_inventory(peer, item1, haveitem1);
										modify_inventory(peer, item2, haveitem2);
										if (haveitem1 >= item1c && haveitem2 >= item2c) received = 1;
										p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wCrazy Jim's Daily Quest``|left|3902|\nadd_textbox|I guess some people call me Crazy Jim because I'm a bit of a hoarder. But I'm very particular about what I want! And today, what I want is this:|left|\nadd_label_with_icon|small|`2" + to_string(item1c) + " " + items[item1].name + "|left|" + to_string(item1) + "|\nadd_smalltext|and|left|\nadd_label_with_icon|small|`2" + to_string(item2c) + " " + items[item2].name + "|left|" + to_string(item2) + "|\nadd_spacer|small|\nadd_smalltext|You shove all that through the phone (it works, I've tried it), and I will hand you one of the `2Growtokens`` from my personal collection!  But hurry, this offer is only good until midnight, and only one `2Growtoken`` per person!|left|\nadd_spacer|small|\nadd_smalltext|`6(You have " + to_string(haveitem1) + " " + items[item1].name + " and " + to_string(haveitem2) + " " + items[item2].name + ")``|left|\nadd_spacer|small|" + (received == 1 ? "\nadd_button|turnin|Turn in items|noflags|0|0|" : "") + "\nadd_spacer|small|\nadd_button|12345|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
									}
									else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wCrazy Jim's Daily Quest``|left|3902|\nadd_textbox|You've already completed my Daily Quest for today! Call me back after midnight to hear about my next cravings.|left|\nadd_button|12345|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
								}
								else if (btn == "turnin") {
									if (today_day != pInfo(peer)->dd) {
										int haveitem1 = 0, haveitem2 = 0, received = 0, remove = -1, remove2 = -1, giveitem = 1;
										modify_inventory(peer, item1, haveitem1);
										modify_inventory(peer, item2, haveitem2);
										if (haveitem1 >= item1c && haveitem2 >= item2c) received = 1;
										if (pInfo(peer)->quest_active && pInfo(peer)->quest_step == 6 && pInfo(peer)->quest_progress < 28) {
											pInfo(peer)->quest_progress += received;
											if (pInfo(peer)->quest_progress >= 28) {
												pInfo(peer)->quest_progress = 28;
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(peer);
											}
										}
										if (received == 1) {
											pInfo(peer)->dd = today_day;
											modify_inventory(peer, item1, remove *= item1c);
											modify_inventory(peer, item2, remove2 *= item2c);
											modify_inventory(peer, 1486, giveitem);
											pInfo(peer)->growpass_points += 40;
											grow4good_daily(peer);
											{
												{
													string name_ = pInfo(peer)->world;
													vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
													if (p != worlds.end()) {
														World* world_ = &worlds[p - worlds.begin()];
														PlayerMoving data_{};
														data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
														data_.packetType = 19, data_.plantingTree = 500;
														data_.punchX = 1486, data_.punchY = pInfo(peer)->netID;
														int32_t to_netid = pInfo(peer)->netID;
														BYTE* raw = packPlayerMoving(&data_);
														raw[3] = 5;
														memcpy(raw + 8, &to_netid, 4);
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
															if (pInfo(currentPeer)->world == world_->name) {
																send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
															}
														}
														delete[] raw;
													}
												}
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("[`6You jammed " + to_string(item1c) + " " + items[item1].name + " and " + to_string(item2c) + " " + items[item2].name + " into the phone, and 1 `2Growtoken`` popped out!``]");
												p.CreatePacket(peer);
											}
										}
									}
									else {
										p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wCrazy Jim's Daily Quest``|left|3902|\nadd_textbox|You've already completed my Daily Quest for today! Call me back after midnight to hear about my next cravings.|left|\nadd_button|12345|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
										p.CreatePacket(peer);
									}
								}
								else if (btn == "chc2_1") {
									int c_ = 0;
									modify_inventory(peer, 1796, c_);
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBlue Gem Lock``|left|7188|\nadd_textbox|Excellent! I'm happy to sell you a Blue Gem Lock in exchange for 100 Diamond Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " Diamond Lock.``|left|" + (c_ >= 100 ? "\nadd_button|chc2_2_1|Thank you!|noflags|0|0|" : "") + "\nadd_button|53785|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
								}
								else if (btn == "cvgtg") {
									int mmk = pInfo(peer)->creditgems;
									if (mmk < 10000) {
										Algorithm::send_overlay(peer, "You must have atleast 10K Credit Gems to convert it");
										break;
									}
									int c_ = 0;
									modify_inventory(peer, 1486, c_);
									if (c_ >= 200) { Algorithm::send_overlay(peer, "`4FULL OF GROWTOKENS"); break; }
									else {
										int dapat = 1;
										pInfo(peer)->creditgems -= 10000;
										modify_inventory(peer, 1486, c_ += dapat);
										p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wCrazy Jim's Quest Emporium``|left|3902|\nadd_textbox|You successfully convert `510K Credit Gems ``to `21 Growtoken``|left|\nadd_button|chc1_1|Daily Quest|left\nadd_button|cvgtg|Convert Credit Gems To Growtoken|left|\nadd_label_with_icon|small|`wCurrent Credit Gems: " + to_string(pInfo(peer)->creditgems) + "``|left|112|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
									}
								}
								//2500000000
						    	else if (btn == "chc0_1") {
								int c_ = pInfo(peer)->gems;
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDiamond Lock``|left|1796|\nadd_textbox|Excellent! I'm happy to sell you a Diamond Lock in exchange for 200.000 Gems.|left|\nadd_smalltext|`6You have " + fixint(c_) + " Gems.``|left|" + (c_ >= 200000 ? "\nadd_button|chc0_2_1|Thank you!|noflags|0|0|" : "") + "\nadd_button|53785|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
							}
								else if (btn == "convert_bgl") {
								int current_gems = pInfo(peer)->gems;
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBlue Gem Lock|left|7188|\nadd_textbox|`$Excellent! I'm happy to sell you Blue Gem Lock in exchange for 20,000,000|\nadd_smalltext|`6You have " + to_string(current_gems) + "|" + (current_gems >= 20000000 ? "\nadd_button||`oConvert Blue Gem Lock|noflags|0|0|" : "") + "\nadd_button|53785|Back|noflags|0|0|\nend_dialog|3898|Hang Up||");
							}
								else if (btn == "chc0_2_1") {
								int c_ = pInfo(peer)->gems, c1796 = 0, additem = 0;
								modify_inventory(peer, 1796, c1796);
								if (c_ < 200000) continue;
								if (c1796 >= 200) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("You don't have room in your backpack!");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(peer);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You don't have room in your backpack!");
										p.CreatePacket(peer);
									}
									continue;
								}
								if (c_ >= 200000) {
									if (get_free_slots(pInfo(peer)) >= 2) {
										int cz_ = 200000;
										if (modify_inventory(peer, 1796, additem = 1) == 0) {
											{
												{
													pInfo(peer)->gems -= cz_;
													string name_ = pInfo(peer)->world;
													vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
													if (p != worlds.end()) {
														gamepacket_t p8;
														p8.Insert("OnSetBux");
														p8.Insert(pInfo(peer)->gems);
														p8.Insert(0);
														p8.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
														if (pInfo(peer)->supp >= 2) {
															p8.Insert((float)33796, (float)1, (float)0);
														}
														p8.CreatePacket(peer);
														World* world_ = &worlds[p - worlds.begin()];
														PlayerMoving data_{};
														data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
														data_.packetType = 19, data_.plantingTree = 500;
														data_.punchX = 1796, data_.punchY = pInfo(peer)->netID;
														int32_t to_netid = pInfo(peer)->netID;
														BYTE* raw = packPlayerMoving(&data_);
														raw[3] = 5;
														memcpy(raw + 8, &to_netid, 4);
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
															if (pInfo(currentPeer)->world == world_->name) {
																send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
															}
														}
														delete[] raw;
													}
												}
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("[`6You spent 200.000 Gems to get 1 Diamond Lock``]");
												p.CreatePacket(peer);
											}
										}
										int c_ = pInfo(peer)->gems;
										p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDiamond Lock``|left|1796|\nadd_textbox|Excellent! I'm happy to sell you a Diamond Lock in exchange for 200.000 Gems.|left|\nadd_smalltext|`6You have " + fixint(c_) + " Gems.``|left|" + (c_ >= 200000 ? "\nadd_button|chc0_2_1|Thank you!|noflags|0|0|" : "") + "\nadd_button|53785|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You don't have enough inventory space!");
										p.CreatePacket(peer);
									}
								}
							}
								else if (btn == "chc2_1") {
								int c_ = 0;
								modify_inventory(peer, 1796, c_);
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBlue Gem Lock``|left|7188|\nadd_textbox|Excellent! I'm happy to sell you a Blue Gem Lock in exchange for 100 Diamond Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " Diamond Lock.``|left|" + (c_ >= 100 ? "\nadd_button|chc2_2_1|Thank you!|noflags|0|0|" : "") + "\nadd_button|53785|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
							}
								else if (btn == "kdkdkdkdkdkekekkekskskskskskskskskdmdndndnejdj010293") {
								int current_gems = pInfo(peer)->gems;
								int bgl = 0;
								modify_inventory(peer, 7188, bgl);
								if (bgl >= 200) {
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBlue Gem Lock|left|7188|\nadd_smalltext|`4You are full of Blue Gem Lock|\nadd_textbox|`$Excellent! I'm happy to sell you Blue Gem Lock in exchange for 25,000,000|\nadd_smalltext|`6You have " + to_string(current_gems) + "|" + (current_gems >= 25000000 ? "\nadd_button|kdkdkdkdkdkekekkekskskskskskskskskdmdndndnejdj010293|`oConvert Blue Gem Lock|noflags|0|0|" : "") + "\nadd_button|53785|Back|noflags|0|0|\nend_dialog|3898|Hang Up||");
								}
								else {
									int get = 1;
									modify_inventory(peer, 7188, get);
									pInfo(peer)->gems -= 20000000;
									gamepacket_t bux;
									bux.Insert("OnSetBux");
									bux.Insert(pInfo(peer)->gems);
									bux.CreatePacket(peer);
									p.Insert("set_default_color|`o\nadd_textbox|`oSuccessfully convert Blue Gem Lock!|\nadd_spacer|small|\nadd_button|53785|Back|noflags|0|0|\nend_dialog|3898|||");
								}
								}

								else if (btn == "chc2_2_1") {
									int c7188 = 0, c1796 = 0, additem = 0;
									modify_inventory(peer, 1796, c1796);
									if (c1796 < 100) continue;
									modify_inventory(peer, 7188, c7188);
									if (c7188 >= 200) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("You don't have room in your backpack!");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(peer);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You don't have room in your backpack!");
											p.CreatePacket(peer);
										}
										continue;
									}
									if (c1796 >= 100) {
										if (get_free_slots(pInfo(peer)) >= 2) {
											int cz_ = 1;
											if (modify_inventory(peer, 1796, additem = -100) == 0) {
												modify_inventory(peer, 7188, additem = 1);
												{
													{
														string name_ = pInfo(peer)->world;
														vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
														if (p != worlds.end()) {
															World* world_ = &worlds[p - worlds.begin()];
															PlayerMoving data_{};
															data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
															data_.packetType = 19, data_.plantingTree = 500;
															data_.punchX = 7188, data_.punchY = pInfo(peer)->netID;
															int32_t to_netid = pInfo(peer)->netID;
															BYTE* raw = packPlayerMoving(&data_);
															raw[3] = 5;
															memcpy(raw + 8, &to_netid, 4);
															for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																if (pInfo(currentPeer)->world == world_->name) {
																	send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
																}
															}
															delete[] raw;
														}
													}
													gamepacket_t p;
													p.Insert("OnConsoleMessage");
													p.Insert("[`6You spent 100 Diamond Lock to get 1 Blue Gem Lock``]");
													p.CreatePacket(peer);
												}
											}
											int c_ = 0;
											modify_inventory(peer, 1796, c_);
											p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBlue Gem Lock``|left|7188|\nadd_textbox|Excellent! I'm happy to sell you a Blue Gem Lock in exchange for 100 Diamond Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " Diamond Lock.``|left|" + (c_ >= 100 ? "\nadd_button|chc2_2_1|Thank you!|noflags|0|0|" : "") + "\nadd_button|53785|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You don't have enough inventory space!");
										p.CreatePacket(peer);
									}
								}
								else if (btn == "chc3_1") {
								int zombie_brain = 0, pile = 0, total = 0;
								modify_inventory(peer, 10002, zombie_brain);
								modify_inventory(peer, 99999999, pile);
								total += zombie_brain + (pile * 100);
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wKevin: You must be rich because you press this icon``|left|2398|\nadd_textbox|I smell a lot of coins in your backpack, it will be fine if you spend a few of your coin for role in game and you won't regret about it.|left|\nadd_smalltext|You currently have " + setGems(total) + " Bitcoin.|left|\nadd_spacer|small|\ntext_scaling_string|5,000ZB|\n" + zombie_list + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|81235|Back|noflags|0|0|\nend_dialog|zombie_back|Hang Up||\n");
								p.CreatePacket(peer);
								}
								else if (btn == "chc99_1") {
									int zombie_brain = 0, pile = 0, total = 0;
									modify_inventory(peer, 10014, zombie_brain);
									modify_inventory(peer, 999999, pile);
									total += zombie_brain + (pile * 100);
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wKevin: Hmmm let see how many your litecoins.``|left|2398|\nadd_textbox|I smell a lot of coins in your backpack, it will be fine if you spend a few of your coin for some items and you won't regret about it.|left|\nadd_smalltext|You currently have " + setGems(total) + " Litecoin.|left|\nadd_spacer|small|\ntext_scaling_string|5,000ZB|\n" + lite_list + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|81235|Back|noflags|0|0|\nend_dialog|lite_back|Hang Up||\n");
									p.CreatePacket(peer);
									}
								else if (btn == "chc4_1") {
								int zombie_brain = 0, pile = 0, total = 0;
								modify_inventory(peer, 4298, zombie_brain);
								modify_inventory(peer, 4300, pile);
								total += zombie_brain + (pile * 100);
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSales-Man: Surgery``|left|4358|\nadd_textbox|Excellent! I'm happy to sell you rare and precious Surgery prizes in exchange for Caduceus medals.|left|\nadd_smalltext|You currently have " + setGems(total) + " Caducei.|left|\nadd_spacer|small|\ntext_scaling_string|5,000ZB|\n" + surgery_list + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|53785|Back|noflags|0|0|\nend_dialog|zurgery_back|Hang Up||\n");
								p.CreatePacket(peer);
								}
								else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDisconnected``|left|774|\nadd_textbox|The number you have tried to reach is disconnected. Please check yourself before you wreck yourself.|left|\nend_dialog|3898|Hang Up||\n");
								if (btn != "turnin") p.CreatePacket(peer);
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|pworld_view\nbuttonClicked|banworld\n\n") {
								string name_ = pInfo(peer)->wwop;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];

									if (not world_->nuked) {
										struct tm newtime;
										time_t now = time(0);
										localtime_s(&newtime, &now);
										world_->nuked = true;
										world_->n_t = "" + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + "/2022 " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min)) + ":" + to_string(newtime.tm_sec) + "";
										world_->n_b = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``";
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("`o>> `4" + world_->name + " `4was nuked from orbit`o. It's the only way to be sure. Play nice, everybody!");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(peer)->wwop and not pInfo(currentPeer)->mod and not pInfo(currentPeer)->dev) exit_(currentPeer);
											packet_(currentPeer, "action|play_sfx\nfile|audio/bigboom.wav\ndelayMS|0");
											p.CreatePacket(currentPeer);
										}
										add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "NUKED WORLD: `#" + pInfo(peer)->wwop, "");
									}
									else {
										world_->nuked = false, world_->n_t = "", world_->n_b = "";
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("This world is once again available to everyone!"), p.CreatePacket(peer);
										add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "UNNUKED WORLD: `#" + pInfo(peer)->wwop, "");
									}
								}
						}
							else if (cch == "action|dialog_return\ndialog_name|pworld_view\nbuttonClicked|dcworld\n\n") {
								//	string world_name = cch.substr(67, cch.length() - 67);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->owner) continue;
									if (pInfo(currentPeer)->world == pInfo(peer)->wwop) {
										enet_peer_disconnect_later(currentPeer, 1);
									}
								}
							}
						else if (cch.find("action|dialog_return\ndialog_name|punish_view\nbuttonClicked|view_inventory") != string::npos) {
								if (pInfo(peer)->coown) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
											string recently_visited = "";
											for (auto it = pInfo(currentPeer)->last_visited_worlds.rbegin(); it != pInfo(currentPeer)->last_visited_worlds.rend(); ++it) {
												string a_ = *it + (next(it) != pInfo(currentPeer)->last_visited_worlds.rend() ? "``, " : "``");
												recently_visited += "`#" + a_;
											}
											string inventory = "";
											int thats5 = 0, thatsadded = 0;
											for (int i_ = 0; i_ < pInfo(currentPeer)->inv.size(); i_++) {
												if (pInfo(currentPeer)->inv[i_].id == 0 || pInfo(currentPeer)->inv[i_].id == 18 || pInfo(currentPeer)->inv[i_].id == 32) continue;
												thats5++;
												thatsadded = 0;
												inventory += "\nadd_button_with_icon|" + (pInfo(peer)->dev == 1 ? to_string(pInfo(currentPeer)->inv[i_].id) : "") + "||staticBlueFrame|" + to_string(pInfo(currentPeer)->inv[i_].id) + "|" + to_string(pInfo(currentPeer)->inv[i_].count) + "|";
												if (thats5 >= 6) {
													thats5 = 0;
													thatsadded = 1;
													inventory += "\nadd_button_with_icon||END_LIST|noflags|0||";
												}
											}
											gamepacket_t p;
											p.Insert("OnDialogRequest");
											p.Insert("set_default_color|`o\nadd_label_with_icon|small|`0Inventory of " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s (" + pInfo(currentPeer)->requestedName + ") - #" + to_string(pInfo(currentPeer)->netID) + "|left|3802|\nadd_spacer|small|\nadd_textbox|Last visited: " + recently_visited + "|\nadd_textbox|Gems: `w" + setGems(pInfo(currentPeer)->gems) + "|\nadd_textbox|Backpack slots: `w" + to_string(pInfo(currentPeer)->inv.size() - 1) + "|" + inventory + "" + (thatsadded == 1 ? "" : "\nadd_button_with_icon||END_LIST|noflags|0||") + "|\nend_dialog|view_inventory|Continue||\nadd_quick_exit|");
											p.CreatePacket(peer);
										}
									}
								}
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|punish_view\nbuttonClicked|warp_to_") != string::npos) {
								if (pInfo(peer)->mod == 1 || pInfo(peer)->dev == 1) {
									string world_name = cch.substr(67, cch.length() - 67);
									vector<string> test = split_string_by_newline(world_name);
									join_world(peer, test[0]);
								}
								break;
							}
							//else if (cch.find("action|dialog_return\ndialog_name|top\nbuttonClicked|warp_to_") != string::npos) {
							//	string world_name = cch.substr(59, cch.length() - 59);
							//	replace_str(world_name, "\n", "");
							//	join_world(peer, world_name);
							//	break;
							//}
							else if (cch == "action|dialog_return\ndialog_name|top\nbuttonClicked|wotwlistback\n\n") {
								Sendcmd(peer, "/top", true);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|shopgemsconfirm\ngemspurchase|") != string::npos) {
								int gems = atoi(cch.substr(62, cch.length() - 62).c_str());
								if (gems <= 0) break;
								pInfo(peer)->offergems = gems;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Gems``|left|112|\n\nadd_spacer|small|\nadd_textbox|`2Purchase`` `9" + setGems(pInfo(peer)->offergems * 2000) + " Gems`` for `9" + to_string(gems) + " World Locks?``|\nadd_button|shopmoneybuy|`0Purchase``|NOFLAGS|0|0|\nadd_button||`0Cancel``|NOFLAGS|0|0|");
								p.CreatePacket(peer);
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopmoneybuy\n\n") {
							if (pInfo(peer)->offergems <= 0) break;
								if (pInfo(peer)->gtwl >= pInfo(peer)->offergems) {
									pInfo(peer)->gems += (pInfo(peer)->offergems * 2000);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You got `0" + setGems(pInfo(peer)->offergems * 2000) + "`` Gems!");
										p.CreatePacket(peer);
									}
									packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
									gamepacket_t p;
									p.Insert("OnSetBux");
									p.Insert(pInfo(peer)->gems);
									p.Insert(0);
									p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
									if (pInfo(peer)->supp >= 2) {
										p.Insert((float)33796, (float)1, (float)0);
									}
									p.CreatePacket(peer);
									pInfo(peer)->gtwl -= pInfo(peer)->offergems;
								}
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|top\nbuttonClicked|yesterdaylist\n\n" || cch == "action|dialog_return\ndialog_name|top\nbuttonClicked|overalllist\n\n" || cch == "action|claimprogressbar\n" || cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoptitle\n\n" || cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopgrowtoken\n\n" || cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopxp\n\n" || cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprankvip\n\n" || cch == "action|dialog_return\ndialog_name|top\nbuttonClicked|toplist\n\n" || cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopmoney\n\n" || cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprankglory\n\n" || cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprankmod\n\n" || cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprank\n\n" || cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopitems\n\n" || cch == "action|dialog_return\ndialog_name|socialportal\nbuttonClicked|bitsystem\n\n" || cch == "action|dialog_return\ndialog_name|socialportal\nbuttonClicked|systemcoin\n\n" || cch == "action|dialog_return\ndialog_name|socialportal\nbuttonClicked|bccoin\n\n") {
								gamepacket_t p;
								string shopss = "";
								for (int i = 1; i < shops.size(); i++) shopss += shops[i];
								p.Insert("OnDialogRequest");
								if (cch == "action|dialog_return\ndialog_name|top\nbuttonClicked|yesterdaylist\n\n")p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`5Top Worlds Of Yesterday``|left|394|\nadd_spacer|" + top_yesterday_list + "\nadd_button|wotwlistback|`oBack`|NOFLAGS|0|0|\nend_dialog|top|Close||\n");
								///if (cch == "action|opcshop\n")p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Online Point Hub``|left|10668|\nadd_spacer|small|\nadd_textbox|Welcome to Online Point HUB! Do you have any OPC? You can buy items from me with them.|left|\nadd_smalltext|`2You can earn 1 OPC by onlined 5 minute's on our server.``|left|\nadd_spacer|small|\nadd_textbox|You have `1" + setGems(pInfo(peer)->coin) + " ``Online Point``.|left|\ntext_scaling_string|99,000BPC|" + coin_list + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|chc0|OK|noflags|0|0|\nnend_dialog|gazette||OK|");
								if (cch == "action|dialog_return\ndialog_name|top\nbuttonClicked|overalllist\n\n")p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Top Worlds Of All Time``|left|394|\nadd_spacer|" + top_overall_list + "\nadd_button|wotwlistback|`oBack`|NOFLAGS|0|0|\nend_dialog|top|Close||\n");
								if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprank\n\n") p.Insert(a + "set_default_color|`o\n\nadd_label_with_icon|big|`0Roles``|left|408|\n\nadd_spacer|small|\n\nadd_textbox|`rPlease choose item that you want to purchase!``|left|\n\nadd_spacer|small|\nadd_button_with_icon|" + (pInfo(peer)->dev ? "" : "shoprankglory") + "|`9Moderator`` `0(``" + (pInfo(peer)->dev ? "`2OWNED``" : "`95000WL``") + "`0)``|noflags|9436|\nadd_button_with_icon|" + (pInfo(peer)->gp ? "" : "shoprankgrowpass") + "|`9MVP`` `0(``" + (pInfo(peer)->gp ? "`2OWNED``" : "`91000WL``") + "`0)``|noflags|11304|\nadd_button_with_icon|" + (pInfo(peer)->mod ? "" : "shoprankmod") + "|`bMVP+`` `0(``" + (pInfo(peer)->mod ? "`2OWNED" : "`92000WL``") + "`0)``|noflags|278|\nadd_button_with_icon|" + (pInfo(peer)->vip ? "" : "shoprankvip") + "|`eVIP`` `0(``" + (pInfo(peer)->vip ? "`2OWNED``" : "`9600WL``") + "`0)``|noflags|276|"/*"\nadd_button_with_icon|shoprankgrowpass1|`rGrowPass LVL1`` `0(```9200Wls```0)``|noflags|9222|\nadd_button_with_icon|shoprankgrowpass2|`rGrowPass LVL2`` `0(```9400Wls```0)``|noflags|9222|\nadd_button_with_icon|shoprankgrowpass3|`rGrowPass LVL3`` `0(```9500Wls```0)``|noflags|9222|"*/"||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|shop|`0Back..``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoptitle\n\n") p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`2Purchase Title|left|9472|\n\nadd_spacer|small|\n\nadd_textbox|Choose which title do you want to purchase?|left|\nadd_smalltext|Note: We are only selling 5 titles for real growtopia payment.|left|\ntext_scaling_string|100,000,000,000coin|\nadd_spacer|small|\nadd_button_with_icon|" + string(pInfo(peer)->legend ? "" : "shoptit_leg") + "|`9Legendary`` `0(``" + (pInfo(peer)->legend ? "`2OWNED``" : "`91000WL``") + "`0)``|noflags|1794|\nadd_button_with_icon|" + string(pInfo(peer)->drtitle ? "" : "shoptit_doc") + "|`4Doctor`` `0(``" + (pInfo(peer)->drtitle ? "`2OWNED``" : "`9500WL``") + "`0)``|noflags|7068|\nadd_button_with_icon|" + string(pInfo(peer)->level >= 125 ? "" : "shoptit_125") + "|`3Blue Name`` `0(``" + (pInfo(peer)->level >= 125 ? "`2OWNED``" : "`9125LC``") + "`0)``|noflags|1488|\nadd_button_with_icon|" + (pInfo(peer)->have_master ? "" : "shoptit_men") + "|`8Mentor`` `0(``" + (pInfo(peer)->have_master ? "`2OWNED``" : "`9500WL``") + "`0)``|noflags|9472|\nadd_button_with_icon|" + (pInfo(peer)->have_donor ? "" : "shoptit_don") + "|`1G```24```6G`` `0(``" + (pInfo(peer)->have_donor ? "`2OWNED``" : "`9500WL``") + "`0)``|noflags|10856|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|shop|`0Back``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopitems\n\n") p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Purchase items``|left|6312|\n\nadd_spacer|small|\n\nadd_textbox|`rPlease choose item that you want to purchase!``|left|\n\nadd_spacer|small|" + shop_list + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|shop|`0Back..``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								if (cch == "action|dialog_return\ndialog_name|socialportal\nbuttonClicked|systemcoin\n\n") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Online Point Hub``|left|10668|\nadd_spacer|small|\nadd_textbox|Welcome to Online Point HUB! Do you have any OPC? You can buy items from me with them.|left|\nadd_smalltext|`2You can earn 1 OPC by onlined 5 minute's on our server.``|left|\nadd_spacer|small|\nadd_textbox|You have `1" + setGems(pInfo(peer)->coin) + " ``Online Point``.|left|\ntext_scaling_string|99,000BPC|" + coin_list + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|chc0|OK|noflags|0|0|\nnend_dialog|gazette||OK|");
								if (cch == "action|dialog_return\ndialog_name|socialportal\nbuttonClicked|bccoin\n\n") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Bitcoin Exchange``|left|10002|\nadd_spacer|small|\nadd_textbox|This Feature Is Still On Beta|left|\nadd_smalltext|`2You can change your Bitcoin on telephone by calling 81235.``|left|\ntext_scaling_string|5000ZB|" + zombie_list + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|chc0|OK|noflags|0|0|\nnend_dialog|gazette||OK|");
								if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprankmod\n\n")p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Purchase MVP+``|left|18|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\nadd_smalltext|Price: `32000`` `9WL``|left|\nadd_smalltext|Duration: `7[```4~```7]``|left|\nadd_smalltext|Stock: `7[```4~```7]``|left|\n\nadd_textbox|`6Rules:``|left|\nadd_smalltext|`e1.`` `rDo not abuse your role.``|left|\nadd_smalltext|`e2.`` `rIf you are going to ban people, make sure to have screenshots/video for proof.``|left|\nadd_smalltext|`e3.`` `rSharing account will result in account loss.``|left|\nadd_smalltext|`e4.`` `rTrying to sell your account will result in ip-ban!``|left|\nadd_spacer|small|\n\nadd_textbox|`6Commands:``|left|\nadd_smalltext|`eAll commands are displayed in /help ``|left|\nadd_spacer|\nadd_url_button|comment|Purchase with E-Money|noflags|https://wa.me/6289503314293" + server_name + "|Open Premium WL shop?|0|0|\nadd_button|shoprankmodbuy|`0Purchase for `918 Bitcoin``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|shop|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprankglory\n\n") p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Purchase Moderator``|left|18|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\nadd_smalltext|Price: `35000`` `9WL``|left|\nadd_smalltext|Duration: `7[```4~```7]``|left|\nadd_smalltext|Stock: `7[```4~```7]``|left|\nadd_smalltext|Extra: `7RECEIVE INSTANTLY 100,000 GEMS - LEVEL UP & EARN UP TO 1,600,000 GEMS (save up 600+wls)``|left|\n\nadd_textbox|`6Rules:``|left|\nadd_smalltext|`e1.`` `rDo not abuse your role.``|left|\nadd_smalltext|`e2.`` `rIf you are going to ban people, make sure to have screenshots/video for proof.``|left|\nadd_smalltext|`e3.`` `rSharing account will result in account loss.``|left|\nadd_smalltext|`e4.`` `rTrying to sell your account will result in ip-ban!``|left|\nadd_spacer|small|\n\nadd_textbox|`6Commands:``|left|\nadd_smalltext|`eAll commands are displayed in /help ``|left|\nadd_spacer|\nadd_url_button|comment|Purchase with E-Money|noflags|https://wa.me/6289503314293" + server_name + "|Open premium wls shop?|0|0|\nadd_button|shoprankglorybuy|`0Purchase for `932 Bitcoin``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|shop|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopmoney\n\n")p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Gems``|left|112|\n\nadd_spacer|small|\nadd_textbox|`91 WL is 2000 gems!``|\nadd_textbox|`9You have " + to_string(pInfo(peer)->gtwl) + " WL, how much you want to premium wl for gems?`` `1(Enter Wls amount):``|\nadd_text_input|gemspurchase|Wls||30|\nend_dialog|shopgemsconfirm|Cancel|`5Check price..``|\n");
								if (cch == "action|dialog_return\ndialog_name|top\nbuttonClicked|toplist\n\n")p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`8Top worlds today``|left|394|\nadd_spacer|" + top_list + "\nadd_button|wotwlistback|`oBack`|NOFLAGS|0|0|\nend_dialog|top|Close||\n");
								if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprankvip\n\n") p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Purchase VIP``|left|18|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\nadd_smalltext|Price: `1600`` `9WL``|left|\nadd_smalltext|Duration: `7[```4~```7]``|left|\nadd_smalltext|Stock: `7[```4~```7]``|left|\n\nadd_textbox|`6Rules:``|left|\nadd_smalltext|`e1.`` `rDo not spam with VIP SB.``|left|\nadd_smalltext|`e2.`` `rInpersonating someone with name changing will result in ban!``|left|\nadd_smalltext|`e3.`` `rSharing account will result in account loss.``|left|\nadd_smalltext|`e4.`` `rTrying to sell your account will result in ip-ban!``|left|\nadd_spacer|small|\n\nadd_textbox|`6Commands:``|left|\nadd_smalltext|`eAll commands are displayed in /vhelp (vip help)``|left|\nadd_spacer|\nadd_url_button|comment|Purchase with E-Money|noflags|https://wa.me/6289503314293" + server_name + "|Open mining shop?|0|0|\nadd_button|shoprankvipbuy|`0Purchase for `96 Bitcoin``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|shop|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopxp\n\n")p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`1Level``|left|1488|\nadd_spacer|small|\n\nadd_textbox|`1Choose which potion you want to purchase:``|left|\n\nadd_spacer|small|\nadd_button_with_icon|shopxp1|`01 WL``|noflags|1488|100|\nadd_button_with_icon|shopxp2|`05 WL``|noflags|1488|500|\nadd_button_with_icon|shopxp3|`010 WL``|noflags|1488|1250|\nadd_button_with_icon||END_LIST|noflags|0||\n\nadd_spacer|\nadd_button|shop|`0Back..``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopgrowtoken\n\n")p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`1Purchase Growtoken``|left|1486|\nadd_spacer|small|\n\nadd_textbox|`1Choose which potion you want to purchase:``|left|\n\nadd_spacer|small|\nadd_button_with_icon|shopgt1|`0100 WL``|noflags|1486|1|\nadd_button_with_icon|shopgt2|`0500 WL``|noflags|1486|5|\nadd_button_with_icon|shopgt3|`01000 WL``|noflags|1486|12|\nadd_button_with_icon||END_LIST|noflags|0||\n\nadd_spacer|\nadd_button|shop|`0Back..``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								if (cch == "action|claimprogressbar\n")p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wAbout Valentine's Event``|left|384|\nadd_spacer|small|\nadd_textbox|During Valentine's Week you will gain points for opening Golden Booty Chests. Claim enough points to earn bonus rewards.|left|\nadd_spacer|small|\nadd_textbox|Current Progress: " + to_string(pInfo(peer)->booty_broken) + "/100|left|\nadd_spacer|small|\nadd_textbox|Reward:|left|\nadd_label_with_icon|small|Super Golden Booty Chest|left|9350|\nadd_smalltext|             - 4x chance of getting a Golden Heart Crystal when opening!|left|\nend_dialog|valentines_quest||OK|\n");
									p.CreatePacket(peer);
								break;
							}//isskyy
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprankgrowpass\n\n" || cch == "action|shoprankgrowpass\n\n" || cch == "action|shoprankgrowpass\n" || cch == "action|shoprankgrowpass") {
								gamepacket_t p(500);
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Purchase MVP``|left|18|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\nadd_smalltext|Price: `912 Bitcoin``|left|\nadd_smalltext|Duration: `7[```4~```7]``|left|\nadd_smalltext|Stock: `7[```4~```7]``|left|\nadd_smalltext|Extra: `7Receive daily items everyday, get 2x coin points, receive newest coolest growotpia items, use /buy <item> command``|left|\n\nadd_textbox|`6Rules:``|left|\nadd_smalltext|`e1.`` `rDo not abuse your role.``|left|\nadd_smalltext|`e2.`` `rIf you are going to ban people, make sure to have screenshots/video for proof.``|left|\nadd_smalltext|`e3.`` `rSharing account will result in account loss.``|left|\nadd_smalltext|`e4.`` `rTrying to sell your account will result in ip-ban!``|left|\nadd_spacer|small|\n\nadd_textbox|`6Commands:``|left|\nadd_smalltext|`eAll commands are displayed in /help ``|left|\nadd_spacer|\nadd_url_button|comment|Purchase E-Money|noflags|https://wa.me/6289503314293" + server_name + "|Open premium wls shop?|0|0|\nadd_button|shoprankgrowpassbuy|`0Purchase for `912 Bitcoin``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|shop|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|shop_price_") != string::npos) {
								int item = atoi(cch.substr(59, cch.length() - 59).c_str());
								if (item <= 0 || item >= items.size() || items[item].pwl == 0) continue;
								string special = "`eThere is none yet for that item``";
								if (item == 6312 || item == 11118) special = "`eGet `2Double Gems``";
								if (item == 11118) special += ", `220% higher chance of getting Magic Ores``";
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Purchase " + items[item].name + "``|left|" + to_string(items[item].id) + "|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\nadd_smalltext|Price: `3" + setGems(items[item].pwl) + "`` `9Premium WL``|left|\nadd_smalltext|Duration: `7[```4~```7]``|left|\nadd_smalltext|Stock: `7[```4~```7]``|left|\n\nadd_textbox|`6Special Effects:``|left|\nadd_smalltext|" + special + "|left|\nadd_spacer|\nadd_button|shop_item_" + to_string(item) + "|`0Purchase for `9" + setGems(items[item].pwl) + " Premium WL``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|shop|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|gazette\nbuttonClicked|farm_price_") != string::npos) {
								int item = atoi(cch.substr(66, cch.length() - 66).c_str());
								std::ifstream js("./shop/-" + to_string(item) + ".json");
								json j;
								js >> j;
								js.close();
								int Ids = j["id"].get<int>();
								int price = j["price"].get<int>();
								int stock = j["stock"].get<int>();
								string harga = "World Lock";
								string special = "`eThere is none yet for that item``";
								if (item == 9928 || item == 9816) special = "`9Higher Gems Rate``";
								if (item == 340) special += ", `2Classic Farmables``";
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Purchase " + items[Ids].name + "``|left|" + to_string(items[Ids].id) + "|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\nadd_smalltext|Price: `3" + setGems(price) + "``" + harga +" ```|left|\nadd_smalltext|Duration: `7[```4~```7]``|left|\nadd_smalltext|Stock: `7[```9"+setGems(stock) + "```7]``|left|\n\nadd_textbox|`6Special Effects:``|left|\nadd_smalltext|" + special + "|left|\nadd_spacer|\nadd_button|farm_item_" + to_string(item) + "|`0Purchase for `9" + setGems(price) + " " + harga + "``|left|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|shop|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|shoptit_") != string::npos) {
								string kyy = cch.substr(56, cch.length() - 58).c_str();
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								if (kyy == "doc") p.Insert("set_default_color|`o\nadd_label_with_icon|big|Purchase Doctor Title|left|9472|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\nadd_smalltext|Price: `350`` `9Litecoin``|left|\nadd_smalltext|Duration: `7[```4~```7]``|left|\nadd_smalltext|Stock: `7[```4~```7]``|left|\nadd_smalltext|Extra: `7[```4~```7]``|left|\nadd_spacer|\nadd_button|shopbuytit_" + kyy + "|`0Purchase for `950 LC``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|shop|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								else if (kyy == "leg") p.Insert("set_default_color|`o\nadd_label_with_icon|big|Purchase Legendary Title|left|9472|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\nadd_smalltext|Price: `3100`` `9Litecoin``|left|\nadd_smalltext|Duration: `7[```4~```7]``|left|\nadd_smalltext|Stock: `7[```4~```7]``|left|\nadd_smalltext|Extra: `7[```4~```7]``|left|\nadd_spacer|\nadd_button|shopbuytit_" + kyy + "|`0Purchase for `91 Bitcoin``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|shop|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								else if (kyy == "125") p.Insert("set_default_color|`o\nadd_label_with_icon|big|Purchase Blue Name|left|9472|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\nadd_smalltext|Price: `3125`` `9Litecoin``|left|\nadd_smalltext|Duration: `7[```4~```7]``|left|\nadd_smalltext|Stock: `7[```4~```7]``|left|\nadd_smalltext|Extra: `7[```4~```7]``|left|\nadd_spacer|\nadd_button|shopbuytit_" + kyy + "|`0Purchase for `9125 LC``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|shop|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								else if (kyy == "men") p.Insert("set_default_color|`o\nadd_label_with_icon|big|Purchase Mentor Title|left|9472|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\nadd_smalltext|Price: `34`` `9Bitcoin``|left|\nadd_smalltext|Duration: `7[```4~```7]``|left|\nadd_smalltext|Stock: `7[```4~```7]``|left|\nadd_smalltext|Extra: `7[```4~```7]``|left|\nadd_spacer|\nadd_button|shopbuytit_" + kyy + "|`0Purchase for `94 Bitcoin``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|shop|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								else if (kyy == "don") p.Insert("set_default_color|`o\nadd_label_with_icon|big|Purchase Grow4Good Title|left|9472|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\nadd_smalltext|Price: `34`` `9Bitcoin``|left|\nadd_smalltext|Duration: `7[```4~```7]``|left|\nadd_smalltext|Stock: `7[```4~```7]``|left|\nadd_smalltext|Extra: `7[```4~```7]``|left|\nadd_spacer|\nadd_button|shopbuytit_" + kyy + "|`0Purchase for `94 Bitcoin``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|shop|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								p.CreatePacket(peer);
								break;
								}
							else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|shopbuytit_") != string::npos) {
									if (pInfo(peer)->world == "") break;
									string kyy = cch.substr(59, cch.length() - 61).c_str();
									int price = 0;
									if (kyy == "doc") price = 50;
									else if (kyy == "leg") price = 100;
									else if (kyy == "125") price = 125;
									else if (kyy == "men") price = 400;
									else if (kyy == "don") price = 400;
									if (price != 0 && pInfo(peer)->gtwl >= price) {
										pInfo(peer)->gtwl -= price;
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										if (kyy == "doc") pInfo(peer)->drtitle = 1, pInfo(peer)->drt = 1, p.Insert(">> You've purchased Doctor Title");
										if (kyy == "leg") pInfo(peer)->legend = 1, pInfo(peer)->is_legend = 1, p.Insert(">> You've purchased Legendary Title");
										if (kyy == "125") pInfo(peer)->level = 125, pInfo(peer)->lvl125 = 1, p.Insert(">> You've purchased Blue Name");
										if (kyy == "men") pInfo(peer)->gp = 1, pInfo(peer)->gp = 1, p.Insert(">> You've purchased Mentor Title");
										if (kyy == "don") pInfo(peer)->gp = 1, pInfo(peer)->gp = 1, p.Insert(">> You've purchased Grow4Good Title");
										update_clothes(peer);
										p.CreatePacket(peer);
									}
									break;
									}
							else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|lock_price_") != string::npos) {
								int item = atoi(cch.substr(59, cch.length() - 59).c_str());
								if (item <= 0 || item >= items.size() || items[item].gtwl == 0) continue;
								pInfo(peer)->lockeitem = item;
								int wl = 0, dl = 0;
								modify_inventory(peer, 242, wl);
								modify_inventory(peer, 1796, dl);
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`9Buy " + items[item].name + "?``|left|" + to_string(items[item].id) + "|\nadd_smalltext|`4" + items[item].description + "``|left|\nadd_smalltext|`1Price: " + (items[item].gtwl > 200 ? to_string(items[item].gtwl / 100) : to_string(items[item].gtwl)) + " " + (items[item].gtwl > 200 ? "Diamond Lock" : "World Locks") + "``|left|\nadd_spacer|\nadd_textbox|How many " + items[item].name + " do you want to buy, for " + (items[item].gtwl > 200 ? to_string(items[item].gtwl / 100) : to_string(items[item].gtwl)) + " " + (items[item].gtwl > 200 ? "Diamond Lock" : "World Locks") + " each?|left|\nadd_text_input|howmuch||1|5|\nadd_smalltext|" + (wl + dl != 0 ? "You have " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", " + to_string(dl) + " Diamond Lock." : ".") + "" : "") + "|left|\nadd_button|lock_item_|`9Purchase``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|locke|No thanks|noflags|0|0|\nnend_dialog|gazette||OK|");
								p.CreatePacket(peer);
								}
								else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|locm_price_") != string::npos) {
								int item = atoi(cch.substr(59, cch.length() - 59).c_str());
								if (item <= 0 || item >= items.size() || items[item].u_gtwl == 0) continue;
								pInfo(peer)->lockeitem = item;
								int wl = 0, dl = 0;
								modify_inventory(peer, 242, wl);
								modify_inventory(peer, 1796, dl);
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`9Buy " + items[item].name + "?``|left|" + to_string(items[item].id) + "|\nadd_smalltext|`4" + items[item].description + "``|left|\nadd_smalltext|`1Price: "+setGems(items[item].u_gtwl) + " World Lock``|left|\nadd_spacer|\nadd_textbox|How many " + items[item].name + " do you want to buy, for " + (items[item].u_gtwl > 200 ? to_string(items[item].u_gtwl / 100) : to_string(items[item].u_gtwl)) + " " + (items[item].u_gtwl > 200 ? "Diamond Lock" : "World Locks") + " each?|left|\nadd_text_input|howmuch||1|5|\nadd_smalltext|" + (wl + dl != 0 ? "You have " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", " + to_string(dl) + " Diamond Lock." : ".") + "" : "") + "|left|\nadd_button|lock_item_|`9Purchase``|noflags|0|0||small|\n\nadd_quick_exit|\nadd_button|lockm|No thanks|noflags|0|0|\nnend_dialog|gazette||OK|");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|lockkskskskske") != string::npos) {
								if (pInfo(peer)->world == "LOCKETOWN") {
									if (thedaytoday == 0 or thedaytoday == 1 or thedaytoday == 5 or thedaytoday == 6) {
										int wl = 0, dl = 0;
										modify_inventory(peer, 242, wl);
										modify_inventory(peer, 1796, dl);
										gamepacket_t p;
										p.Insert("OnDialogRequest");
										p.Insert(a + "set_default_color|`o\n\nadd_label_with_icon|big|`9Locke The Traveling Salesman``|left|4358|\nadd_spacer|small|\nadd_smalltext|Ho there, friend! Locke's my name, and locks are my game. I Love 'em all, Diamond, Huge.. even Small! If you can part with some locks, I'll give you something special in return. Whaddya say?|left|\nadd_spacer|small|\nadd_smalltext|" + (wl + dl != 0 ? "`9(Hmm, smells like you care carrying " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", and and " + to_string(dl) + " Diamond Lock" : "") + ")``" : "`9(Hmm, smells like you don't care any world locks)``") + "|left|\nadd_spacer|small|" + shop_list2 + "|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
										p.CreatePacket(peer);
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|locke") != string::npos) {
								string care = "";
								int wl = 0, dl = 0, bgl = 0;
								modify_inventory(peer, 242, wl);
								modify_inventory(peer, 1796, dl);
								modify_inventory(peer, 7188, bgl);
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(a + "set_default_color|`o\n\nadd_label_with_icon|big|`9GTPS Salesman``|left|2398|\nadd_spacer|small|\nadd_smalltext|Ho there, friend! Locke's my name, and locks are my game. I Love 'em all, Diamond, Huge.. even Small! If you can part with some locks, I'll give you something special in return. Whaddya say?|left|\nadd_spacer|small|\nadd_smalltext|" + (wl + dl != 0 ? "`9(Hmm, smells like you care carrying " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", and and " + to_string(dl) + " Diamond Lock" : "") + ")``" : "`9(Hmm, smells like you don't care any world locks)``") + "|left|\nadd_spacer|small|" + shop_list2 + "|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|lockm") != string::npos) {
								int wl = 0, dl = 0, bgl = 0, cgl = 0;
								modify_inventory(peer, 242, wl);
								modify_inventory(peer, 1796, dl);
								modify_inventory(peer, 7188, bgl);
								modify_inventory(peer, 2696, cgl);
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(a + "set_default_color|`o\n\nadd_label_with_icon|big|`9Sales-Man Untradeable``|left|9528|\nadd_spacer|small|\nadd_smalltext|Damn.. I hate LOCKE!! This guy takes all my diamond locks, i'm hungry so feed me more. The Untradeable Sales-Man|left|\nadd_spacer|small|\nadd_smalltext|" + (wl + dl != 0 ? "`9(Hmm, smells like you care carrying " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", and and " + to_string(dl) + " Diamond Lock" : "") + ")``" : "`9(Hmm, smells like you don't care any world locks)``") + "|left|" + (bgl == 0 ? "" : "\nadd_smalltext|`9(You are also holding additional " + to_string(bgl) + " Blue Gem Locks)``|left|") + "\nadd_spacer|small|" + shop_list2_2 + "|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|bankgem\nbuttonClicked|tfgem") != string::npos) {
								bankgem_transfer(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|bankgem") != string::npos) {
								int berapa = atoi(explode("\n", explode("jumlah_|", cch)[1])[0].c_str());
								string player = explode("\n", explode("player_|", cch)[1])[0];
								if (player.length() < 1) {
									Algorithm::send_overlay(peer, "`4INVALID TYPE");
									break;
								}
								if (player == "WD") {
									int d_;
									int bgl = 0;
									d_ = pInfo(peer)->bankgem;
									bgl = pInfo(peer)->gems;
									if (berapa < 0) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else if (d_ < berapa) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else {
										int c_ = berapa;
										Algorithm::send_overlay(peer, "Successfully withdrawn your `5Gems");
										pInfo(peer)->bankgem -= berapa;
										gamepacket_t p;
										p.Insert("OnSetBux");
										p.Insert(pInfo(peer)->gems += c_);
										p.Insert(0);
										p.CreatePacket(peer);
										save_player(pInfo(peer), false);
									}
								}
								if (player == "DP") {
									int d_;
									int bgl = 0;
									d_ = pInfo(peer)->bankgem;
									bgl = pInfo(peer)->gems;
									if (berapa < 0) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else if (bgl < berapa) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else {
										int c_ = berapa;
										Algorithm::send_overlay(peer, "Successfully deposit your `5Gems");
										pInfo(peer)->bankgem += berapa;
										gamepacket_t p;
										p.Insert("OnSetBux");
										p.Insert(pInfo(peer)->gems -= c_);
										p.Insert(0);
										p.CreatePacket(peer);
										save_player(pInfo(peer), false);
									}
								}
							}
							if (cch.find("action|dialog_return\ndialog_name|name_change") != string::npos) {
								if (not pInfo(peer)->creatorlist) break;
								string nama = explode("\n", explode("name_box|", cch)[1])[0];
								int punya = 0;
								modify_inventory(peer, 1280, punya);
								int kurang = -1;
								if (punya <= 0) {
									Algorithm::send_console(peer, "Dumbass");
									break;
								}
								if (has_playmod(pInfo(peer), "Recently-Name-Changed")) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wChange your GrowID``|left|1280|\nadd_textbox|`4Please Wait Until Your Cooldowns Removed!``|left|\nadd_smalltext|This will change your GrowID `4permanently``.<CR>Your `wBirth Certificate`` will be consumed if you press `5Change It``.<CR>NOTE: The birth certificate only will change your name case (you can not change your whole GrowID)!``|left|\nadd_textbox|Enter your new name:|left|\nadd_text_input|name_box|||32|\nadd_spacer|small|\nend_dialog|name_change|Cancel|Change it!|");
									p.CreatePacket(peer);
									break;
								}
								if (nama.length() < 1 or nama.length() > 32) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wChange your GrowID``|left|1280|\nadd_textbox|`4Change name can't less than 1 letter or more than 32 letters!``|left|\nadd_smalltext|This will change your GrowID `4permanently``.<CR>Your `wBirth Certificate`` will be consumed if you press `5Change It``.<CR>NOTE: The birth certificate only will change your name case (you can not change your whole GrowID)!``|left|\nadd_textbox|Enter your new name:|left|\nadd_text_input|name_box|||32|\nadd_spacer|small|\nend_dialog|name_change|Cancel|Change it!|");
									p.CreatePacket(peer);
									break;
								}
								else if (special_char(nama)) {
									gamepacket_t p1;
									p1.Insert("OnDialogRequest");
									p1.Insert("set_default_color|`o\nadd_label_with_icon|big|`wChange your GrowID``|left|1280|\nadd_textbox|`4You can only use a letter or a number for your new GrowID!``|left|\nadd_smalltext|This will change your GrowID `4permanently``.<CR>Your `wBirth Certificate`` will be consumed if you press `5Change It``.<CR>NOTE: The birth certificate only will change your name case (you can not change your whole GrowID)!``|left|\nadd_textbox|Enter your new name:|left|\nadd_text_input|name_box|||32|\nadd_spacer|small|\nend_dialog|name_change|Cancel|Change it!|");
									p1.CreatePacket(peer);
									break;
								}
								else if (modify_inventory(peer, 1280, kurang) == 0) {
									PlayMods new_playmod{};
									new_playmod.id = 112, new_playmod.time = time(nullptr) + 2592000;
									pInfo(peer)->playmods.push_back(new_playmod);
									string before_name = pInfo(peer)->tankIDName;
									std::filesystem::remove("database/players/" + pInfo(peer)->tankIDName + "_.json");
									pInfo(peer)->tankIDName = nama;
									save_player(pInfo(peer), true);
									for (int I = 0; I < pInfo(peer)->worlds_owned.size(); I++) {
										string name_ = pInfo(peer)->worlds_owned[I];
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											World* world_ = &worlds[p - worlds.begin()];
											if (world_->owner_name == before_name && world_->owner_name != pInfo(peer)->tankIDName) {
												world_->owner_name = pInfo(peer)->tankIDName, world_->owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName;
												//if (pInfo(peer)->world == pInfo(peer)->worlds_owned[I]) update_locks(world_, peer);
											}
										}
									}
									{
										for (int i = 0; i < UIDList.size(); i++) {
											if (to_lower(before_name) == to_lower(UIDList[i].name)) {
												UIDList[i].name = pInfo(peer)->tankIDName;
												save_server_events();
											}
										}
									}
									sendmessage(peer, "console", "`0You changed your GrowID! `o(Recently-Name-Changed mod added 30day's left)");
									update_nick(peer);
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|socialportal\nbuttonClicked|marketitem") != string::npos) {
								string button1 = "", button2 = "", button3 = "", button4 = "", button5 = "", button6 = "", button7 = "", button8 = "", button9 = "";
								for (int i = 0; i < mpitem.size(); i++) {
									if (items[mpitem[i].itemid].blockType == MASK) button1 = "\nadd_button_with_icon|item_1|HAT (" +setGems(mpitem.size())+ ")|staticYellowFrame|6904||";
									if (items[mpitem[i].itemid].blockType == HAIR) button2 = "\nadd_button_with_icon|item_2|HAIR (" + setGems(mpitem.size()) + ")|staticYellowFrame|6008||";
									if (items[mpitem[i].itemid].blockType == FACE) button3 = "\nadd_button_with_icon|item_3|FACE (" + setGems(mpitem.size()) + ")|staticYellowFrame|3774||";
									if (items[mpitem[i].itemid].blockType == NECKLACE) button4 = "\nadd_button_with_icon|item_4|NECK (" + setGems(mpitem.size()) + ")|staticYellowFrame|9344||";
									if (items[mpitem[i].itemid].blockType == SHIRT) button5 = "\nadd_button_with_icon|item_5|SHIRT (" + setGems(mpitem.size()) + ")|staticYellowFrame|8848||";
									if (items[mpitem[i].itemid].blockType == PANTS) button6 = "\nadd_button_with_icon|item_6|PANT (" + setGems(mpitem.size()) + ")|staticYellowFrame|1524||";
									if (items[mpitem[i].itemid].blockType == FEET) button7 = "\nadd_button_with_icon|item_7|FEET (" + setGems(mpitem.size()) + ")|staticYellowFrame|496||";
									if (items[mpitem[i].itemid].blockType == BACK) button8 = "\nadd_button_with_icon|item_8|BACK (" + setGems(mpitem.size()) + ")|staticYellowFrame|1784||";
									if (items[mpitem[i].itemid].blockType == ANCES) button9 = "\nadd_button_with_icon|item_9|ANCES (" + setGems(mpitem.size()) + ")|staticYellowFrame|5080||";
								}
								sendmessage(peer, "dialog", "add_label_with_icon|big|Item Marketplace|left|5308|\nadd_spacer|small|\ntext_scaling_string|9999|" + button1 + button2 + button3 + button4 + button5 + button6 + button7 + button8 + button9 + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|mpitem|Close||");
							}
							else if (cch.find("action|dialog_return\ndialog_name|mpbutton\nbuttonClicked|item_") != string::npos) {
								string bttn = "\nadd_textbox|There is no item in sell|left|";
								int type = atoi(cch.substr(61, cch.length() - 61).c_str());
								for (int i = 0; i < mpitem.size(); i++) {
									if (mpitem[i].sold == false && items[mpitem[i].itemid].blockType == (type == 1 ? MASK : type == 2 ? HAIR : type == 3 ? FACE : type == 4 ? NECKLACE : type == 5 ? SHIRT : type == 6 ? PANTS : type == 7 ? FEET : type == 8 ? BACK : ANCES)) bttn += "\nadd_button_with_icon|buy_" + to_string(i) + "|" + to_string(mpitem[i].price) + "|staticBlueFrame|" + to_string(mpitem[i].itemid) + "||";
								}
								sendmessage(peer, "dialog", "add_label_with_icon|big|Item Marketplace|left|5308|\nadd_spacer|small|\nadd_smalltext|Item Marketplace is the place where you can sold your item even if you're offlined|left|\nadd_smalltext|When your item is sold, system will give your world lock that you got from Item Marketplace with World Lock Bank Balance|left|\nadd_spacer|small|\ntext_scaling_string|99,999BZ|" + bttn + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_button|check_sell|Check Your Selling Items|left|\nadd_quick_exit|\nend_dialog|mpitem||");
							}
							else if (cch.find("action|dialog_return\ndialog_name|add_mpitem\nitemid|") != string::npos) {
								int itemid = atoi(cch.substr(51, cch.length() - 51).c_str());
								if (itemid == 1424 || itemid == 18 || itemid == 32 || itemid <= 0 || itemid > items.size()) break;
								pInfo(peer)->lastwrenchI = itemid;
								packet_(peer, "action|dialog_return\ndialog_name|mpitem\nbuttonClicked|add_sell");
							}
							else if (cch.find("action|dialog_return\ndialog_name|mpitem") != string::npos) {
								if (cch.find("buttonClicked|add_sell") != string::npos) {
									//size_t targetid = cch.find("itemid|");
									//if (targetid == string::npos) break;
									int iditem = pInfo(peer)->lastwrenchI;
									if (iditem > items.size() || iditem <= 0 || iditem == 1424 || iditem == 18 || iditem == 32) break;
									//pInfo(peer)->lastwrenchI = iditem;
									sendmessage(peer, "dialog", "add_label_with_icon|big|Confirmation item in sell|left|" + to_string(iditem) + "|\nadd_spacer|small|\nadd_text_input|price|Set The Price:||9|\nadd_text_input|stock|Set The Stock:||4|\nadd_spacer|small|\nadd_smalltext|Press this button bellow if you are ready to sell this item with that price and stock|left|\nadd_button|confirm_add_sell|Confirm|left|\nadd_quick_exit|\nend_dialog|mpitem|Close||");
							}
							else if (cch.find("buttonClicked|confirm_add_sell") != string::npos) {
									int price = atoi(explode("\n", explode("price|", cch)[1])[0].c_str());
									int stocks = atoi(explode("\n", explode("stock|", cch)[1])[0].c_str());
									int itemid = pInfo(peer)->lastwrenchI;
									if (itemid <= 0 || itemid > items.size() || itemid == 18 || itemid == 32 || stocks <= 0 || price <= 0 || price > 2000000000) break;
									for (int a = 0; a < mpitem.size(); a++) {
										if (itemid == mpitem[a].itemid && pInfo(peer)->tankIDName == mpitem[a].owner) {
											int have = 0, jmbd = 0;
											modify_inventory(peer, itemid, have);
											if (modify_inventory(peer, itemid, jmbd -= stocks) == 0) {
											mpitem[a].price = price;
											mpitem[a].stock = stocks;
											sendmessage(peer, "console", items[itemid].name + " detected on Items Marketplace. Your selling items name " + items[itemid].name + " price and stock will changed by instruction");
											save_market_item();
											break;
										}
										}
									}
									if (pInfo(peer)->selling_item.size() > 3) { sendmessage(peer, "console", "You already had 3 items on Items Marketplace"); break; }
									int kontol = 0, kurg = 0; modify_inventory(peer, itemid, kontol); if (kontol < stocks) { sendmessage(peer, "console", "You don't have that much"); break; }
									modify_inventory(peer, itemid, kurg -= stocks);
									MarketplaceItem itm_{};
									itm_.receive = 0,itm_.sold = false, itm_.itemid = itemid, itm_.price = price, itm_.stock = stocks, itm_.owner = pInfo(peer)->tankIDName;
									mpitem.push_back(itm_);
									save_market_item();
									sendmessage(peer, "overlay", "Success");
									sendmessage(peer, "console", "Success added your item with name " + items[itemid].name + " to Item Marketplace");
								}
							else if (cch.find("buttonClicked|check_sell") != string::npos) {
									vector<int> emptysell = { 0,0,0 };
									if (pInfo(peer)->selling_item.empty()) pInfo(peer)->selling_item = emptysell;
									string btn = "";
									for (int i = 0; i < 3; i++) btn += "\nadd_button_with_icon|"+(pInfo(peer)->selling_item[i] == 0 or pInfo(peer)->selling_item.empty() ? "add_item" : "info_" + to_string(pInfo(peer)->selling_item[i])) + "||staticGrayFrame|" + (pInfo(peer)->selling_item[i] == 0 or pInfo(peer)->selling_item.empty() ? "9412" : to_string(pInfo(peer)->selling_item[i])) + "||\nadd_custom_margin|x:10;y:0|";
									sendmessage(peer, "dialog", "add_label_with_icon|big|Check Item in Sell|left|9412|\nadd_spacer|small|\nadd_smalltext|Add or edit your selling item here by pressing the button below|left|" + btn + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nend_dialog|mpitem|Close||");
								}
							else if (cch.find("buttonClicked|info_") != string::npos || cch.find("buttonClicked|add_item") != string::npos) {
									if (cch.find("buttonClicked|info_") != string::npos) {
										size_t target = cch.find("info_"); if (target == string::npos) break; int pos = atoi(cch.substr(target + 5).c_str());
										vector<int> trgt = pInfo(peer)->selling_item;
										for (int i = 0; i < mpitem.size(); i++) {
											if (find(trgt.begin(), trgt.end(), pos) != trgt.end() && pos == mpitem[i].itemid) {
												pInfo(peer)->lastwrenchI = pos;
												sendmessage(peer, "dialog", "add_label_with_icon|big|Information Item in Sell (" + items[pos].name + ")|left|" + to_string(pos) + "|\nadd_spacer|small|\nadd_smalltext|Price: " + setGems(mpitem[i].price) + " World Lock Credit/Balance|left|\nadd_smalltext|Stock: " + setGems(mpitem[i].stock) + "|left|\nadd_spacer|small|\nadd_button|edits_1|Add Stock|left|\nadd_button|edits_2|Take Stock|left|\nadd_button|edits_3|Edit Price|left|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|mpitem|Close||");
											}
										}
									}
									else if (cch.find("buttonClicked|add_item") != string::npos) {
										sendmessage(peer, "dialog", "add_textbox|Choose Item what you want to sell|left|\nadd_item_picker|itemid|Choose an item to sell|Choose Clothing Item!|\nadd_quick_exit|\nend_dialog|add_mpitem|||");
									}
									break;
								}
							else if (cch.find("buttonClicked|edits_") != string::npos) {
									size_t trgt = cch.find("edits_"); if (trgt == string::npos) break; int type = atoi(cch.substr(trgt + 6).c_str());
									if (type >= 1 || type <= 3) {
										for (int i = 0; i < mpitem.size(); i++) {
											if (mpitem[i].itemid == pInfo(peer)->lastwrenchI && to_lower(mpitem[i].owner) == to_lower(pInfo(peer)->tankIDName) && find(pInfo(peer)->selling_item.begin(), pInfo(peer)->selling_item.end(), pInfo(peer)->lastwrenchI) != pInfo(peer)->selling_item.end()) {
												string dialog = (type == 1 ? "Add Stock" : type == 2 ? "Take Stock" : "Edit Price"), cnt = (type != 3 ? setGems(mpitem[i].stock) : to_string(mpitem[i].price));
												sendmessage(peer, "dialog", "add_label_with_icon|big|" + dialog + " Stock (" + cnt + ")|left|" + to_string(pInfo(peer)->lastwrenchI) + "|\nadd_spacer|small|\nadd_text_input|count|Count:||4|\nadd_button|cdt_"+to_string(type)+"|Confirm|left|\nend_dialog|mpitem|Nevermind||");
											}
										}
									}
									break;
								}
							else if (cch.find("buttonClicked|cdt_") != string::npos) {
									size_t trgt = cch.find("cdt_"); if (trgt == string::npos) break; int type = atoi(cch.substr(trgt + 4).c_str());
									int count = atoi(explode("\n", explode("count|", cch)[1])[0].c_str());
									if (count <= 0) break;
									if (type == 1) {
										for (int i = 0; i < mpitem.size(); i++) {
											if (mpitem[i].itemid == pInfo(peer)->lastwrenchI && to_lower(mpitem[i].owner) == to_lower(pInfo(peer)->tankIDName) && find(pInfo(peer)->selling_item.begin(), pInfo(peer)->selling_item.end(), pInfo(peer)->lastwrenchI) != pInfo(peer)->selling_item.end()) {
												int have = 0, got = 0; modify_inventory(peer, pInfo(peer)->lastwrenchI, have); if (have < count) { sendmessage(peer, "console", "You don't have that much"); break; }
												modify_inventory(peer, pInfo(peer)->lastwrenchI, got -= count);
												mpitem[i].stock += count;
												save_market_item();
												sendmessage(peer, "overlay", "Success add stock"), sendmessage(peer, "console", "Success add stock");
											}
											break;
										}
									}
									else if (type == 2) {
										for (int i = 0; i < mpitem.size(); i++) {
											if (mpitem[i].itemid == pInfo(peer)->lastwrenchI && to_lower(mpitem[i].owner) == to_lower(pInfo(peer)->tankIDName) && find(pInfo(peer)->selling_item.begin(), pInfo(peer)->selling_item.end(), pInfo(peer)->lastwrenchI) != pInfo(peer)->selling_item.end()) {
												int got = 0; if (count > 250) break;
												if (mpitem[i].stock >= count && modify_inventory(peer, pInfo(peer)->lastwrenchI, got += count) == 0) {
													mpitem[i].stock -= count;
													if (mpitem[i].stock == 0) mpitem.erase(mpitem.begin() + i);
													save_market_item();
													sendmessage(peer, "console", "You took" + setGems(count) + " " + items[pInfo(peer)->lastwrenchI].name + " from your Market");
												}
												break;
											}
											break;
										}
									}
									else if (type == 3) {
										if (count > 2000000000) break;
										for (int i = 0; i < mpitem.size(); i++) {
											if (mpitem[i].itemid == pInfo(peer)->lastwrenchI && to_lower(mpitem[i].owner) == to_lower(pInfo(peer)->tankIDName) && find(pInfo(peer)->selling_item.begin(), pInfo(peer)->selling_item.end(), pInfo(peer)->lastwrenchI) != pInfo(peer)->selling_item.end()) {
												mpitem[i].price = count;
												save_market_item(); sendmessage(peer, "console", "Success edit your selling item price");
											}
											break;
										}
									}
									break;
								}
							else if (cch.find("buttonClicked|buy_") != string::npos) {
									size_t target = cch.find("buy_"); if (target == string::npos) break; int pos = atoi(cch.substr(target + 4).c_str());
									if (pos > mpitem.size()) break;
									//pInfo(peer)->lastworldcase = pos;
									sendmessage(peer, "dialog", "add_label_with_icon|big|Purchase Confirmation|left|" + to_string(mpitem[pos].itemid) + "|\nadd_spacer|small|\nadd_textbox|Information:|left|\nadd_label_with_icon|small|Item Name: " + items[mpitem[pos].itemid].name + "|left|" + to_string(mpitem[pos].itemid) + "|\nadd_label_with_icon|small|Price: " + setGems(mpitem[pos].price) + " World Lock Credit|left|242|\nadd_label_with_icon|small|Stock: "+setGems(mpitem[pos].stock)+"|left|"+to_string(mpitem[pos].itemid)+"\nadd_spacer|small|\nadd_smalltext|Are you sure you want to buy this ?|left|\nadd_button| confirm_buy_" + to_string(pos) + " | Purchase | left | \nadd_quick_exit | \nend_dialog | mpitem | Nevermind || ");
								}
							else if (cch.find("buttonClicked|confirm_buy_") != string::npos) {
									size_t trget = cch.find("confirm_buy_"); if (trget == string::npos) break; int count = atoi(explode("\n", explode("count|", cch)[1])[0].c_str()), pos = atoi(cch.substr(trget + 12).c_str());
									if (pos > mpitem.size() || to_lower(mpitem[pos].owner) == to_lower(pInfo(peer)->tankIDName) || mpitem[pos].stock < count || count < 0) break; if (mpitem[pos].sold) break;
									if (pInfo(peer)->bwl >= (mpitem[pos].price * count)) {
										int kntl = 0;
										if (modify_inventory(peer, mpitem[pos].itemid, kntl += count) == 0) {
											pInfo(peer)->bwl -= mpitem[pos].price * count; mpitem[pos].stock -= count;
											//save_market_item();
											bool Online = false;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) { //fix
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (to_lower(pInfo(currentPeer)->tankIDName) == mpitem[pos].owner) {
													Online = true;
													int total = mpitem[pos].price * count, ids = mpitem[pos].itemid;
													pInfo(currentPeer)->bwl += total;
													if (mpitem[pos].stock == 0) pInfo(currentPeer)->selling_item.erase(remove(pInfo(currentPeer)->selling_item.begin(), pInfo(currentPeer)->selling_item.end(), mpitem[pos].itemid), pInfo(currentPeer)->selling_item.end()), mpitem.erase(mpitem.begin() + pos);
													save_market_item();
													sendmessage(peer, "console", "You received " + setGems(total) + " World Lock Credit from Item Marketplace");
													sendmessage(currentPeer, "console", "You just bought " + setGems(count) + " " + items[ids].name + " for " + setGems(total) + " World Lock Credit");
												}
											}
											if (Online == false) {
												mpitem[pos].receive += (mpitem[pos].price * count);
												if (mpitem[pos].stock == 0) mpitem[pos].sold = true;
												save_market_item();
												sendmessage(peer, "console", "You just bought " + setGems(count) + " " + items[mpitem[pos].itemid].name + " for " + setGems(mpitem[pos].price * count) + " World Lock Credit");
											}
										}
										else sendmessage(peer, "console", "No Inventory Space");
									}
									else sendmessage(peer, "console","You cannot afford it");
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|market") != string::npos) {
								if (cch.find("buttonClicked|checksell") != string::npos) {
									string button = "";
									for (int i = 0; i < pInfo(peer)->selling_world.size(); i++) {
										button += "\nadd_button_with_icon|infoW_" + to_string(i) + "|" + pInfo(peer)->selling_world[i] + "|staticYellowFrame|3802||\nadd_custom_margin|x:30;y:0|";
									}
									Algorithm::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|My Selling World|left|242|\nadd_spacer|small|" + button + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_smalltext|You can check your selling world information by clicking the button|left|\nadd_smalltext|You can also edit your selling world information like edit price or remove your world from marketplace|left|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|market|Close||");
								}
								else if (cch.find("buttonClicked|infoW_") != string::npos) {
									size_t T = cch.find("infoW_");
									if (T == string::npos) break;
									int target = atoi(cch.substr(T + 6).c_str());
									for (int I = 0; I < Market.size(); I++) {
										if (pInfo(peer)->selling_world[target] == Market[I].world_name && pInfo(peer)->tankIDName == Market[I].owned_by) {
											Algorithm::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|World Information|left|3802|\nadd_spacer|small|\nadd_textbox|World Name: " + Market[I].world_name + "|left|\nadd_textbox|Price: " + setGems(Market[I].price) + " Blue Gem Credit|left|\nadd_spacer|small|\nadd_button|edit_" + to_string(I) + "|Edit World Price|left|\nadd_button|remv_" + to_string(I) + "|Remove this world from marketplace|left|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|market|Close||");
										}
									}
								}
								else if (cch.find("buttonClicked|edit_") != string::npos || cch.find("buttonClicked|cEdit_") != string::npos) {
									if (cch.find("buttonClicked|edit_") != string::npos) {
										size_t T = cch.find("edit_");
										if (T == string::npos) break;
										int target = atoi(cch.substr(T + 5).c_str());
										for (int I = 0; I < pInfo(peer)->selling_world.size(); I++) { if (pInfo(peer)->selling_world[I] != Market[target].world_name && pInfo(peer)->tankIDName != Market[target].owned_by) break; }
										Algorithm::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|Edit Price ( " + Market[target].world_name + " ) |left|242|\nadd_spacer|small|\nadd_text_input|price|Price: |" + to_string(Market[target].price) + "|10|\nadd_spacer|small|\nadd_button|cEdit_" + to_string(target) + "|left¦\nadd_quick_exit|\nend_dialog|market||");
									}
									else if (cch.find("buttonClicked|cEdit_") != string::npos) {
										size_t T = cch.find("cEdit_");
										if (T == string::npos) break;
										int target = atoi(cch.substr(T + 6).c_str());
										for (int I = 0; I < pInfo(peer)->selling_world.size(); I++) { if (pInfo(peer)->selling_world[I] != Market[target].world_name && pInfo(peer)->tankIDName != Market[target].owned_by) break; }
										int price = atoi(txt_explode("price|", cch).c_str());
										if (price >= 1) {
											Market[target].price = price;
											save_markets();
											sendmessage(peer, "overlay", "Success Edit " + pInfo(peer)->selling_world[target] + " Price");
										}
										else {
											sendmessage(peer, "overlay", "Price can't be 0 or less than 0");
											packet_(peer, "action|dialog_return\ndialog_name|market\nbuttonClicked|edit_" + to_string(target));
										}
									}
								}
								else if (cch.find("buttonClicked|remv_") != string::npos) {
									size_t T = cch.find("remv_");
									if (T == string::npos) break;
									int target = atoi(cch.substr(T + 5).c_str());
									for (int I = 0; I < Market.size(); I++) {
										if (pInfo(peer)->selling_world[I] == Market[target].world_name && pInfo(peer)->tankIDName == Market[target].owned_by) {
											string nama = pInfo(peer)->selling_world[I];
											pInfo(peer)->selling_world.erase(pInfo(peer)->selling_world.begin() + I);
											Market.erase(Market.begin() + target), save_markets();
											sendmessage(peer, "overlay", "Success Removing World " + nama + " from World Marketplace");
										}
									}
								}
								else if (cch.find("buttonClicked|buy_") != string::npos) {
									size_t target = cch.find("buy_");
									if (target == string::npos) break;
									int Target = atoi(cch.substr(target + 4).c_str());
									if (pInfo(peer)->lastworldcase == Target) { sendmessage(peer, "overlay", "Please Wait for 3 Second's"); break; }
									if (Target > Market.size()) break;
									//if (pInfo())
									pInfo(peer)->lastworldcase = Target;
									string warp_world = Market[Target].world_name;
									if (pInfo(peer)->world != warp_world) {
										replace_str(warp_world, "\n", "");
										join_world(peer, warp_world);
										Sleep(500);
									}
									Algorithm::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|World Information ( `1" + Market[Target].world_name + "`o )|left|3802|\nadd_spacer|small|\nadd_label_with_icon|small|Owner Name: " + Market[Target].owned_by + "|left|12436|\nadd_label_with_icon|small|Price: " + setGems(Market[Target].price) + " Credit Blue Gem Lock|left|242|\nadd_spacer|small|\nadd_button|confirmbuy_" + setGems(Target) + "|Buy This World|left|\nend_dialog|market|Nevermind||");
								}
								else if (cch.find("buttonClicked|confirmbuy_") != string::npos) {
									size_t Target = cch.find("confirmbuy_");
									if (Target == string::npos) break;
									int TPos = atoi(cch.substr(Target + 11).c_str());
									if (TPos > Market.size() || Market[TPos].sold == true || pInfo(peer)->tankIDName == Market[TPos].owned_by) break;
									if (pInfo(peer)->world != Market[TPos].world_name) break;
									if (pInfo(peer)->bank_p >= Market[Target].price) {
										pInfo(peer)->bank_p = (pInfo(peer)->bank_p - Market[TPos].price);
										bool Online = false;
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) { //fix
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (Market[TPos].owned_by == pInfo(currentPeer)->tankIDName) {
												Online = true;
												string name_ = pInfo(peer)->world;
												vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
												if (p != worlds.end()) {
													pInfo(currentPeer)->bwl = (pInfo(currentPeer)->bwl + Market[TPos].price);
													//pInfo(currentPeer)->worlds_owned.erase(remove(pInfo(currentPeer)->worlds_owned.begin(), pInfo(currentPeer)->worlds_owned.end(), Market[TPos].world_name), pInfo(currentPeer)->worlds_owned.end());
													for (int kn = 0; kn < pInfo(currentPeer)->selling_world.size(); kn++) if (pInfo(currentPeer)->selling_world[kn] == Market[TPos].world_name) pInfo(currentPeer)->selling_world.erase(remove(pInfo(currentPeer)->selling_world.begin(), pInfo(currentPeer)->selling_world.end(), Market[TPos].world_name), pInfo(currentPeer)->selling_world.end());
													//pInfo(peer)->worlds_owned.push_back(pInfo(peer)->world);
													sendmessage(currentPeer, "overlay", "You sold your world with name " + Market[TPos].world_name + " and received " + setGems(Market[TPos].price) + " Credit Blue Gem Lock");
													sendmessage(currentPeer, "console", "You sold your world with name " + Market[TPos].world_name + " and received " + setGems(Market[TPos].price) + " Credit Blue Gem Lock");
													sendmessage(peer, "overlay", "You just bought this world for " + setGems(Market[TPos].price) + " Blue Gem Lock Credit");
													World* world_ = &worlds[p - worlds.begin()];
													//transfer_world(world_, currentPeer, peer);
													world_->owner_name = pInfo(peer)->tankIDName, world_->owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName;
													pInfo(peer)->worlds_owned.push_back(pInfo(peer)->world);
													vector<string> cpeerWO = pInfo(currentPeer)->worlds_owned;
													if (find(cpeerWO.begin(), cpeerWO.end(), Market[TPos].world_name) != cpeerWO.end()) pInfo(currentPeer)->worlds_owned.erase(remove(cpeerWO.begin(), cpeerWO.end(), Market[TPos].world_name), cpeerWO.end());
													if (world_->owner_name != pInfo(peer)->tankIDName) world_->owner_name = pInfo(peer)->tankIDName, world_->owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName;
													string wname = Market[TPos].world_name; replace_str(wname, "\n", "");
													exit_(currentPeer); Sleep(1000); join_world(currentPeer, wname);
													Market.erase(Market.begin() + TPos);
													save_markets();
												}
											}
										}
										if (Online == false) {
											string name_ = pInfo(peer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world = &worlds[p - worlds.begin()];
												if (Market[TPos].owned_by != pInfo(peer)->tankIDName) {
													Market[TPos].sold = true;
													save_markets();
													pInfo(peer)->worlds_owned.push_back(pInfo(peer)->world);
													//transfer_world(world, world->owner_name, peer);
													if (pInfo(peer)->tankIDName != world->owner_name) world->owner_name = pInfo(peer)->tankIDName, world->owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName;
													sendmessage(peer, "overlay", "You just bought this world for " + setGems(Market[TPos].price) + " Credit Blue Gem Lock");
													sendmessage(peer, "console", "You just bought this world for " + setGems(Market[TPos].price) + " Credit Blue Gem Lock");
													//update_locks(world, peer);
													string wname = pInfo(peer)->world; replace_str(wname, "\n", "");
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) { //fix
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
														if (pInfo(currentPeer)->world == pInfo(peer)->world) {
															exit_(currentPeer); 
															sendmessage(currentPeer, "console", pInfo(peer)->name_color + pInfo(peer)->tankIDName + " `o Just bought this world from World Marketplace. All players who's in this world will be reentering this world");
															Sleep(1000); join_world(currentPeer, wname);
														}
													}
												}
											}
										}
									}
									else sendmessage(peer, "console", "You don't have that much");
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|socialportal\nbuttonClicked|gwm") != string::npos) {
								world_mart(peer);
							}
							else if (cch.find("action|dialog_return\ndialog_name|cryptochange\nbuttonClicked|confirmbc") != string::npos) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|Crypto Price Change|left|10002|\nadd_spacer|small|\nadd_textbox|Here you can change all crypto price with only 1 button. So after you put how the price and then you press the button it will drop/rise depend on how many you put on it|left|\nadd_text_input|jumlah_|How many?:||5|\nadd_spacer|small|\nadd_button|risebc|Rise All Crypto Price|left|\nadd_button|dropbc|Drop All Crypto Price|\nend_dialog|cryptochange|Nevermind||");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|slaveoption") != string::npos) {
							if (cch.find("buttonClicked|setmagloc") != string::npos) {
								pInfo(peer)->slave.magnetron_id = pInfo(peer)->magnetron_id, pInfo(peer)->slave.magnetron_x = pInfo(peer)->magnetron_x, pInfo(peer)->slave.magnetron_y = pInfo(peer)->magnetron_y;
								sendmessage(peer, "overlay", "Success set Magplant Remote Location");
							}
							else if (cch.find("buttonClicked|kill") != string::npos) {
								pInfo(peer)->slave.active = 0;
								ENetPacket* onKilledPacket = Variant{ "OnKilled" }.pack(pInfo(peer)->slave.netID, 100);
								enet_peer_send(peer, 0, onKilledPacket);
								gamepacket_t p;
								p.Insert("OnRemove"); p.Insert("netID|" + to_string(pInfo(peer)->slave.netID) + "\n");
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->slave.worlds) continue;
									p.CreatePacket(currentPeer);
								}
								sendmessage(peer, "console", "You just killed your slave. Use /farmslave to spawn your slave again");
								pInfo(peer)->slave.worlds.erase();
							}
							else if (cch.find("buttonClicked|active") != string::npos) {
								if (pInfo(peer)->slave.magnetron_id != 0 && pInfo(peer)->slave.magnetron_x != 0 && pInfo(peer)->slave.magnetron_y != 0) {
									pInfo(peer)->slave.active = (pInfo(peer)->slave.active == 0 ? 1 : 0);
									string what = (pInfo(peer)->slave.active == 1 ? "start" : "stop");
									sendmessage(peer, "overlay", "Slave is " + what + " farming now");
									gamepacket_t p;
									p.Insert("OnRemove");
									p.Insert("netID|" + to_string(pInfo(peer)->slave.netID) + "\n"); for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->slave.worlds) continue;
										p.CreatePacket(currentPeer);
									}
									slave_upd(peer);
									if (pInfo(peer)->slave.active == 1) loop_cheat(peer);
								}
							}
						}
							else if (cch.find("action|dialog_return\ndialog_name|worldtutorial") != string::npos) {
								if (cch.find("buttonClicked|tutorialworld") != string::npos) {
									tutorial_world(peer);
									cout << "A new account has been created, name " + pInfo(peer)->tankIDName + " clicked starter pack by system @iAlfa" << endl;
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|login_p") != string::npos) {
								if (cch.find("buttonClicked|loginpage") != string::npos) {
									loginpage(peer);
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|ngewe_dulu\n") != string::npos) {
								if (cch.find("buttonClicked|buy_cheater") != string::npos) {
									int item = atoi(cch.substr(54, cch.length() - 54).c_str());
									if (pInfo(peer)->glcoin <= 0) {
										gamepacket_t p;
										p.Insert("OnTextOverlay");
										p.Insert("You don't have any coin left");
										p.CreatePacket(peer);
									}
									else if (pInfo(peer)->glcoin >= 1) {
										pInfo(peer)->glcoin -= 1;
										pInfo(peer)->cheater = 1;
										Algorithm::send_overlay(peer, "`9Successfully purchased Permanent Cheater role``");
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										break;

									}
								}
								if (cch.find("buttonClicked|buy_mvp") != string::npos) {
									int item = atoi(cch.substr(54, cch.length() - 54).c_str());
									if (pInfo(peer)->glcoin <= 0) {
										gamepacket_t p;
										p.Insert("OnTextOverlay");
										p.Insert("You don't have any coin left");
										p.CreatePacket(peer);
									}
									else if (pInfo(peer)->glcoin >= 2) {
										pInfo(peer)->glcoin -= 2;
										pInfo(peer)->mod = 1, pInfo(peer)->cheater = 1;
										Algorithm::send_overlay(peer, "`9Successfully purchased MVP role``");
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										break;

									}
								}
								if (cch.find("buttonClicked|buy_mod") != string::npos) {
									int item = atoi(cch.substr(54, cch.length() - 54).c_str());
									if (pInfo(peer)->glcoin <= 0) {
										gamepacket_t p;
										p.Insert("OnTextOverlay");
										p.Insert("You don't have any coin left");
										p.CreatePacket(peer);
									}
									else if (pInfo(peer)->glcoin >= 3) {
										pInfo(peer)->glcoin -= 3;
										pInfo(peer)->mod = 1, pInfo(peer)->dev = 1;
										Algorithm::send_overlay(peer, "`9Successfully purchased MOD role``");
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										break;

									}
								}
								if (cch.find("buttonClicked|buy_umod") != string::npos) {
									int item = atoi(cch.substr(54, cch.length() - 54).c_str());
									if (pInfo(peer)->glcoin <= 0) {
										gamepacket_t p;
										p.Insert("OnTextOverlay");
										p.Insert("You don't have any coin left");
										p.CreatePacket(peer);
									}
									else if (pInfo(peer)->glcoin >= 6) {
										pInfo(peer)->glcoin -= 6;
										pInfo(peer)->mod = 1, pInfo(peer)->cheater = 1, pInfo(peer)->dev = 1, pInfo(peer)->superdev = 1;
										Algorithm::send_overlay(peer, "`9Successfully purchased UMOD role``");
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										break;

									}
								}
								if (cch.find("buttonClicked|buy_helper") != string::npos) {
									int item = atoi(cch.substr(54, cch.length() - 54).c_str());
									if (pInfo(peer)->glcoin <= 0) {
										gamepacket_t p;
										p.Insert("OnTextOverlay");
										p.Insert("You don't have any coin left");
										p.CreatePacket(peer);
									}
									else if (pInfo(peer)->glcoin >= 7) {
										pInfo(peer)->glcoin -= 7;
										pInfo(peer)->mod = 1, pInfo(peer)->cheater = 1, pInfo(peer)->dev = 1, pInfo(peer)->superdev = 1, pInfo(peer)->helper = 1;
										Algorithm::send_overlay(peer, "`9Successfully purchased Helper Role``");
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										break;

									}
								}
								if (cch.find("buttonClicked|buy_dev") != string::npos) {
									int item = atoi(cch.substr(54, cch.length() - 54).c_str());
									if (pInfo(peer)->glcoin <= 0) {
										gamepacket_t p;
										p.Insert("OnTextOverlay");
										p.Insert("You don't have any coin left");
										p.CreatePacket(peer);
									}
									else if (pInfo(peer)->glcoin >= 8) {
										pInfo(peer)->glcoin -= 8;
										pInfo(peer)->mod = 1, pInfo(peer)->cheater = 1, pInfo(peer)->dev = 1, pInfo(peer)->superdev = 1, pInfo(peer)->helper = 1, pInfo(peer)->owner = 1;
										Algorithm::send_overlay(peer, "`9Successfully purchased Developer Role``");
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										break;

									}
								}
								if (cch.find("buttonClicked|buy_udev") != string::npos) {
									int item = atoi(cch.substr(54, cch.length() - 54).c_str());
									if (pInfo(peer)->glcoin <= 0) {
										gamepacket_t p;
										p.Insert("OnTextOverlay");
										p.Insert("You don't have any coin left");
										p.CreatePacket(peer);
									}
									else if (pInfo(peer)->glcoin >= 10) {
										pInfo(peer)->glcoin -= 10;
										pInfo(peer)->mod = 1, pInfo(peer)->cheater = 1, pInfo(peer)->dev = 1, pInfo(peer)->superdev = 1, pInfo(peer)->helper = 1, pInfo(peer)->owner = 1, pInfo(peer)->udev = 1;
										Algorithm::send_overlay(peer, "`9Successfully purchased Ultra-Developer Role``");
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										break;

									}
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|giveend") != string::npos) {
								if (cch.find("buttonClicked|giveawaysdstart") != string::npos) {
									auto_give2(peer);
								}
								if (cch.find("buttonClicked|autogive1") != string::npos) {
								auto_give1(peer);
								gamepacket_t p4;
								p4.Insert("OnAddNotification"), p4.Insert("interface/large/special_event.rttex"), p4.Insert("`4Congratulations! `9You `8Get Giveaway `#From `9@" + clist1 + ""), p4.Insert("audio/ogg/suspended.ogg"), p4.Insert(0), p4.CreatePacket(peer);
								}
								if (cch.find("buttonClicked|rolecoin") != string::npos) {
									rolecoin(peer);
								}
							}
							if (cch.find("action|dialog_return\ndialog_name|ruler_sword_settings") != string::npos) {
								if (pInfo(peer)->hand == 9510)
								{
									pInfo(peer)->kill_mode = atoi(explode("\n", explode("checkbox_killer|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->genjutsu = atoi(explode("\n", explode("checkbox_genjutsu|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->wide_place = atoi(explode("\n", explode("checkbox_wide_place|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->wide_punch = atoi(explode("\n", explode("checkbox_wide_punch|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->genjutsu2 = atoi(explode("\n", explode("checkbox_genjutsu2|", cch)[1])[0].c_str()) == 1 ? true : false;
									//if (pInfo(peer)->face == 13554 and pInfo(peer)->hand == 13560) pInfo(peer)->knockback = atoi(explode("\n", explode("checkbox_izanami|", cch)[1])[0].c_str()) == 1 ? true : false;
									//if (pInfo(peer)->izanagi) pInfo(peer)->spotlight = true;
									pInfo(peer)->punched = pInfo(peer)->kill_mode ? 13 : 0;
									if (pInfo(peer)->genjutsu2) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->dev >= 1) continue;
											if (pInfo(currentPeer)->world == pInfo(peer)->world and pInfo(currentPeer)->tankIDName != pInfo(peer)->tankIDName) {
												pInfo(currentPeer)->got_tsukoyomi = true;
												PlayMods new_playmod{};
												new_playmod.id = 3;
												new_playmod.time = time(nullptr) + 86400;
												new_playmod.user = pInfo(currentPeer)->tankIDName;
												pInfo(currentPeer)->playmods.push_back(new_playmod);
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("You've caught in Tsukoyomi dream! (`$Tsukoyomi`` mod added, `$permanent time ``left)");
												p.CreatePacket(currentPeer);
												pInfo(currentPeer)->face = 13610;
												update_clothes(currentPeer);
											}
										}
									}
									else {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or not pInfo(currentPeer)->got_tsukoyomi or pInfo(currentPeer)->dev >= 1) continue;
											if (pInfo(currentPeer)->world == pInfo(peer)->world and pInfo(currentPeer)->tankIDName != pInfo(peer)->tankIDName) {
												for (int i = 0; i < pInfo(currentPeer)->playmods.size(); i++)
													if (pInfo(currentPeer)->playmods[i].id == 3)
														pInfo(currentPeer)->playmods[i].time = 0;
												pInfo(currentPeer)->got_tsukoyomi = false;

												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("You've gone from Tsukoyomi dream! (`$Tsukoyomi`` mod removed)");
												p.CreatePacket(currentPeer);
												pInfo(currentPeer)->face = 0;
												update_clothes(currentPeer);
											}
										}
									}
									if (pInfo(peer)->genjutsu) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->admin or currentPeer == peer or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
											add_curse(currentPeer, 300, "genjutsu", "someone");
										}
									}

									update_clothes(peer);
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("Settings updated.");
									p.CreatePacket(peer);
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|artifact_upgrade") != string::npos) {
								/*
								5104|Celestial Kaleidoscope
								5106|Harmonic Chimes
								5204|Plasma Globe
								5070|Crystallized Reality
								5072|Crystallized Wealth
								5074|Crystallized Brilliance
								5076|Crystallized Nature|999
								*/
								// Wisdom
								if (cch.find("buttonClicked|upgrade-5126") != string::npos) {
									SendArtifactUpgrade(peer, 5078, 1, 5126, 5104, 1, 5074, 1);
								}
								else if (cch.find("buttonClicked|upgrade-5128") != string::npos) {
									SendArtifactUpgrade(peer, 5126, 1, 5128, 5106, 1, 5074, 1);
								}
								else if (cch.find("buttonClicked|upgrade-5130") != string::npos) {
									SendArtifactUpgrade(peer, 5128, 2, 5130, 5204, 1, 5074, 1);
								}
								else if (cch.find("buttonClicked|upgrade-5132") != string::npos) {
									SendArtifactUpgrade(peer, 5130, 2, 5132, 5104, 2, 5074, 2);
								}
								else if (cch.find("buttonClicked|upgrade-5134") != string::npos) {
									SendArtifactUpgrade(peer, 5132, 3, 5134, 5106, 3, 5074, 2);
								}
								// Tesseract
								else if (cch.find("buttonClicked|upgrade-5144") != string::npos) {
									SendArtifactUpgrade(peer, 5080, 1, 5144, 5204, 1, 5070, 1);
								}
								else if (cch.find("buttonClicked|upgrade-5146") != string::npos) {
									SendArtifactUpgrade(peer, 5144, 1, 5146, 5104, 1, 5070, 1);
								}
								else if (cch.find("buttonClicked|upgrade-5148") != string::npos) {
									SendArtifactUpgrade(peer, 5146, 2, 5148, 5106, 1, 5070, 1);
								}
								else if (cch.find("buttonClicked|upgrade-5150") != string::npos) {
									SendArtifactUpgrade(peer, 5148, 2, 5150, 5204, 2, 5070, 2);
								}
								else if (cch.find("buttonClicked|upgrade-5152") != string::npos) {
									SendArtifactUpgrade(peer, 5150, 2, 5152, 5104, 3, 5070, 2);
								}
								// Seed of Life
								else if (cch.find("buttonClicked|upgrade-5162") != string::npos) {
									SendArtifactUpgrade(peer, 5082, 1, 5162, 5106, 1, 5076, 1);
								}
								else if (cch.find("buttonClicked|upgrade-5164") != string::npos) {
									SendArtifactUpgrade(peer, 5162, 1, 5164, 5204, 1, 5076, 1);
								}
								else if (cch.find("buttonClicked|upgrade-5166") != string::npos) {
									SendArtifactUpgrade(peer, 5164, 2, 5166, 5104, 1, 5076, 1);
								}
								else if (cch.find("buttonClicked|upgrade-5168") != string::npos) {
									SendArtifactUpgrade(peer, 5166, 2, 5168, 5106, 2, 5076, 2);
								}
								else if (cch.find("buttonClicked|upgrade-5170") != string::npos) {
									SendArtifactUpgrade(peer, 5168, 2, 5170, 5204, 3, 5076, 2);
								}
								// Riches
								else if (cch.find("buttonClicked|upgrade-5180") != string::npos) {
									SendArtifactUpgrade(peer, 5084, 1, 5180, 5104, 2, 5072, 1);
								}
								else if (cch.find("buttonClicked|upgrade-5182") != string::npos) {
									SendArtifactUpgrade(peer, 5180, 1, 5182, 5204, 2, 5072, 1);
								}
								else if (cch.find("buttonClicked|upgrade-5184") != string::npos) {
									SendArtifactUpgrade(peer, 5182, 2, 5184, 5106, 2, 5072, 1);
								}
								else if (cch.find("buttonClicked|upgrade-5186") != string::npos) {
									SendArtifactUpgrade(peer, 5184, 2, 5186, 5104, 3, 5072, 2);
								}
								else if (cch.find("buttonClicked|upgrade-5188") != string::npos) {
									SendArtifactUpgrade(peer, 5186, 2, 5188, 5204, 3, 5072, 2);
								}
								// Orb
								else if (cch.find("buttonClicked|upgrade-7168") != string::npos) {
									SendArtifactUpgrade(peer, 7166, 1, 7168, 5106, 2, 7186, 1);
								}
								else if (cch.find("buttonClicked|upgrade-7170") != string::npos) {
									SendArtifactUpgrade(peer, 7168, 1, 7170, 5104, 1, 7186, 1);
								}
								else if (cch.find("buttonClicked|upgrade-7172") != string::npos) {
									SendArtifactUpgrade(peer, 7170, 2, 7172, 5204, 1, 7186, 1);
								}
								else if (cch.find("buttonClicked|upgrade-7174") != string::npos) {
									SendArtifactUpgrade(peer, 7172, 2, 7174, 5106, 2, 7186, 2);
								}
								else if (cch.find("buttonClicked|upgrade-9212") != string::npos) {
									SendArtifactUpgrade(peer, 7174, 2, 9212, 5104, 3, 7186, 2);
								}
								// Upgrading
								if (cch.find("buttonClicked|completecraft-" + to_string(pInfo(peer)->Upgradeto) + "") != string::npos) {
									int AlgorithmStone = 0, Crystalized = 0, Celestial = 0, Riddles = 0, HaveAnces = 0;
									modify_inventory(peer, 5202, AlgorithmStone);
									modify_inventory(peer, pInfo(peer)->IDCrystalized, Crystalized);
									modify_inventory(peer, pInfo(peer)->IDCeles, Celestial);
									modify_inventory(peer, pInfo(peer)->DailyRiddles, Riddles);
									modify_inventory(peer, pInfo(peer)->AncesID, HaveAnces);
									if (AlgorithmStone >= pInfo(peer)->HowmuchAlgorithmStone && Crystalized >= pInfo(peer)->JumlahCrystalized && Celestial >= pInfo(peer)->JumlahCeles && Riddles >= 5 && HaveAnces >= 1) {
										int del_a = -pInfo(peer)->HowmuchAlgorithmStone, del_b = -pInfo(peer)->JumlahCrystalized, del_c = -pInfo(peer)->JumlahCeles, del_d = -5, del_e = -1;
										modify_inventory(peer, 5202, del_a);
										modify_inventory(peer, pInfo(peer)->IDCrystalized, del_b);
										modify_inventory(peer, pInfo(peer)->IDCeles, del_c);
										modify_inventory(peer, pInfo(peer)->DailyRiddles, del_d);
										modify_inventory(peer, pInfo(peer)->AncesID, del_e);
										/*if (pInfo(peer)->Upgradeto == 7174 || pInfo(peer)->Upgradeto == 5186 || pInfo(peer)->Upgradeto == 5150 || pInfo(peer)->Upgradeto == 5168 || pInfo(peer)->Upgradeto == 5132) {
											SendSuccesAchievement(peer, "Ancestral Being", false, "Ancestral Being", 137, 1);
										}*/
										if (pInfo(peer)->ances == pInfo(peer)->AncesID) {
											pInfo(peer)->ances = 0;
											update_clothes(peer);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == pInfo(peer)->world) {
													packet_(currentPeer, "action|play_sfx\nfile|audio/change_clothes.wav\ndelayMS|0");
												}
											}
										}
										int c_ = 1;
										if (modify_inventory(peer, pInfo(peer)->Upgradeto, c_) == 0) {
											gamepacket_t p;
											p.Insert("OnDialogRequest");
											p.Insert("add_label_with_icon|big|`9Ancient Goddess``|left|5086|\nadd_spacer|small|\nadd_textbox|`8You've pleased me, clever one.``|left|\nadd_spacer|small|\nend_dialog|artifact_upgrade|Return|");
											p.CreatePacket(peer);
										}
										else {
											gamepacket_t p;
											p.Insert("OnDialogRequest");
											p.Insert("add_label_with_icon|big|`9Ancient Goddess``|left|5086|\nadd_spacer|small|\nadd_textbox|`8You didn't have enough inventory.``|left|\nadd_spacer|small|\nend_dialog|artifact_upgrade|Return|");
											p.CreatePacket(peer);
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|logoutdialog") != string::npos) {
								if (cch.find("buttonClicked|keloginpage") != string::npos) {
									gamepacket_t p(1000);
									p.Insert("OnDialogRequest");
									p.Insert("set_border_color|250,250,250,250\nset_bg_color|0,0,0,255\nset_default_color|`o\nadd_label_with_icon|big|`oGrowtopia Private Server|left|12436|\nadd_label|small|`wBefore you start playing on this GTPS you are required to login your account, but if you don't have one, you can press the '`6Register`w` button for account registration.|\nadd_spacer|small|\nadd_button|login_register|`9Register|left|\nadd_button|login|`9Login|left|\nend_dialog|login_authorizations|||");
									p.CreatePacket(peer);
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|confirm_buytoken") != string::npos) {
								if (cch.find("buttonClicked|buy_token1") != string::npos) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|\nadd_label|big|Confirmation Purchase!|left|\nadd_spacer|small|\nadd_button|confirm_token1|Purchase [ 1 TOKEN ][ 500 COIN ]|left|\nadd_button|confirm_token10|Purchase [ 10 TOKEN ][ 5000 COIN ]|left|\nend_dialog|confirm_buytoken||");
									p.CreatePacket(peer);
								}
								if (cch.find("buttonClicked|confirm_token10") != string::npos) {
									if (pInfo(peer)->coinss <= 0) continue;
									pInfo(peer)->coinss -= 5000;
									pInfo(peer)->Summer_Fate += 10;
									ENetPacket* msg = Variant{ "OnConsoleMessage" }.push("Succesfuly Buying 10 Token").pack();
									enet_peer_send(peer, 0, msg);
								}
								if (cch.find("buttonClicked|confirm_token1") != string::npos) {
									if (pInfo(peer)->coinss <= 0) continue;
									pInfo(peer)->coinss -= 500;
									pInfo(peer)->Summer_Fate += 1;
									ENetPacket* msg = Variant{ "OnConsoleMessage" }.push("Succesfuly Buying 1 Token").pack();
									enet_peer_send(peer, 0, msg);
								}
							}
							if (cch.find("action|dialog_return\ndialog_name|choose_pet") != string::npos) {
								if (cch.find("buttonClicked|chicken_pet") != string::npos) {
									if (pInfo(peer)->ChickenFlyTgt) {
										pInfo(peer)->pet_ID = 20094;
										pInfo(peer)->pet_type = 1;
										pInfo(peer)->show_pets = true;
										pInfo(peer)->pet_name = "`4@Pegasus";
										if (pInfo(peer)->pet_level == 10) {
											pInfo(peer)->ability_xgems = 2;
											pInfo(peer)->ability_xxp = 2;
										}
										if (pInfo(peer)->pet_level == 20) {
											pInfo(peer)->ability_xgems = 4;
											pInfo(peer)->ability_xxp = 4;
											pInfo(peer)->active_1hit = true;
										}
										if (pInfo(peer)->pet_level == 30) {
											pInfo(peer)->ability_xgems = 6;
											pInfo(peer)->ability_xxp = 6;
										}
										if (pInfo(peer)->pet_level == 40) {
											pInfo(peer)->ability_xgems = 8;
											pInfo(peer)->ability_xxp = 8;
										}
										if (pInfo(peer)->pet_level == 50) {
											pInfo(peer)->ability_xgems = 10;
											pInfo(peer)->ability_xxp = 10;
											pInfo(peer)->active_bluename = true;
										}
										Pet_Ai::Spawn(peer);
										save_player(pInfo(peer), false);
									}
									break;
								}
								if (cch.find("buttonClicked|galaxy_pet") != string::npos) {
									if (pInfo(peer)->GalaxyFly) {
										pInfo(peer)->pet_ID = 20096;
										pInfo(peer)->show_pets = true;
										pInfo(peer)->pet_type = 1;
										pInfo(peer)->pet_name = "`b@" + pInfo(peer)->tankIDName + "_Pet";
										if (pInfo(peer)->pet_level == 50) {
											pInfo(peer)->active_bluename = true;
										}
										Pet_Ai::Spawn(peer);
										save_player(pInfo(peer), false);
									}
								}
								if (cch.find("buttonClicked|anya_forger") != string::npos) {
									if (pInfo(peer)->GalaxyFly) {
										pInfo(peer)->pet_ID = 9960;
										pInfo(peer)->show_pets = true;
										pInfo(peer)->pet_type = 1;
										pInfo(peer)->pet_name = "`5@Anya Forger";
										pInfo(peer)->active_bluename = true;
										pInfo(peer)->ability_xgems = 3;
										pInfo(peer)->ability_xxp = 3;
										Pet_Ai::Spawn(peer);
										save_player(pInfo(peer), false);
									}
								}
								if (cch.find("buttonClicked|cat_moon") != string::npos) {
									if (pInfo(peer)->CatMoon) {
										pInfo(peer)->pet_ID = 9514;
										pInfo(peer)->show_pets = true;
										pInfo(peer)->pet_type = 1;
										pInfo(peer)->pet_name = "`o@Golden's Cat Moon";
										pInfo(peer)->active_bluename = true;
										pInfo(peer)->ability_xgems = 5;
										pInfo(peer)->ability_xxp = 5;
										Pet_Ai::Spawn(peer);
										save_player(pInfo(peer), false);
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|gachaend\nbuttonClicked|Gacha") != string::npos) {
								if (pInfo(peer)->gems >= 500000) {
									vector<int> common_prize = { 11118, 1796, 10020, 9386, 7188, 5480, 7960, 9726, 10400, 10384, 9350, 9488,  10716 }, rare_prize = { 242, 1796, 10716, 2, 340, 9928, 542, 9906 };
									int reward = 0, got = 0;
									{
										reward = (rand() % 101 == 1 ? rare_prize[rand() % rare_prize.size()] : common_prize[rand() % common_prize.size()]);
									}
									if (modify_inventory(peer, reward, got += 1) == 0) {
										pInfo(peer)->gems -= 1500000;
										gamepacket_t p; p.Insert("OnSetBux"); p.Insert(pInfo(peer)->gems); p.Insert(0); p.CreatePacket(peer);
										ENetPacket* msg = Variant{ "OnAddNotification" }.push("interface/large/special_event.rttex").push("You receive " + items[reward].name + " from Gacha").push("audio/achievement.wav").pack();
										enet_peer_send(peer, 0, msg);
									}
									else sendmessage(peer, "console", "You don't have enough gems");
								}
							}
							if (cch.find("action|dialog_return\ndialog_name|gacha_system") != string::npos) {
								if (cch.find("buttonClicked|opengachabanner") != string::npos) {
									gacha_benner(peer);
								}
								if (cch.find("buttonClicked|opengachabanner1") != string::npos) {
									gacha_benner(peer);
								}
								if (cch.find("buttonClicked|Gacha_Shop") != string::npos) {
									Algorithm::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|Gacha Shop!|left|\nadd_button|buy_token1|`wBuy Gacha Token [ Click To Buy ]|left|\nadd_quick_exit|\nend_dialog|confirm_buytoken|Close|");
								}
								if (cch.find("buttonClicked|Gacha_Detail") != string::npos) {
									Algorithm::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|`wEvent Wish - Gacha Magplant|left|\nadd_spacer|small|\nadd_textbox|`5 - the percentage of acquisition increases - |left|\nadd_spacer|small|\nadd_textbox|`oProbability of getting a 5 Stars percentage: 50,000%|left|\nadd_spacer|small|\nadd_label_with_icon|small|`2Mythical Infinity Rayman's Fist|left|9908|\nadd_spacer|small|\nadd_textbox|`oProbability of getting a 4 Stars percentage: 50,000%|left|\nadd_spacer|small|\nadd_label_with_icon|small|`2Legendary Rayman Fist|left|9906|\nadd_label_with_icon|small|`2Rayman's Fist|left|5480|\nadd_spacer|small|\nadd_label|small|`5 - Detailed Explanation - |left|\nadd_spacer|small|\nadd_smalltext|`o   -  The Wish Event - Galaxy Magplant has begin. During the wish event, the percentage of obtaining 5-star items `8Exclusive `5\"Galaxy Magplant\"`o, 4-star items `5\"Legendary Rayman\" `oand `5\"Rayman Fist\" `o increases drastically!|left|\nadd_smalltext|`o   -  This Application Event is available for a limited time. All items in the event may return in the future. The above exclusive characters will not be included in the Standard \"Wanderlust Invocation\".|left|\nadd_smalltext|`o   -  Under normal circumstances, requests for goods are calculated based on a basic percentage. For requests with increased acquisition percentages, acquisition guarantees, etc., they will be calculated based on applicable provisions.|left|\nadd_spacer|small|\nadd_label|small|`5 - Stipulations - |left|\nadd_spacer|small|\nadd_smalltext|`o - [Item 5 Stars] - |left|\nadd_smalltext|`o - For Wish Event - Mythical Rayman's, base percentage to get Items 5: 0.600%; overall percentage (including collateral): 1,600%. Guaranteed to get Items 5 at least once every 90 Applications. When you get Items 5 from the Request, there is a 50,000% chance that Items is the UP Items 5 in this event: \"Mythical Rayman's\". If the first 5 Stars Items you get from this event is not an UP Items, the next 5 Stars Items you get is guaranteed to be an UP Character.|left|\nadd_spacer|small|\nadd_smalltext|`o - [Item 4 Stars] - |left|\nadd_smalltext|`o - For Wish Event - Mythical Rayman's, base percentage for getting Item 4 Stars: 5.100%; base percentage to get Item 4 Stars: 2.550%, overall percentage to get a 4 Stars item (including guarantee) : 13,000%. Guaranteed to get a 4 Stars item or above at least once every 10 times you apply; the percentage of obtaining 4 Stars items from the guarantee is 99.400%, percentage item gain 5 Stars of the guarantee is 0.600%. When you get a 4 Stars item from the Wish, there is a 50,000% chance that it will be the 4 Stars UP Item in this event: \"Legendary Rayman\" L.Ray and \"Rayman Fist's\" O.Ray. If the first 4 Stars item you get from this event is not an UP Item, then the next 4 Stars item you get is guaranteed to be a 4 Stars UP Item from this period. When you get a 4 Stars UP item from a Request, the percentage of obtaining each 4 Stars UP Item in this request event is the same flat.|left|\nadd_spacer|small|\nadd_label|small|`5 - List Items - |left|\nadd_spacer|small|\nadd_smalltext|`o- \"5 Stars Item acquistion base percentage: 0,600% (including guarantee: 1,600%)\" -|left|\nadd_spacer|small|\nadd_custom_textbox|     `2- Mythical Infinity Rayman's Fist|size:tiny;|\nadd_spacer|small|\nadd_smalltext|`o(NOTE: When an increase in the probability of earning or a guarantee condition has not been triggered, all items will have the same base percentage)|left|\nadd_spacer|small|\nadd_smalltext|`o- \"4 Stars Item acquistion base percentage: 5,100% (including guarantee: 13,000%)\" -|left|\nadd_spacer|small|\nadd_custom_textbox|     `2- Rayman's Fist|size:tiny;|\nadd_custom_textbox|     `2- Legendary Rayman Fist|size:tiny;|\nadd_custom_textbox|     `2- Rainbow Hair|size:tiny;|\nadd_custom_textbox|     `2- Intergalactic Warrior Hair|size:tiny;|\nadd_custom_textbox|     `2- Azraq Hair|size:tiny;|\nadd_custom_textbox|     `2- Black Intergalactic Hair|size:tiny;|\nadd_custom_textbox|     `2- Golden Aura|size:tiny;|\nadd_custom_textbox|     `2- Prismatic Aura|size:tiny;|\nadd_custom_textbox|     `2- Money Aura|size:tiny;|\nadd_custom_textbox|     `2- Snowflake Wings of Winter|size:tiny;|\nadd_custom_textbox|     `2- Shamrock Wings|size:tiny;|\nadd_custom_textbox|     `2- Burning Hands|size:tiny;|\nadd_custom_textbox|     `2- Crystal Cape|size:tiny;|\nadd_custom_textbox|     `2- Cosmic Cape|size:tiny;|\nadd_custom_textbox|     `2- Rainbow Cape|size:tiny;|\nadd_custom_textbox|     `2- Golden Sunset Cape|size:tiny;|\nadd_custom_textbox|     `2- Glowy Cape|size:tiny;|\nadd_custom_textbox|     `2- Neon Party Cape|size:tiny;|\nadd_custom_textbox|     `2- The Traveler's Cape|size:tiny;|\nadd_custom_textbox|     `2- Aquatic Volcanic Cape|size:tiny;|\nadd_spacer|small|\nadd_smalltext|`o(NOTE: When an increase in the probability of earning or a guarantee condition has not been triggered, all items will have the same base percentage)|left|\nadd_spacer|small|\nadd_smalltext|`o- \"3 Stars Item acquistion base percentage: 94,300% (including guarantee: 85,400%)\" -|left|\nadd_spacer|small|\nadd_custom_textbox|     `2- Ripper Wings|size:tiny;|\nadd_custom_textbox|     `2-Blazing Electro Wings |size:tiny;|\nadd_custom_textbox|     `2- Angel Wings|size:tiny;|\nadd_custom_textbox|     `2- Rainbow Wings|size:tiny;|\nadd_custom_textbox|     `2- Parrot Wings|size:tiny;|\nadd_custom_textbox|     `2- Crimson Wings|size:tiny;|\nadd_custom_textbox|     `2- Fairy Wings|size:tiny;|\nadd_custom_textbox|     `2- Brown Pet Apatoceratops|size:tiny;|\nadd_custom_textbox|     `2- Green Pet Apatoceratops|size:tiny;|\nadd_custom_textbox|     `2- Red Pet Apatoceratops|size:tiny;|\nadd_custom_textbox|     `2- Black Tie Baller Shoes|size:tiny;|\nadd_custom_textbox|     `2- Bouncer Shoes|size:tiny;|\nadd_custom_textbox|     `2- The Diviner's Shoes|size:tiny;|\nadd_custom_textbox|     `2- Butcher Knife|size:tiny;|\nadd_custom_textbox|     `2- Super Cape - Black|size:tiny;|\nadd_custom_textbox|     `2- Super Cape - Purple|size:tiny;|\nadd_custom_textbox|     `2- Super Cape - Green|size:tiny;|\nadd_custom_textbox|     `2- Super Cape - Blue|size:tiny;|\nadd_custom_textbox|     `2- Super Cape - Red|size:tiny;|\nadd_custom_textbox|     `2- Cape of Shadow|size:tiny;|\nadd_custom_textbox|     `2- Pligrim's Shoes|size:tiny;|\nadd_custom_textbox|     `2- Black Shoes|size:tiny;|\nadd_custom_textbox|     `2- Clown Shoes|size:tiny;|\nadd_custom_textbox|     `2- Leprechaun Shoes|size:tiny;|\nadd_custom_textbox|     `2- Patent Leather Shoes|size:tiny;|\nadd_custom_textbox|     `2- Brown Shoes|size:tiny;|\nadd_custom_textbox|     `2- Golden Razor Wings|size:tiny;|\nadd_custom_textbox|     `2- Heart Necklace|size:tiny;|\nadd_custom_textbox|     `2- Melody Necklace|size:tiny;|\nadd_custom_textbox|     `2- Orange Geiger V-Neck|size:tiny;|\nadd_custom_textbox|     `2- Purple Geiger V-Neck|size:tiny;|\nadd_custom_textbox|     `2- Blue Geiger V-Neck|size:tiny;|\nadd_custom_textbox|     `2- Green Geiger V-Neck|size:tiny;|\nadd_spacer|small|\nadd_smalltext|`o(NOTE: When an increase in the probability of earning or a guarantee condition has not been triggered, all items will have the same base percentage)|left|\nadd_spacer|small|\nadd_button|BackToDialog|Back|noflags|0|0|\nend_dialog|gacha_system|||\nadd_quick_exit|");
								}
								if (cch.find("buttonClicked|Gacha_History") != string::npos) {
									string list = "";
									for (int i = 0; i < pInfo(peer)->Gacha_History.size(); i++) list += "\nadd_textbox|`w" + to_string(i) + ". " + pInfo(peer)->Gacha_History[i] + "|left|\n";
									if (list.empty()) list = "\nadd_textbox|`oThere is no History whatsoever here.|left|";
									Algorithm::OnDialogRequest(peer, "set_default_color|\nadd_label|big|Gacha History|left|\nadd_smalltext|`oYou can see the Gacha history here, the Gacha history is updated after you make the Gacha, if you don't see it here, please check back in a few moments.|left|\nadd_spacer|small|" + list + "|\nadd_spacer|small|\nadd_button|BackToDialog|`wBack|noflags|0|0|\nend_dialog|gacha_system|||");
								}
								if (cch.find("buttonClicked|gacha_1x") != string::npos) {
									if (pInfo(peer)->Summer_Fate < 1) {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You Dont Have An Enough Fate");
										p.Insert("audio/slot_lose.wav");
										p.CreatePacket(peer);
										break;
									}
									int itemCount = 1;
									int singleResult = Gacha::Event::Single(peer);
									Algorithm::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|`wCongratulations!!|left|\nadd_spacer|small|\nadd_button_with_icon|||" + a + (Gacha::Event::Legendary_Item(singleResult) ? "staticYellowFrame" : Gacha::Event::Rare_Item(singleResult) ? "staticPurpleFrame" : "staticGreyFrame") + "|" + to_string(singleResult) + "|\nadd_button_with_icon||END_LIST|noflags|0|\nend_quick_exit|\nadd_spacer|small|\nadd_button|opengachabanner|`wBack|noflags|0|0|\nend_dialog|gacha_system|||");
									if (modify_inventory(peer, singleResult, itemCount) == 0) {
									}
									pInfo(peer)->Summer_Fate -= 1;
									time_t currentTime; struct tm* localTime; char buffer[80];
									time(&currentTime); localTime = localtime(&currentTime);
									int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
									pInfo(peer)->Gacha_History.push_back("" + items[singleResult].name + " `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "");
								}
								if (cch.find("buttonClicked|gacha_10x") != string::npos) {
									if (pInfo(peer)->Summer_Fate < 10) {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You Dont Have An Enough Fate");
										p.CreatePacket(peer);										break;
									}
									int itemCount = 1; string list = "";
									std::vector<int> multiResults = Gacha::Event::Multi(peer);
									for (auto result : multiResults) {
										if (modify_inventory(peer, result, itemCount) == 0) {
											itemCount = 1;
										}
										time_t currentTime; struct tm* localTime; char buffer[80];
										time(&currentTime); localTime = localtime(&currentTime);
										int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
										pInfo(peer)->Gacha_History.push_back("" + items[result].name + " `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "");
										list += "\nadd_button_with_icon|||" + a + (Gacha::Event::Legendary_Item(result) ? "staticYellowFrame" : Gacha::Event::Rare_Item(result) ? "staticPurpleFrame" : "staticGreyFrame") + ",no_padding_x,|" + to_string(result) + "|";
									}
									pInfo(peer)->Summer_Fate -= 10;
									Algorithm::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|`wCongratulations!!|left|\nadd_spacer|small|" + list + "\nadd_button_with_icon||END_LIST|noflags|0|\nadd_quick_exit|\nadd_spacer|small|\nadd_button|opengachabanner|`wBack|noflags|0|0|\nend_dialog|gacha_system|||");
								}
							}
							/*else if (cch.find("action|dialog_return\ndialog_name|0999828383728283838383737337SS") != string::npos) {
								if (cch.find("buttonClicked|bgls_depo") != string::npos) {
									int bgls = 0, c_ = 0;
									modify_inventory(peer, 7188, c_);
									if (c_ == 0) break;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDeposit Blue Gem Locks````|left|7188|\nadd_label|small|Deposit how many? (you have " + to_string(c_) + ")|left|\nadd_text_input|bgl_count|`wAmount:``|" + to_string(c_) + "|3|\nadd_spacer|small|\nadd_button|deposit_bgl|Deposit|noflags|0|0|\nend_dialog|0999828383728283838383737337SS|Nevermind.||");
									p.CreatePacket(peer);
									break;
								}
								else if (cch.find("buttonClicked|deposit_bgl") != string::npos) {
									try {
										int count = atoi(explode("\n", explode("bgl_count|", cch)[1])[0].c_str());
										int got = 0, receive = 0;
										modify_inventory(peer, 7188, got);
										if (count <= 0 || count > got) {
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
										}
										else if (got == 0) {
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
										}
										else {
											receive = count * -1;
											string name_ = pInfo(peer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												gamepacket_t p1, p2;
												p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("`3You Deposit `w" + to_string(count) + "`e Golden Gem Lock's`w in The bank!"), p1.CreatePacket(peer);
												p2.Insert("OnConsoleMessage"), p2.Insert("`3You Deposit `w" + to_string(count) + "`e Golden Gem Lock's`w in The bank!"), p2.CreatePacket(peer);
												packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
												modify_inventory(peer, 7188, receive);
												pInfo(peer)->bank_p += count;
											}
										}
									}
									catch (...) {
										break;
									}
								}
								else if (cch.find("buttonClicked|bgls_takes") != string::npos) {
									int bgls = pInfo(peer)->bank_p;
									if (bgls == 0 || bgls <= 0) break;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWithdraw Blue Gem Locks````|left|7188|\nadd_label|small|Withdraw how many? (you have `3" + setGems(bgls) + "``) in the bank!|left|\nadd_text_input|bgl_withdraw|`wAmount:``|0|3|\nadd_spacer|small|\nadd_button|7188w_bgl|`^Withdraw``|noflags|0|0|\nend_dialog|0999828383728283838383737337SS|Nevermind.||");
									p.CreatePacket(peer);
									break;
								}
								else if (cch.find("buttonClicked|7188w_bgl") != string::npos) {
									try {
										int maubrp = atoi(explode("\n", explode("bgl_withdraw|", cch)[1])[0].c_str());
										//int maubrp = 0;
										int bank = 0;
										bank = pInfo(peer)->bank_p;
										int fler = 0;
										modify_inventory(peer, 7188, fler);
										if (bank < maubrp) {
											gamepacket_t a;
											a.Insert("OnConsoleMessage"), a.Insert("Your BGL in bank doesnt enough");
											a.CreatePacket(peer);
											break;
										}
										if (maubrp > 200) break;
										if (to_string(maubrp).find_first_not_of("1234567890") != string::npos) break;
										int oky = 0;
										modify_inventory(peer, 7188, oky += maubrp);
										pInfo(peer)->bank_p -= maubrp;
										gamepacket_t a;
										a.Insert("OnConsoleMessage"), a.Insert("You withdraw " + to_string(maubrp) + " From");
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");

										break;
									}
									catch (...) {
										break;
									}
								}
								break;
							}*/
							else if (cch.find("action|dialog_return\ndialog_name|bank_tut\n") != string::npos) {
								int berapa = atoi(explode("\n", explode("bank|", cch)[1])[0].c_str());

								Algorithm::send_overlay(peer, "`oSuccessfully created bank ID");
								pInfo(peer)->bank_id = berapa;
								pInfo(peer)->udah8 = 1;
						}
							else if (cch.find("action|dialog_return\ndialog_name|bank_begal\n") != string::npos) {
								if (cch.find("buttonClicked|depo_bgl") != string::npos) {
									int d = 0;
									modify_inventory(peer, 7188, d);
									if (d == 0);
									DialogBuilder o("`o");
									o.add_label_icon(true, 7188, "`oDeposit Blue Gem Lock");
									o.add_smalltext("`oYou have " + to_string(d) + " Blue Gem Lock");
									o.add_spacer(false);
									o.add_text_input(3, "kerukim_p", "Deposit : ", "");
									o.add_spacer(false);
									o.add_quick_exit().end_dialog("kerukim_woi", "Nevermind", "Continue");
									enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(o.to_string()).pack());
								}
								if (cch.find("buttonClicked|regis_") != string::npos) {
									DialogBuilder p("`o");
									p.add_label_icon(true, 7188, "`oCreate Bank Id");
									p.add_spacer(false);
									p.add_textbox("`oIf you create a bank id you can get easly transfer to other people");
									p.add_spacer(false);
									p.add_text_input(5, "bank", "Bank Id:", "");
									p.add_spacer(false);
									p.add_quick_exit().end_dialog("bank_tut", "Nevermind!", "Continue");
									enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(p.to_string()).pack());
								}
								}
								if (cch.find("buttonClicked|with_bgl") != string::npos) {
									int d = pInfo(peer)->bank_p;

									if (d == 0);
									DialogBuilder o("`o");
									o.add_label_icon(true, 7188, "`oWithdraw Blue Gem Lock");
									o.add_smalltext("`oYou have " + to_string(d) + " Love Gem Lock");
									o.add_spacer(false);
									o.add_text_input(3, "bgl_ps", "Deposit : ", "");
									o.add_spacer(false);
									o.add_quick_exit().end_dialog("deposit2_woi", "Nevermind", "Continue");
									enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(o.to_string()).pack());
								}
								else if (cch.find("action|dialog_return\ndialog_name|deposit2_woi\n") != string::npos) {
									int berapa = atoi(explode("\n", explode("bgl_ps|", cch)[1])[0].c_str());
									int d_;
									int bgl = 0;
									d_ = pInfo(peer)->bank_p;
									modify_inventory(peer, 7188, bgl);
									if (berapa < 0) {
										Algorithm::send_overlay(peer, "Jumlah yang dimasukkan tidak valid");
									}
									else if (d_ < berapa) {
										Algorithm::send_overlay(peer, "Woi, Kamu ga punya sebanyak itu ");
									}
									else {
										int c_ = berapa;
										Algorithm::send_overlay(peer, "Successfully withdrawn your BGL");
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										pInfo(peer)->bank_history.push_back("`9You Withdraw `o" + setGems(berapa) + " `eBlue Gem Lock.");
										modify_inventory(peer, 7188, c_);
										pInfo(peer)->bank_p -= berapa;
									}
								}
								else if (cch.find("action|dialog_return\ndialog_name|kerukim_woi\n") != string::npos) {
									int berapa = atoi(explode("\n", explode("kerukim_p|", cch)[1])[0].c_str());
									int d_ = 0;
									modify_inventory(peer, 7188, d_);
									if (berapa < 0) {
										Algorithm::send_overlay(peer, "Jumlah yang dimasukkan tidak valid");
									}
									else if (d_ < berapa) {
										gamepacket_t p;
										p.Insert("OnTextOverlay"), p.Insert("`oWoi, kamu ga punya sebanyak itu"), p.CreatePacket(peer);
									}
									else {
										int c_ = berapa * -1;
										Algorithm::send_overlay(peer, "Successfully deposit your BGL");
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										pInfo(peer)->bank_history.push_back("`9You Deposit `o" + setGems(berapa) + " `eBlue Gem Lock.");
										modify_inventory(peer, 7188, c_);
										pInfo(peer)->bank_p += berapa;
										pInfo(peer)->udah7 = 1;
									}
								}
							else if (cch.find("action|dialog_return\ndialog_name|coin_fish") != string::npos) {
								if (cch.find("buttonClicked|sell_epic") != string::npos) {
									int kntl = 0; modify_inventory(peer, 9508, kntl);
									if (kntl < 1) { gamepacket_t p; p.Insert("OnTextOverlay"); p.Insert("`9You don't have enough `#Epic Coin!"); p.CreatePacket(peer); break; }
									int add = 0;
									if (modify_inventory(peer, 1796, add += 1) == 0) {
										int kurg = 0;
										modify_inventory(peer, 9508, kurg -= 1);
										gamepacket_t p1; p1.Insert("OnTextOverlay"); p1.Insert("`9Succesfuly Selling 1 `#Epic Coin");
										p1.CreatePacket(peer);
									}
									else {
										gamepacket_t p2; p2.Insert("OnTextOverlay"); p2.Insert("`9No Inventory Space"); p2.CreatePacket(peer);
									}
								}
								if (cch.find("buttonClicked|sell_mythic") != string::npos) {
									int kntl = 0; modify_inventory(peer, 9506, kntl);
									if (kntl < 1) { gamepacket_t p; p.Insert("OnTextOverlay"); p.Insert("`9You don't have enough `bMythical Coin!"); p.CreatePacket(peer); break; }
									int add = 0;
									if (modify_inventory(peer, 1796, add += 5) == 0) {
										int kurg = 0;
										modify_inventory(peer, 9506, kurg -= 1);
										gamepacket_t p1; p1.Insert("OnTextOverlay"); p1.Insert("`9Succesfuly Selling 1 `bMythical Coin");
										p1.CreatePacket(peer);
									}
									else {
										gamepacket_t p2; p2.Insert("OnTextOverlay"); p2.Insert("`9No Inventory Space"); p2.CreatePacket(peer);
									}
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|pet_spawn") != string::npos) {
								if (cch.find("buttonClicked|show_pet") != string::npos) {
									if (not pInfo(peer)->ChickenFlyTgt and not pInfo(peer)->GalaxyFly) {
										Algorithm::send_console(peer, "`oYou don't have pets! Buy Pets from Lock-Bot");
									}
									else {
										if (pInfo(peer)->show_pets) {
											pInfo(peer)->pet_ID = 0;
											pInfo(peer)->show_pets = false;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(peer)->world == pInfo(currentPeer)->world) {
													vz::OnRemove(currentPeer, pInfo(peer)->pet_netID, 0);
												}
											}
										}
										else {
											Algorithm::OnDialogRequest(peer, "set_default_color|\nadd_label|big|`$Pet Ai You Have|left|\nadd_spacer|small|\nadd_textbox|`$Choose your Pet's:|left|\nadd_custom_margin|x:10;y:0|\ntext_scaling_string|Subscribtions++++++++|" + a + (pInfo(peer)->ChickenFlyTgt ? "\nadd_button_with_icon|chicken_pet|Chicken Fly|staticYellowFrame|10294||" : "") + (pInfo(peer)->GalaxyFly ? "\nadd_button_with_icon|galaxy_pet|Galaxy Fly|staticYellowFrame|20096||" : "") + (pInfo(peer)->AnyaForger ? "\nadd_button_with_icon|anya_forger|Anya Forger|staticYellowFrame|9960||" : "") + (pInfo(peer)->AnyaForger ? "\nadd_button_with_icon|cat_moon|Golden's Cat Moon|staticYellowFrame|9514||" : "") + "\nreset_placement_x|\nadd_button_with_icon||END_LIST|noflags|0||\nend_dialog|choose_pet|Close||");
										}
										save_player(pInfo(peer), false);
									}
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|farmable_shop") != string::npos) {
								if (cch.find("buttonClicked|buy_lpot") != string::npos) {
									Algorithm::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wConfirmation Purchase!|left|340|\nadd_spacer|small|\nadd_smalltext|`wPrice:|left|\nadd_spacer|small|\nadd_label_with_icon|small|`w200 `9LPOT `w/ `w10 `9WL|left|482|\nadd_button|confirm_lpot|Purchase|\nend_dialog|farmable_shop|Nevermind|");
								}
								if (cch.find("buttonClicked|buy_pot") != string::npos) {
									Algorithm::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wConfirmation Purchase!|left|542|\nadd_spacer|small|\nadd_smalltext|`wPrice:|left|\nadd_spacer|small|\nadd_label_with_icon|small|`w200 `9POT `w/ `w5 `9WL|left|482|\nadd_button|confirm_pot|Purchase|\nend_dialog|farmable_shop|Nevermind|");
								}
								if (cch.find("buttonClicked|confirm_lpot") != string::npos) {
									int kntl = 0; modify_inventory(peer, 242, kntl);
									if (kntl < 10) { gamepacket_t p; p.Insert("OnTextOverlay"); p.Insert("`9You don't have enough Lock"); p.CreatePacket(peer); break; }
									int add = 0;
									if (modify_inventory(peer, 9928, add += 200) == 0) {
										int kurg = 0;
										modify_inventory(peer, 242, kurg -= 10);
										gamepacket_t p1; p1.Insert("OnTextOverlay"); p1.Insert("`9Succesfuly Buying The Items!");
										p1.CreatePacket(peer);
									}
									else {
										gamepacket_t p2; p2.Insert("OnTextOverlay"); p2.Insert("`9No Inventory Space"); p2.CreatePacket(peer);
									}
								}
								if (cch.find("buttonClicked|confirm_pot") != string::npos) {
									int kntl1 = 0; modify_inventory(peer, 242, kntl1);
									if (kntl1 < 5) { gamepacket_t p; p.Insert("OnTextOverlay"); p.Insert("`9You don't have enough Lock"); p.CreatePacket(peer); break; }
									int add1 = 0;
									if (modify_inventory(peer, 542, add1 += 200) == 0) {
										int kurg1 = 0;
										modify_inventory(peer, 242, kurg1 -= 5);
										gamepacket_t p1; p1.Insert("OnTextOverlay"); p1.Insert("`9Succesfuly Buying The Items!");
										p1.CreatePacket(peer);
									}
									else {
										gamepacket_t p2; p2.Insert("OnTextOverlay"); p2.Insert("`9No Inventory Space"); p2.CreatePacket(peer);
									}
								}
								}
							else if (cch.find("action|dialog_return\ndialog_name|chest_store") != string::npos) {
								if (cch.find("buttonClicked|buy_dgc") != string::npos) {
									Algorithm::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wConfirmation Purchase!|left|9512|\nadd_spacer|small|\nadd_smalltext|`wPrice:|left|\nadd_spacer|small|\nadd_label_with_icon|small|`w1 `cDGC`w/ `w50 `9WL|left|482|\nadd_button|confirm_dgc|Purchase|\nend_dialog|chest_store|Nevermind|");
								}
								if (cch.find("buttonClicked|buy_rgc") != string::npos) {
									Algorithm::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wConfirmation Purchase!|left|9898|\nadd_spacer|small|\nadd_smalltext|`wPrice:|left|\nadd_spacer|small|\nadd_label_with_icon|small|`w1 `4RGC `w/ `w25 `9WL|left|482|\nadd_button|confirm_rgc|Purchase|\nend_dialog|chest_store|Nevermind|");
								}
								if (cch.find("buttonClicked|confirm_dgc") != string::npos) {
									int kntl = 0; modify_inventory(peer, 242, kntl);
									if (kntl < 50) { gamepacket_t p; p.Insert("OnTextOverlay"); p.Insert("`9You don't have enough Lock"); p.CreatePacket(peer); break; }
									int add = 0;
									if (modify_inventory(peer, 9512, add += 1) == 0) {
										int kurg = 0;
										modify_inventory(peer, 242, kurg -= 50);
										gamepacket_t p1; p1.Insert("OnTextOverlay"); p1.Insert("`9Succesfuly Buying The Items!");
										p1.CreatePacket(peer);
									}
									else {
										gamepacket_t p2; p2.Insert("OnTextOverlay"); p2.Insert("`9No Inventory Space"); p2.CreatePacket(peer);
									}
								}
								if (cch.find("buttonClicked|confirm_rgc") != string::npos) {
									int kntl1 = 0; modify_inventory(peer, 242, kntl1);
									if (kntl1 < 25) { gamepacket_t p; p.Insert("OnTextOverlay"); p.Insert("`9You don't have enough Lock"); p.CreatePacket(peer); break; }
									int add1 = 0;
									if (modify_inventory(peer, 9898, add1 += 1) == 0) {
										int kurg1 = 0;
										modify_inventory(peer, 242, kurg1 -= 25);
										gamepacket_t p1; p1.Insert("OnTextOverlay"); p1.Insert("`9Succesfuly Buying The Items!");
										p1.CreatePacket(peer);
									}
									else {
										gamepacket_t p2; p2.Insert("OnTextOverlay"); p2.Insert("`9No Inventory Space"); p2.CreatePacket(peer);
									}
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|handphone") != string::npos) {
								if (cch.find("buttonClicked|spotify_menu") != string::npos) {
									spotify_menu(peer);
								}
								if (cch.find("buttonClicked|ktp_") != string::npos) {
									ktp_confirm(peer);
								}
								if (cch.find("buttonClicked|rolecoin") != string::npos) {
									rolecoin(peer);
								}
								if (cch.find("buttonClicked|ktp") != string::npos) {
									ktp_(peer);
								}
								if (cch.find("buttonClicked|punch_event") != string::npos) {
									punch_event(peer);
								}
								if (cch.find("buttonClicked|send_GemsDialog") != string::npos) {
									send_GemsDialog(peer);
								}
								if (cch.find("buttonClicked|items_price") != string::npos) {
									items_price(peer);
								}
								if (cch.find("buttonClicked|c_daily") != string::npos) {
									c_daily(peer, true, "tab_1", 0);
								}
								if (cch.find("buttonClicked|role_price") != string::npos) {
									role_price(peer);
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|login_authorizations") != std::string::npos) {
								if (cch.find("buttonClicked|login_register") != std::string::npos) {
									gamepacket_t p;
									p.Insert("OnDialogRequest"), p.Insert(r_dialog("")), p.CreatePacket(peer);
								}
								else if (cch.find("buttonClicked|login") != std::string::npos) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_border_color|250,250,250,250\nset_bg_color|0,0,0,255\nset_default_color|`o\n"
										"add_label_with_icon|big|`oGrowtopia Login Accounts|7188|\n"
										"add_textbox|`o If you already have a GrowID you are welcome to fill in GrowID data and Password.|left|\n"
										"add_spacer|small|\n"
										"embed_data|data|login|\n"
										"add_text_input|name_|GrowID||18|\n"
										"add_text_input_password|password_|Password||18|\n"
										"add_spacer|small|\n"
										"add_quick_exit|\nend_dialog|login_data||`wApply Connects\n");
									p.CreatePacket(peer);
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|login_data") != std::string::npos) {
								string name = explode("\n", explode("name_|", cch)[1])[0];
								string pass = explode("\n", explode("password_|", cch)[1])[0];
								gamepacket_t pc;
								pc.Insert("OnConsoleMessage");
								bool success = false;
								string pass_, user_;
								string path_ = "database/players/" + name + "_.json";
								ifstream acc(path_);
								if (acc.is_open()) {
									json j;
									acc >> j;
									user_ = j["name"].get<string>();
									pass_ = j["pass"].get<string>();
									acc.close();
								}
								string log_pass2 = explode("\n", pass).at(0);
								if (log_pass2 == pass_ and name == user_) success = true;
								if (success) {
									//save_player(pInfo(peer), true);
									gamepacket_t p;
									pc.Insert("`oLogin to " + server_name + " successful please wait....``");
									p.Insert("SetHasGrowID"), p.Insert(1), p.Insert(user_), p.Insert(pass_), p.CreatePacket(peer);
									pc.CreatePacket(peer);

									/*gamepacket_t p1;
									p1.Insert("OnSendToServer");
									p1.Insert(17091);
									p1.Insert("GrowNevo");
									p1.Insert(peer->connectID);
									p1.Insert(server_ip + "|0|-1");
									p1.Insert(1);
									p1.Insert(name);
									p1.CreatePacket(peer);*/
									enet_peer_disconnect_later(peer, 0);
								}
								else pc.Insert("`4Login failed. `oplease double check you filled data.");
								pc.CreatePacket(peer);
							}

							else if (cch.find("action|dialog_return\ndialog_name|set_server900") != string::npos) {
								if (pInfo(peer)->tankIDName != clist1) break;
								if (cch.find("buttonClicked|setname900") != string::npos) {
									string name = server_name;
									DialogBuilder o;
									o.add_label_icon(true, 32, "Set Server name")
										.add_spacer(false)
										.add_text_input(120, "name_server", "New Name");
									o.end_dialog("confirm_setname900", "Close", "Apply"), o.add_quick_exit();
									Algorithm::send_dialog(peer, o.to_string());
								}
}
if (cch.find("buttonClicked|ehjawadiemajalu") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label|big|Giveaway|left|\nadd_spacer|small|\nadd_textbox|Hello Owner Im The Robot Giveaway My work Is Send Prize Giveaway To All Player To Change Prize Giveaway You Can Edit In giveaway.json Are you Sure To Giveaway? If You Want To Giveaway Click Button `2Giveaway|left|\nend_dialog|giveawaystart|Nevermind|Giveaway||");
	p.CreatePacket(peer);
}
if (cch.find("buttonClicked|setflt900") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	rekomendedworldadd(peer);
}
if (cch.find("buttonClicked|setclt900") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|Set Creator Name|left|12436|\nadd_spacer|small|\nadd_textbox|Creator 1: " + clist1 + "|left|\nadd_textbox|Creator 4: " + clist4 + "|left|\nadd_textbox|Creator 5: " + clist5 + "|left|\nadd_textbox|Creator 6: " + clist6 + "|left|\nadd_textbox|Creator 6: " + clist6 + "|left|\nadd_textbox|Creator 7: " + clist7 + "|left|\nadd_textbox|Creator 8: " + clist8 + "|left|\nadd_textbox|Creator 9: " + clist9 + "|left|\nadd_textbox|Creator 10: " + clist10 + "|left|\nadd_textbox|Creator 11:" + clist11 + "|left|\nadd_textbox|Creator 12:" + clist12 + "|left|\nadd_smalltext|Creators Number are 1, 4, 5, 6, 7, 8, 9, 10, 11, 12. if you put another number than that it will failed or invalid|left|\nadd_text_input|berapa|Creator:||3|\nadd_spacer|small|\nadd_smalltext|This one is for the creator name|left|\nadd_text_input|namanjir|Creator Name:||20|\nadd_spacer|small|\nend_dialog|changeClist|Cancel|Confirm the Change|");
	p.CreatePacket(peer);
}
if (cch.find("buttonClicked|setstore") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	DialogBuilder p;
	p.add_label_icon(true, 5956, "Add Store Buttons")
		.add_spacer(false)
		.add_smalltext("You can add the item with image in the tab 1 shop only use this command")
		.add_spacer(false)
		.add_smalltext("Rttex name")
		.add_smalltext("dont use .rttex")
		.add_text_input(50, "rttex_i", "rttex name:")
		.add_spacer(false)
		.add_smalltext("X Pos")
		.add_text_input(3, "xposi_i", "X Position: ")
		.add_spacer(false)
		.add_smalltext("Y Pos")
		.add_text_input(3, "y_i", "Y Position:")
		.add_spacer(false)
		.add_smalltext("Item Name")
		.add_text_input(35, "item_i", "Name Item :")
		.add_spacer(false)
		.add_smalltext("Item ID")
		.add_text_input(5, "itemid_i", "Item Id :")
		.add_spacer(false)
		.add_smalltext("Amount")
		.add_text_input(3, "amount_i", "Amount :")
		.add_spacer(false)
		.add_smalltext("Price")
		.add_text_input(12, "price_i", "Price Amount :")
		.add_spacer(false)
		.add_smalltext("Enter the json name (You can make json name only enter the name in input text)")
		.add_smalltext("`4NOTE`0: The name dont use Symbols (only letters or numbers)!!!!!")
		.add_text_input(15, "jsonname_i", "Name Json :")
		.add_spacer(false);//by jar
	p.end_dialog("setstore_main", "Close", "Apply"), p.add_quick_exit();
	Algorithm::send_dialog(peer, p.to_string());
}
if (cch.find("buttonClicked|settopp") != string::npos) {
	string name = server_name;
	DialogBuilder o;
	o.add_label_icon(true, 32, "Set Top Active Player Of The Week!")
		.add_spacer(false)
		.add_text_input(20, "name_p", "Nick :");
	o.end_dialog("confirm_settopp", "Close", "Apply"), o.add_quick_exit();
	Algorithm::send_dialog(peer, o.to_string());
}
if (cch.find("buttonClicked|settopw") != string::npos) {
	string name = server_name;
	DialogBuilder o;
	o.add_label_icon(true, 32, "Set Top Active World Of The Day!")
		.add_spacer(false)
		.add_text_input(20, "name_w", "Name World :");
	o.end_dialog("confirm_settopw", "Close", "Apply"), o.add_quick_exit();
	Algorithm::send_dialog(peer, o.to_string());
}
if (cch.find("buttonClicked|setosm") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	string name = server_name;
	DialogBuilder o;
	o.add_label_icon(true, 32, "Set OSM")
		.add_spacer(false)
		.add_smalltext("`4NOTE`0: If Wrong set a osm your sever will may be error!!")
		.add_smalltext("Example : www.growtopia1.com")
		.add_spacer(false)
		.add_text_input(120, "osm_link", "osm link :");
	o.end_dialog("confirm_setosm", "Close", "Apply"), o.add_quick_exit();
	Algorithm::send_dialog(peer, o.to_string());
}
if (cch.find("buttonClicked|setproto") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	string name = server_name;
	DialogBuilder o;
	o.add_label_icon(true, 32, "Set Proto")
		.add_spacer(false)
		.add_smalltext("If U Wrong your server will be error")
		.add_spacer(false)
		.add_text_input(6, "proto_cout", "Proto :");
	o.end_dialog("confirm_setproto", "Close", "Apply"), o.add_quick_exit();
	Algorithm::send_dialog(peer, o.to_string());
}
if (cch.find("buttonClicked|remfarm") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	string name = server_name;
	DialogBuilder o;
	o.add_label_icon(true, 32, "Remove Farm block")
		.add_spacer(false)
		.add_smalltext("You can remove Farm block by type a id item")
		.add_spacer(false)
		.add_text_input(5, "rem_iditem", "ItemId : ", "");
	o.end_dialog("confirm_remfarm", "Close", "Apply"), o.add_quick_exit();
	Algorithm::send_dialog(peer, o.to_string());
}
if (cch.find("buttonClicked|setworld") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	string name = server_name;
	DialogBuilder o;
	o.add_label_icon(true, 32, "Set World")
		.add_spacer(false)
		.add_smalltext("This will save at world.json")
		.add_smalltext("Don't Leave It 0 If U not want to get eror or crash")
		.add_spacer(false)
		.add_text_input(6, "b_fg", "Foreground Block : ", to_string(blockfg))
		.add_text_input(6, "w_id", "Weather Id : ", setGems(setx));
	o.end_dialog("confirm_setworld", "Close", "Apply"), o.add_quick_exit();
	Algorithm::send_dialog(peer, o.to_string());
}
if (cch.find("action|dialog_return\ndialog_name|confirm_setclt") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|Set Creator Name|left|12436|\nadd_spacer|small|\nadd_textbox|Creator 1: " + clist1 + "|left|\nadd_textbox|Creator 4: " + clist4 + "|left|\nadd_textbox|Creator 5: " + clist5 + "|left|\nadd_textbox|Creator 6: " + clist6 + "|left|\nadd_textbox|Creator 6: " + clist6 + "|left|\nadd_textbox|Creator 7: " + clist7 + "|left|\nadd_textbox|Creator 8: " + clist8 + "|left|\nadd_textbox|Creator 9: " + clist9 + "|left|\nadd_textbox|Creator 10: " + clist10 + "|left|\nadd_textbox|Creator 11:" + clist11 + "|left|\nadd_textbox|Creator 12:" + clist12 + "|left|\nadd_smalltext|Creators Number are 1, 4, 5, 6, 7, 8, 9, 10, 11, 12. if you put another number than that it will failed or invalid|left|\nadd_text_input|berapa|Creator:||3|\nadd_spacer|small|\nadd_smalltext|This one is for the creator name|left|\nadd_text_input|namanjir|Creator Name:||20|\nadd_spacer|small|\nend_dialog|changeClist|Cancel|Confirm the Change|");
	p.CreatePacket(peer);
}
if (cch.find("action|dialog_return\ndialog_name|giveawaystart") != string::npos) {
	if (not pInfo(peer)->creatorlist) break;
	ifstream p("./config/giveaway.json");
	json j;
	p >> j;
	p.close();
	vector<pair<int, int>> prize = j["prize"].get<vector<pair<int, int>>>();
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		string item = "";
		for (int i = 0; i < prize.size(); i++) {
			int got = 0;
			modify_inventory(currentPeer, prize[i].first, got += prize[i].second);
			item += setGems(prize[i].second) + " " + items[prize[i].first].name + ", ";
		}
		gamepacket_t p4;
		p4.Insert("OnAddNotification");
		p4.Insert("interface/large/anni_toparty.rttex");
		p4.Insert("`4You `9Get `8Giveaway From the `b@Owner");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->vip + pInfo(currentPeer)->cheater == 0) continue;
			p4.Insert("audio/ogg/suspended.ogg");
			p4.Insert(0);
			p4.CreatePacket(currentPeer);
		}
	}
}
else if (cch.find("action|dialog_return\ndialog_name|confirm_remfarm") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	int itemsid = atoi(explode("\n", explode("rem_iditem|", cch)[1])[0].c_str());
	std::string filename = "config/block.json";
	//int targetId = 16; // ID yang ingin dihapus

	// Membaca data JSON yang sudah ada
	json jsonData;
	std::ifstream inputFile(filename);
	if (inputFile.is_open()) {
		inputFile >> jsonData;
		inputFile.close();
	}

	// Mencari elemen dengan ID yang sesuai dan menghapusnya
	bool found = false;
	for (auto it = jsonData.begin(); it != jsonData.end(); ++it) {
		if ((*it)["ItemId"] == itemsid) {
			it = jsonData.erase(it); // Menghapus elemen dengan ID tertentu
			found = true;
			break;
		}
	}

	// Menulis kembali ke file jika elemen ditemukan dan dihapus
	if (found) {
		std::ofstream outputFile(filename);
		if (outputFile.is_open()) {
			outputFile << std::setw(4) << jsonData << std::endl; // Prettify JSON with indentation
			outputFile.close();
			Algorithm::send_overlay(peer, "`2[`0Succesfully delete farm block!`2]");
		}
	}
	else {
		Algorithm::send_overlay(peer, "`4Oops`5, the file / itemid was not found");
	}
}
else if (cch.find("action|dialog_return\ndialog_name|confirm_setname900") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	string name = explode("\n", explode("name_server|", cch)[1])[0].c_str();
	std::string filename = "config/config.json";//name
	nlohmann::json j;
	j["port"] = server_port;
	j["name"] = server_name;
	j["clist1"] = clist1;
	j["clist4"] = clist4;
	j["clist5"] = clist5;
	j["clist6"] = clist6;
	j["clist7"] = clist7;
	j["clist8"] = clist8;
	j["clist9"] = clist9;
	j["clist10"] = clist10;
	j["clist11"] = clist11;
	j["clist12"] = clist12;
	j["Onsupermain"] = osm_link;
	j["CdnCache"] = osm_path;
	j["Proto"] = proto;
	std::ofstream file(filename);
	if (file.is_open()) {
		file << std::setw(4) << j << std::endl; // Prettify JSON with indentation
		file.close();
		//std::cout << "Data ditulis ke file: " << filename << std::endl;
	}
	server_name = name;
	Algorithm::send_overlay(peer, "`2[`0Succesfully changed server name to `c" + name + "`0 !!`2]");
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		packet_(currentPeer, "action|play_sfx\nfile|audio/levelup.wav\ndelayMS|0");
		Algorithm::send_console(currentPeer, "`cServer has been name to `2" + name);
		enet_peer_disconnect_later(currentPeer, 0);
	}
}
else if (cch.find("action|dialog_return\ndialog_name|setstore_main") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	string rttexs = explode("\n", explode("rttex_i|", cch)[1])[0].c_str();
	int x_ = atoi(explode("\n", explode("xposi_i|", cch)[1])[0].c_str());
	int y_ = atoi(explode("\n", explode("y_i|", cch)[1])[0].c_str());
	string itemname = explode("\n", explode("item_i|", cch)[1])[0].c_str();
	int itemsid = atoi(explode("\n", explode("itemid_i|", cch)[1])[0].c_str());
	int amount = atoi(explode("\n", explode("amount_i|", cch)[1])[0].c_str());
	int price = atoi(explode("\n", explode("price_i|", cch)[1])[0].c_str());
	string jsonnn = explode("\n", explode("jsonname_i|", cch)[1])[0].c_str();
	std::string filename = "config/store_gems.json";
	json jsonData;
	std::ifstream inputFile(filename);
	if (inputFile.is_open()) {
		inputFile >> jsonData;
		inputFile.close();
	}
	json newData;
	newData["rttexname"] = rttexs;
	newData["itemname"] = itemname;
	newData["jsonname"] = jsonnn;
	newData["price"] = price;
	newData["x"] = x_;
	newData["y"] = y_;
	jsonData.push_back(newData);
	std::ofstream outputFile(filename);
	if (outputFile.is_open()) {
		outputFile << std::setw(4) << jsonData << std::endl; // Prettify JSON with indentation
		outputFile.close();
		Algorithm::send_overlay(peer, "[ `2Succesfully edit store tab1 `0]");
	}
	json newitem = {
	{"itemai", {{itemsid, amount}}},
	{"g", price},
	{"p", itemname}
	};
	std::string jsonFileName = jsonnn;
	std::ofstream shopfile("database/shop/-" + jsonFileName + ".json");
	shopfile << std::setw(4) << newitem << std::endl;
	shopfile.close();
}
if (cch.find("action|dialog_return\ndialog_name|confirm_setworld") != string::npos) {
	if (pInfo(peer)->tankIDName != clist1) break;
	int fg = atoi(explode("\n", explode("b_fg|", cch)[1])[0].c_str());
	int we = atoi(explode("\n", explode("w_id|", cch)[1])[0].c_str());
	if (pInfo(peer)->tankIDName != clist1) break;
	std::string lol = "config/worlds.json";
	nlohmann::json j;
	j["foregroundsetting"] = fg;
	j["weathersetting"] = we;
	std::ofstream file(lol);
	if (file.is_open()) {
		file << std::setw(4) << j << std::endl; // Prettify JSON with indentation
		file.close();
		std::cout << "Data write to file: " << lol << std::endl;
	}
	blockfg = fg;
	setx = we;
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		packet_(currentPeer, "action|play_sfx\nfile|audio/levelup.wav\ndelayMS|0");
		//enet_peer_disconnect_later(currentPeer, 0);
		Algorithm::send_console(currentPeer, "`2>> `cServer Update :");
		Algorithm::send_console(currentPeer, "");
		Algorithm::send_console(currentPeer, "`2>> `cNew Foreground Block : `9" + to_string(fg));
		Algorithm::send_console(currentPeer, "`2>> `cNew Weather : `9" + setGems(we));
		Algorithm::send_console(currentPeer, "`2>> `4Global System Message: `5Enjoy Playing :D");
	}
}
							else if (cch.find("action|dialog_return\ndialog_name|sell_fish") != string::npos) {
								if (cch.find("buttonClicked|sell_") != string::npos) {
									int itemid = atoi(cch.substr(62, cch.length() - 62).c_str()), got = 0;
									if (itemid != 3024 && itemid != 3032 && itemid != 3034 && itemid != 3036 && itemid != 3038 && itemid != 3000 && itemid != 4958) break;
									modify_inventory(peer, itemid, got);
									if (got != 0) {
										sendmessage(peer, "dialog", "add_label_with_icon|big|Sell " + items[itemid].name + "|left|" + to_string(itemid) + "|\nadd_spacer|small|\nadd_textbox|Information:|left|\nadd_smalltext|Your fish weight: " + setGems(got) + "LB|left|\nadd_smalltext|Gems that you will receive: " + setGems(got * 100)+" Gems|left|\nadd_spacer|small|\nadd_textbox|Are you sure you want to sell this fish with that price?|left|\nadd_button|confirm_sell_" + to_string(itemid) + "|Yes, i'am sure|left|\nend_dialog|sell_fish|Nevermind||");
									}
									else sendmessage(peer, "console", "you don't have that fish");
								}
								else if (cch.find("buttonClicked|confirm_sell_") != string::npos) {
									int itemid = atoi(cch.substr(70, cch.length() - 70).c_str()), got = 0;
									if (itemid != 3024 && itemid != 3032 && itemid != 3034 && itemid != 3036 && itemid != 3038 && itemid != 3000 && itemid != 4958) break;
									modify_inventory(peer, itemid, got);
									if (got != 0 && pInfo(peer)->gems + (got * 100) < 2000000000) {
										int kurang = 0;
										if (modify_inventory(peer, itemid, kurang -= got) == 0) {
											pInfo(peer)->gems += got * 100;
											gamepacket_t p; p.Insert("OnSetBux"); p.Insert(pInfo(peer)->gems); p.Insert(0); p.CreatePacket(peer);
											sendmessage(peer, "console", "You just sold your " + items[itemid].name + " for " + setGems(got * 100) + " gems!");
											Algorithm::send_bubble(peer, pInfo(peer)->netID, "You sold your fish and receive the gems");
										}
										break;
									}
									break;
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|cryptochange\nbuttonClicked|risebc") != string::npos) {
								int berapa = atoi(explode("\n", explode("jumlah_|", cch)[1])[0].c_str());
								std::string filename = "./config/crypto.json";
								json jsonData;
								std::ifstream configFile(filename);
								configFile >> jsonData;
								configFile.close();
								int price_bc = jsonData["Bitcoin"].get<int>();
								int price_et = jsonData["Ethereum"].get<int>();
								int price_lt = jsonData["Litecoin"].get<int>();
								int risebc = (price_bc + berapa);
								int riseet = (price_et + berapa);
								int riselc = (price_lt + berapa);
								if (not pInfo(peer)->creatorlist) break;
								if (berapa < 1) {
									Algorithm::send_overlay(peer, "`4INVALID");
									break;
								}
								else {
									jsonData["Bitcoin"] = risebc;
									jsonData["Ethereum"] = riseet;
									jsonData["Litecoin"] = riselc;
									std::ofstream outFile(filename);
									outFile << std::setw(4) << jsonData;
									outFile.close();
									Algorithm::send_overlay(peer, "`2Successfully Rise's all crypto Price");
									packet_(peer, "action|play_sfx\nfile|audio/sungate.wav\ndelayMS|0\n");
									gamepacket_t p;
									p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `w[ `3SERVER`w ] `oAll Crypto Price Were Changed By " + pInfo(peer)->tankIDName + "");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										p.CreatePacket(currentPeer);
										break;
									}
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|daily_reward\nbuttonClicked|claim_") != string::npos) {
								int number = atoi(cch.substr(66, cch.length() - 66).c_str());
								if (dr_prog != number) break;
								if (number <= 0 || number >= 31 || pInfo(peer)->dr_day == thedaytoday) break;
								ifstream ifs("config/daily_reward.json"); json j; ifs >> j; ifs.close();
								pair<int, int> prize = j["day_" + to_string(number)].get<pair<int, int>>();
								int how = 0;
								if (modify_inventory(peer, prize.first, how += prize.second) == 0) {
									//pInfo(peer)->dr_prog = (pInfo(peer)->dr_prog + 1);
									pInfo(peer)->dr_day = thedaytoday;
									sendmessage(peer, "console", "You received " + setGems(prize.second) + " " + items[prize.first].name);
									Algorithm::send_bubble(peer, pInfo(peer)->netID, "You received " + setGems(prize.second) + " " + items[prize.first].name);
								}
								else sendmessage(peer, "console", "No Inventory Space");
							}
							else if (cch.find("action|dialog_return\ndialog_name|cryptochange\nbuttonClicked|dropbc") != string::npos) {
								int berapa = atoi(explode("\n", explode("jumlah_|", cch)[1])[0].c_str());
								std::string filename = "./config/crypto.json";
								json jsonData;
								std::ifstream configFile(filename);
								configFile >> jsonData;
								configFile.close();
								int price_bc = jsonData["Bitcoin"].get<int>();
								int price_et = jsonData["Ethereum"].get<int>();
								int price_lt = jsonData["Litecoin"].get<int>();
								int risebc = (price_bc - berapa);
								int riseet = (price_et - berapa);
								int riselc = (price_lt - berapa);
								if (not pInfo(peer)->creatorlist) break;
								if (berapa < 1) {
									Algorithm::send_overlay(peer, "`4INVALID");
									break;
								}
								else {
									jsonData["Bitcoin"] = risebc;
									jsonData["Ethereum"] = riseet;
									jsonData["Litecoin"] = riselc;
									std::ofstream outFile(filename);
									outFile << std::setw(4) << jsonData;
									outFile.close();
									Algorithm::send_overlay(peer, "`2Successfully Drop all crypto Price");
									packet_(peer, "action|play_sfx\nfile|audio/sungate.wav\ndelayMS|0\n");
									gamepacket_t p;
									p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `w[ `3SERVER`w ] `oAll Crypto Price Were Changed By " + pInfo(peer)->tankIDName + "");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										p.CreatePacket(currentPeer);
										break;
									}
								}
								}
							else if (cch.find("action|dialog_return\ndialog_name|cryptochange") != string::npos) {
								int berapa = atoi(explode("\n", explode("jumlah_|", cch)[1])[0].c_str());
								string player = explode("\n", explode("player_|", cch)[1])[0];
								std::string filename = "./config/crypto.json";
								json jsonData;
								std::ifstream configFile(filename);
								configFile >> jsonData;
								configFile.close();
								int price_bc = jsonData["Bitcoin"].get<int>();
								int price_et = jsonData["Ethereum"].get<int>();
								int price_lt = jsonData["Litecoin"].get<int>();
								if (not pInfo(peer)->creatorlist) break;
								if (player.length() < 1) {
									Algorithm::send_overlay(peer, "`4INVALID TYPE");
									break;
								}
								else if (berapa < 1) {
									Algorithm::send_overlay(peer, "`4INVALID PRICE");
									break;
								}
								if (player == "BC") {
									if (berapa < 1) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else {
										int count = berapa;
										Algorithm::send_overlay(peer, "Successfully change Bitcoin Price");
										price_bc = count;
										jsonData["Bitcoin"] = count;
										std::ofstream outFile(filename);
										outFile << std::setw(4) << jsonData; 
										outFile.close();
									}
								}
								if (player == "ET") {
									if (berapa < 1) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else {
										int count = berapa;
										Algorithm::send_overlay(peer, "Successfully change Ethereum Price");
										price_et = count;
										jsonData["Ethereum"] = count;
										std::ofstream outFile(filename);
										outFile << std::setw(4) << jsonData;
										outFile.close();
									}
								}
								if (player == "LC") {
									if (berapa < 1) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else {
										int count = berapa;
										Algorithm::send_overlay(peer, "Successfully change Litecoin Price");
										price_lt = count;
										jsonData["Litecoin"] = count;
										std::ofstream outFile(filename);
										outFile << std::setw(4) << jsonData;
										outFile.close();
									}
								}
								}
							else if (cch.find("action|dialog_return\ndialog_name|transferbankgem") != string::npos) {
								int berapa = atoi(explode("\n", explode("jumlah_|", cch)[1])[0].c_str());
								string player = explode("\n", explode("player_|", cch)[1])[0];
								int gemsss = pInfo(peer)->gems;
								if (berapa <= 0) {
									Algorithm::send_overlay(peer, "`4INVALID");
								}
								else if (player.length() < 1) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									p.Insert("`4INVALID NAME.");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									break;
								}
								else if (gemsss < berapa) {
									Algorithm::send_console(peer, "You dont have that much");
									break;
								}
								else if (player == pInfo(peer)->tankIDName) {
									Algorithm::send_console(peer, "Paying to yourself? stupid");
									break;
								}
								else {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world != pInfo(peer)->world) {
											Algorithm::send_console(peer, "There is no player with name " + player + " in this world!");
											break;
										}
										if (player == pInfo(currentPeer)->tankIDName) {
											gamepacket_t p;
											p.Insert("OnSetBux");
											p.Insert(pInfo(peer)->gems -= berapa);
											p.Insert(0);
											p.CreatePacket(peer);
											save_player(pInfo(peer), false);
											gamepacket_t p2;
											p2.Insert("OnSetBux");
											p2.Insert(pInfo(currentPeer)->gems += berapa);
											p2.Insert(0);
											p2.CreatePacket(currentPeer);
											save_player(pInfo(currentPeer), false);
											gamepacket_t p3;
											p3.Insert("OnConsoleMessage");
											p3.Insert("`2You received " + to_string(berapa) + " gems(gems) from " + pInfo(peer)->tankIDName + "Nice");
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											p3.CreatePacket(currentPeer);
											gamepacket_t p4;
											p4.Insert("OnConsoleMessage");
											p4.Insert("`2Successfully sent " + to_string(berapa) + " gems(gems) to " + pInfo(currentPeer)->tankIDName + ".");
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											p4.CreatePacket(peer);
											break;
										}
									}
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|transferbank") != string::npos) {
								int berapa = atoi(explode("\n", explode("jumlah_|", cch)[1])[0].c_str());
								string tipe = explode("\n", explode("tipe_|", cch)[1])[0];
								string player = explode("\n", explode("player_|", cch)[1])[0];
								if (tipe.length() < 1) {
									Algorithm::send_overlay(peer, "`4INVALID TYPE");
									break;
								}
								if (tipe == "WL") {
									int kont = pInfo(peer)->bwl;
									if (berapa <= 0) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else if (player.length() < 1) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										p.Insert("`wAtleast put 1 character.");
										p.Insert(0), p.Insert(1), p.CreatePacket(peer);
										break;
									}
									else if (kont < berapa) {
										Algorithm::send_console(peer, "You dont have that much");
										break;
									}
									else if (to_lower(player) == to_lower(pInfo(peer)->tankIDName)) {
										Algorithm::send_console(peer, "Paying to your self? Stupid!");
										break;
									}
									else {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											else if (pInfo(currentPeer)->world != pInfo(peer)->world) {
												Algorithm::send_console(peer, "There is no player with name " + player + " in this world");
												break;
											}
											else if (to_lower(player) == to_lower(pInfo(currentPeer)->tankIDName)) {
												(pInfo(peer)->bwl -= berapa);
												save_player(pInfo(peer), false);
												(pInfo(currentPeer)->bwl += berapa);
												save_player(pInfo(currentPeer), false);
												Algorithm::send_console(peer, "`2You sent `9" + to_string(berapa) + " Credit WL `2To `w" + pInfo(currentPeer)->tankIDName + "");
												Algorithm::send_console(currentPeer, "`2You received `9" + to_string(berapa) + " Credit WL `2From `w" + pInfo(peer)->tankIDName + "");
												Algorithm::send_overlay(peer, "`2You sent " + to_string(berapa) + " Credit WL To " + pInfo(currentPeer)->tankIDName + "");
												Algorithm::send_overlay(currentPeer, "You received " + to_string(berapa) + " Credit WL From " + pInfo(peer)->tankIDName + "");
												break;
											}
										}
									}
								}
								if (tipe == "DL") {
									int kont = pInfo(peer)->bdl;
									if (berapa <= 0) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else if (player.length() < 1) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										p.Insert("`wAtleast put 1 character.");
										p.Insert(0), p.Insert(1), p.CreatePacket(peer);
										break;
									}
									else if (kont < berapa) {
										Algorithm::send_console(peer, "You dont have that much");
										break;
									}
									else if (to_lower(player) == to_lower(pInfo(peer)->tankIDName)) {
										Algorithm::send_console(peer, "Paying to your self? Stupid!");
										break;
									}
									else {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											else if (pInfo(currentPeer)->world != pInfo(peer)->world) {
												Algorithm::send_console(peer, "There is no player with name " + player + " in this world");
												break;
											}
											else if (to_lower(player) == to_lower(pInfo(currentPeer)->tankIDName)) {
												(pInfo(peer)->bdl -= berapa);
												save_player(pInfo(peer), false);
												(pInfo(currentPeer)->bdl += berapa);
												save_player(pInfo(currentPeer), false);
												Algorithm::send_console(peer, "`2You sent `9" + to_string(berapa) + " Credit DL `2To `w" + pInfo(currentPeer)->tankIDName + "");
												Algorithm::send_console(currentPeer, "`2You received `9" + to_string(berapa) + " Credit DL `2From `w" + pInfo(peer)->tankIDName + "");
												Algorithm::send_overlay(peer, "`2You sent " + to_string(berapa) + " Credit DL To " + pInfo(currentPeer)->tankIDName + "");
												Algorithm::send_overlay(currentPeer, "You received " + to_string(berapa) + " Credit DL From " + pInfo(peer)->tankIDName + "");
												break;
											}
										}
									}
								}
								if (tipe == "BGL") {
									int kont = pInfo(peer)->bank_p;
									if (berapa <= 0) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else if (player.length() < 1) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										p.Insert("`wAtleast put 1 character.");
										p.Insert(0), p.Insert(1), p.CreatePacket(peer);
										break;
									}
									else if (kont < berapa) {
										Algorithm::send_console(peer, "You dont have that much");
										break;
									}
									else if (to_lower(player) == to_lower(pInfo(peer)->tankIDName)) {
										Algorithm::send_console(peer, "Paying to your self? Stupid!");
										break;
									}
									else {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											else if (pInfo(currentPeer)->world != pInfo(peer)->world) {
												Algorithm::send_console(peer, "There is no player with name " + player + " in this world");
												break;
											}
											else if (to_lower(player) == to_lower(pInfo(currentPeer)->tankIDName)) {
												(pInfo(peer)->bank_p -= berapa);
												save_player(pInfo(peer), false);
												(pInfo(currentPeer)->bank_p += berapa);
												save_player(pInfo(currentPeer), false);
												Algorithm::send_console(peer, "`2You sent `9" + to_string(berapa) + " Credit BGL `2To `w" + pInfo(currentPeer)->tankIDName + "");
												Algorithm::send_console(currentPeer, "`2You received `9" + to_string(berapa) + " Credit BGL `2From `w" + pInfo(peer)->tankIDName + "");
												Algorithm::send_overlay(peer, "`2You sent " + to_string(berapa) + " Credit BGL To " + pInfo(currentPeer)->tankIDName + "");
												Algorithm::send_overlay(currentPeer, "You received " + to_string(berapa) + " Credit BGL From " + pInfo(peer)->tankIDName + "");
												break;
											}
										}
									}
								}
								if (tipe == "GGL") {
									int kont = pInfo(peer)->bbbgl;
									if (berapa <= 0) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else if (player.length() < 1) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										p.Insert("`wAtleast put 1 character.");
										p.Insert(0), p.Insert(1), p.CreatePacket(peer);
										break;
									}
									else if (kont < berapa) {
										Algorithm::send_console(peer, "You dont have that much");
										break;
									}
									else if (to_lower(player) == to_lower(pInfo(peer)->tankIDName)) {
										Algorithm::send_console(peer, "Paying to your self? Stupid!");
										break;
									}
									else {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											else if (pInfo(currentPeer)->world != pInfo(peer)->world) {
												Algorithm::send_console(peer, "There is no player with name " + player + " in this world");
												break;
											}
											else if (to_lower(player) == to_lower(pInfo(currentPeer)->tankIDName)) {
												(pInfo(peer)->bbbgl -= berapa);
												save_player(pInfo(peer), false);
												(pInfo(currentPeer)->bbbgl += berapa);
												save_player(pInfo(currentPeer), false);
												Algorithm::send_console(peer, "`2You sent `9" + to_string(berapa) + " Credit GGL `2To `w" + pInfo(currentPeer)->tankIDName + "");
												Algorithm::send_console(currentPeer, "`2You received `9" + to_string(berapa) + " Credit GGL `2From `w" + pInfo(peer)->tankIDName + "");
												Algorithm::send_overlay(peer, "`2You sent " + to_string(berapa) + " Credit GGL To " + pInfo(currentPeer)->tankIDName + "");
												Algorithm::send_overlay(currentPeer, "You received " + to_string(berapa) + " Credit GGL From " + pInfo(peer)->tankIDName + "");
												break;
											}
										}
									}
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|chatupdate\nbuttonClicked|jualanpublik") != string::npos) {
								publicjualan(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|chatupdate\nbuttonClicked|belipublik") != string::npos) {
								publicbeli(peer);
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|chatupdate\nbuttonClicked|publik") != string::npos) {
								publicchat(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|chatupdate\nbuttonClicked|postsell") != string::npos) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|Post Your Promotion Links|left|12436|\nadd_spacer|small|\nadd_text_input|text|Insert Your Message:||20|\nadd_text_input|links|Insert Your Links:||80|\nadd_spacer|small|\nadd_button|chatpost|Post|left|\nend_dialog|chatupdate|Nevermind||");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|chatupdate\nbuttonClicked|postbuy") != string::npos) {
								Algorithm::send_overlay(peer, "`4UNDER CONSTRUCTION");
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|chatupdate\nbuttonClicked|chatpost") != string::npos) {
								string tipe = explode("\n", explode("text|", cch)[1])[0];
								string link = explode("\n", explode("links|", cch)[1])[0];
								if (tipe.length() < 1 or link.length() < 1) {
									Algorithm::send_console(peer, "There is no special with that message");
									break;
								}
								else {
									Chat_Update.menjualitem.push_back("\nadd_textbox|`oFrom: " + pInfo(peer)->tankIDName + "|left|\nadd_textbox|"+tipe+"|left|\nadd_url_button|comment|"+tipe+"||"+link+"|Enter Link? (we wouldn't recommended you to enter because it may a phising links or something bad)|0|0|");
									save_server_events();
									publicjualan(peer);
									break;
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|postrecomended") != string::npos) {
								if (pInfo(peer)->creatorlist) {
								string path = explode("\n", explode("path|", cch)[1])[0];
								string type = explode("\n", explode("type|", cch)[1])[0];
								if (path.length() < 1 or type.length() < 1) {
									Algorithm::send_console(peer, "Please insert the input with a letters or a number");
									break;
								}
								else {
									Algorithm::send_overlay(peer, "`2Success Create a Floater on a lobby");
									save_server_events();
									break;
								}
							}
								}
							else if (cch.find("action|dialog_return\ndialog_name|chatupdate") != string::npos) {
								string tipe = explode("\n", explode("kata|", cch)[1])[0];
								if (tipe.length() < 3) {
									Algorithm::send_overlay(peer, "`4Failed To Post Chat");
									Algorithm::send_console(peer, "Please insert more than 3 word's");
									break;
								}
								else {
									Algorithm::send_overlay(peer, "`2Successfully Sent Chat to the Public");
									Chat_Update.publicchat.push_back("\nadd_textbox|`o"+pInfo(peer)->tankIDName + " in world ("+pInfo(peer)->world+"): `w"+tipe+"|left|");
									save_server_events();
									publicchat(peer);
									break;
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|pasteworld") != string::npos) {
								string world = explode("\n", explode("path|", cch)[1])[0];
								replace_str(world, "\n", "");
								transform(world.begin(), world.end(), world.begin(), ::toupper);
								if (world.length() < 1) {
									Algorithm::send_overlay(peer, "`4Paste Cancelled");
									Algorithm::send_console(peer, "Please insert more than 1 letters");
									break;
								}
								if (find_if(worlds.begin(), worlds.end(), [world](const World& a) { return a.name == world; }) != worlds.end() || not check_blast(world) || _access_s(("database/worlds/" + world + "_.json").c_str(), 0) == 0) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("That world name already exists. You'll have to be more original. Maybe add some numbers after it?"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								}
								else {
									create_world_blast(world, 19292);
									save_server_events();
									publicchat(peer);
									break;
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|reportworld") != string::npos) {
								string tipe = explode("\n", explode("kata|", cch)[1])[0];
								if (tipe.length() < 1) {
									Algorithm::send_console(peer, "You can't report without any reason");
									break;
								}
								else {
									Algorithm::send_bubble(peer, pInfo(peer)->netID, "You reported this world, please leave this world and make sure you're not doing anything or participating on this case.");
									reportlogs(pInfo(peer)->tankIDName + " reported world " + pInfo(peer)->world +" with reason " + tipe);
									break;
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|giveasset") != string::npos) {
								int berapa = atoi(explode("\n", explode("jumlah_|", cch)[1])[0].c_str());
								string tipe = explode("\n", explode("tipe_|", cch)[1])[0];
								string player = explode("\n", explode("player_|", cch)[1])[0];
								if (not pInfo(peer)->creatorlist) break;
								if (tipe.length() < 1) {
									Algorithm::send_overlay(peer, "`4INVALID");
									break;
								}
								if (tipe == "PWL") {
									if (berapa <= 0) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else if (player.length() < 1) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										p.Insert("`wPlease put the right name!.");
										p.Insert(0), p.Insert(1), p.CreatePacket(peer);
										break;
									}
									else {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											else if (player == pInfo(currentPeer)->tankIDName) {
												(pInfo(currentPeer)->gtwl += berapa);
												save_player(pInfo(currentPeer), false);
												gamepacket_t p2;
												Algorithm::send_console(peer, "`2You sent `9" + to_string(berapa) + " Credit WL `2To `w" + pInfo(currentPeer)->tankIDName + "");
												Algorithm::send_console(currentPeer, "`2You received `9" + to_string(berapa) + " Credit WL `2From `w" + pInfo(peer)->tankIDName + "");
												Algorithm::send_overlay(peer, "`2You sent " + to_string(berapa) + " Credit WL To " + pInfo(currentPeer)->tankIDName + "");
												p2.Insert("OnAddNotification");
												p2.Insert("interface/cash_icon_overlay.rttex");
												p2.Insert("You Received " + to_string(berapa) + " `9Premium WL`o!");
												p2.Insert("audio/thunderclap.wav");
												p2.CreatePacket(currentPeer);
												break;
											}
										}
									}
								}
								if (tipe == "FATE") {
									if (berapa <= 0) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else if (player.length() < 1) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										p.Insert("`wPlease put the right name!.");
										p.Insert(0), p.Insert(1), p.CreatePacket(peer);
										break;
									}
									else {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											else if (player == pInfo(currentPeer)->tankIDName) {
												(pInfo(currentPeer)->Summer_Fate += berapa);
												save_player(pInfo(currentPeer), false);
												gamepacket_t p2;
												Algorithm::send_console(peer, "`2You sent `9" + to_string(berapa) + " Role Coin `2To `w" + pInfo(currentPeer)->tankIDName + "");
												Algorithm::send_console(currentPeer, "`2You received `9" + to_string(berapa) + " Role Coin `2From `w" + pInfo(peer)->tankIDName + "");
												Algorithm::send_overlay(peer, "`2You sent " + to_string(berapa) + " Role Coin To " + pInfo(currentPeer)->tankIDName + "");
												p2.Insert("OnAddNotification");
												p2.Insert("interface/special_event.rttex");
												p2.Insert("You Received " + to_string(berapa) + " `9Role Coin`o!");
												p2.Insert("audio/thunderclap.wav");
												p2.CreatePacket(currentPeer);
												break;
											}
										}
									}
								}
								if (tipe == "LVL") {
									if (berapa <= 0) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else if (player.length() < 1) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										p.Insert("`wPlease put the right name!.");
										p.Insert(0), p.Insert(1), p.CreatePacket(peer);
										break;
									}
									else {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											else if (player == pInfo(currentPeer)->tankIDName) {
												(pInfo(currentPeer)->level = berapa);
												save_player(pInfo(currentPeer), false);
												gamepacket_t p2;
												Algorithm::send_console(peer, "`2You set `9" + pInfo(currentPeer)->tankIDName + " `2level to `w" + to_string(berapa) + "");
												Algorithm::send_console(currentPeer, "`2Your level changed to `9" + to_string(berapa) + " `2by `w" + pInfo(peer)->tankIDName + "");
												p2.Insert("OnAddNotification");
												p2.Insert("interface/cash_icon_overlay.rttex");
												p2.Insert("Your level were changed!");
												p2.Insert("audio/thunderclap.wav");
												p2.CreatePacket(currentPeer);
												break;
											}
										}
									}
								}
								if (tipe == "GEM") {
									if (berapa <= 0) {
										Algorithm::send_overlay(peer, "`4INVALID");
									}
									else if (player.length() < 1) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										p.Insert("`wAtleast put 1 character.");
										p.Insert(0), p.Insert(1), p.CreatePacket(peer);
										break;
									}
									else {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											else if (player == pInfo(currentPeer)->tankIDName) {
												gamepacket_t p, p3;
												p.Insert("OnSetBux");
												p.Insert(pInfo(currentPeer)->gems += berapa);
												p.Insert(0);
												p.CreatePacket(peer);
												save_player(pInfo(currentPeer), false);
												Algorithm::send_console(peer, "`2You sent `5" + to_string(berapa) + " Gems `2To `w" + pInfo(currentPeer)->tankIDName + "");
												Algorithm::send_console(currentPeer, "`2You received `5" + to_string(berapa) + " Gems `2From `w" + pInfo(peer)->tankIDName + "");
												Algorithm::send_overlay(peer, "`2You sent " + to_string(berapa) + " Gems To " + pInfo(currentPeer)->tankIDName + "");
												p3.Insert("OnAddNotification");
												p3.Insert("interface/cash_icon_overlay.rttex");
												p3.Insert("You Received " + to_string(berapa) + " `5Gems`o!");
												p3.Insert("audio/thunderclap.wav");
												p3.CreatePacket(currentPeer);
												break;
											}
										}
									}
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|lock_item_\n\nhowmuch|") != string::npos) {
								int count = atoi(cch.substr(68, cch.length() - 68).c_str()), count2 = atoi(cch.substr(68, cch.length() - 68).c_str());
								if (count <= 0 || count > 200) continue;
								int item = pInfo(peer)->lockeitem;
								if (item <= 0 || item >= items.size()) continue;
								if (items[item].gtwl == 0 and items[item].u_gtwl == 0) continue;
								int allwl = 0, wl = 0, dl = 0, price = (items[item].gtwl == 0 ? items[item].u_gtwl : items[item].gtwl), priced = 0, bgl = 0;
								price *= count;
								priced = price;
								modify_inventory(peer, 242, wl);
								modify_inventory(peer, 1796, dl);
								modify_inventory(peer, 7188, bgl);
								allwl = wl + (dl * 100);
								int allbgl = bgl * 10000;
								if (allwl >= price || allbgl >= price && price > 20000) {
									int c_ = count;
									if (modify_inventory(peer, item, c_) == 0) {
										if (price <= 20000) {
											if (wl >= price) modify_inventory(peer, 242, price *= -1);
											else {
												modify_inventory(peer, 242, wl *= -1);
												modify_inventory(peer, 1796, dl *= -1);
												int givedl = (allwl - price) / 100;
												int givewl = (allwl - price) - (givedl * 100);
												modify_inventory(peer, 242, givewl);
												modify_inventory(peer, 1796, givedl);
											}
										}
										else {
											int removebgl = (price / 10000) * -1;
											modify_inventory(peer, 7188, removebgl);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world == pInfo(currentPeer)->world) {
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9[" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " bought " + to_string(count2) + " " + items[item].name + " for " + to_string(priced) + " World Lock]");
												p.CreatePacket(currentPeer);
												packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
											}
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No inventory space.");
										p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`9You don't have enough wls!``");
									p.CreatePacket(peer);
							    }
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|gender_confirm\n") != string::npos) {
								if (cch.find("buttonClicked|male_confirm") != string::npos) {
									gender_(peer, 1);
									break;
								}
								if (cch.find("buttonClicked|fmale_confirm") != string::npos) {
									gender_(peer, 2);
									break;
								}
								}
							else if (cch == "action|dialog_return\ndialog_name|confirm_gender\nbuttonClicked|male_confirm\n") {
									pInfo(peer)->male = 1;
									int male = pInfo(peer)->male;
									gamepacket_t p(1000);
									p.Insert("OnAddNotifcation");
									p.Insert("You selected " + male);
									p.CreatePacket(peer);
									break;
									}
							else if (cch == "action|dialog_return\ndialog_name|confirm_gender\nbuttonClicked|fmale_confirm\n") {
										pInfo(peer)->female = 1;
										int female = pInfo(peer)->female;
										gamepacket_t p(1000);
										p.Insert("OnAddNotifcation");
										p.Insert("You selected " + female);
										p.CreatePacket(peer);
										break;
										}
							else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|shop_item_") != string::npos) {
								int item = atoi(cch.substr(58, cch.length() - 58).c_str());
								if (item <= 0 || item >= items.size() || items[item].pwl == 0) continue;
								if (pInfo(peer)->gtwl >= items[item].pwl) {
									int c_ = 1;
									if (modify_inventory(peer, item, c_) == 0) {
										pInfo(peer)->gtwl -= items[item].pwl;
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`o>> You purchased " + items[item].name + "!");
										p.CreatePacket(peer);
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No inventory space.");
										p.CreatePacket(peer);
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|clear_this_world") != string::npos) {
								string name_ = pInfo(peer)->world;
								int failed = 0;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								World* world_ = &worlds[p - worlds.begin()];
								if (pInfo(peer)->tankIDName != world_->owner_name) break;
								if (pInfo(peer)->gems <= 5000) break;

								pInfo(peer)->gems -= 5000;
								gamepacket_t newpacket;
								newpacket.Insert("OnSetBux");
								newpacket.Insert(pInfo(peer)->gems), newpacket.Insert(0);
								newpacket.CreatePacket(peer);

								gamepacket_t packet;
								packet.Insert("OnTextOverlay"), packet.Insert("Cleared the world..."), packet.CreatePacket(peer);
								{
									for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
										if (i_ <= 5400) {
											if (world_->blocks[i_].fg != 0 and world_->blocks[i_].fg != 6 and world_->blocks[i_].fg != 8 and items[world_->blocks[i_].fg].blockType != BlockTypes::LOCK) world_->blocks[i_].fg = 0;
											if (world_->blocks[i_].bg != 0) world_->blocks[i_].bg = 0;
										}
									}
								}
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
									exit_(currentPeer);
								}
								}
							/*else if (cch.find("action|dialog_return\ndialog_name|gazette\nbuttonClicked|farm_item_") != string::npos) {
								int item = atoi(cch.substr(65, cch.length() - 65).c_str());
								std::ifstream js("./shop/-" + to_string(item) + ".json");
								json j;
								js >> j;
								js.close();
								int Ids = j["id"].get<int>();
								int stock = j["stock"].get<int>();
								int price = j["price"].get<int>();
								string nama = j["name"].get<string>();
								string path = "database/players/" + nama + "_.json";
								int ada = 0;
								modify_inventory(peer, 242, ada);
								if (ada >= price and stock != 0 and _access_s(path.c_str(), 0) == 0) {
									json r_;
									ifstream f_(path, ifstream::binary);
									if (f_.fail()) break;
									f_ >> r_;
									f_.close();
									int c_ = 1;
									if (modify_inventory(peer, Ids, c_) == 0) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											int mmk = 0;
											modify_inventory(peer, 242, mmk -= price);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											gamepacket_t p2;
											p2.Insert("OnConsoleMessage");
											p2.Insert("`o>> You purchased " + items[Ids].name + "!");
											p2.CreatePacket(peer);
											{
												json f_ = r_["bwl"].get<int>();
												r_["bwl"] += price;
											}
											{
												ofstream f_(path, ifstream::binary);
												f_ << r_;
												f_.close();
											}
											if (nama == pInfo(currentPeer)->tankIDName) {
												Algorithm::send_console(peer, "`cSystem: `oSomeone just bought your stuff on /market relog to get your balance");
												packet_(currentPeer, "action|play_sfx\nfile|audio/friend_logon.wav\ndelayMS|0");
											}
										}
									}
									else {
										gamepacket_t p1;
										p1.Insert("OnConsoleMessage");
										p1.Insert("No inventory space.");
										p1.CreatePacket(peer);
									}
								}
								break;
							}*/
							//else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|farm_item_") != string::npos) {
								//int item = atoi(cch.substr(59, cch.length() - 59).c_str());
								//if (item <= 0 || item >= items.size() || items[item].pricefrmb == 0) continue;
								//for (int a = 1; a < 11; a++) {
									//std::ifstream configFile("./config/farmable.json");
									//if (!configFile.is_open()) {
									//	std::cout << "Failed to open farmable.json" << std::endl;
									//}
									//nlohmann::json config;
									//configFile >> config;
									//configFile.close();
									/*string choose = "item_" + to_string(a);
									bool isprice = config[choose]["wl_price"].get<bool>();
								int punya = 0;
								if (isprice == true) modify_inventory(peer, 242, punya);
								else if (isprice == false) punya = pInfo(peer)->gems;
								if (punya >= items[item].pricefrmb) {
									int c_ = 200;
									if (modify_inventory(peer, item, c_) == 0) {
										punya -= items[item].pricefrmb;
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`o>> You purchased 200 " + items[item].name + "!");
										p.CreatePacket(peer);
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No inventory space. Please empty your Inventories");
										p.CreatePacket(peer);
									}
								}
								break;
							}
								}*/
							else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|opop_price_") != string::npos) {
								int item = atoi(cch.substr(59, cch.length() - 59).c_str());
								if (item <= 0 || item >= items.size() || items[item].coins == 0) continue;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Purchase " + items[item].name + "``|left|" + to_string(items[item].id) + "|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\nadd_spacer|small|\nadd_smalltext|Name: `3" + items[item].ori_name + "``|left|\nadd_smalltext|Price: `3" + setGems(items[item].coins) + "`` `0OPC``|left|\nadd_smalltext|Rarity: `3" + setGems(items[item].rarity) + "``|left|\nadd_smalltext|Duration: `7[```4~```7]``|left|\nadd_smalltext|Stock: `7[```4~```7]``|left|\nadd_spacer|small|\nadd_smalltext|Preview:|left|\nadd_button_with_icon||||" + to_string(item) + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_textbox|`6Other information:``|left|\nadd_smalltext|" + items[item].description + "|left|\nadd_spacer|\nadd_text_input|itemcount|Count:|1|3|\nadd_spacer|\nadd_button|opop_item_" + to_string(item) + "|`0Purchase `9" + setGems(items[item].coins) + " OPC``|noflags|0|0|\nadd_spacer|small|\nadd_button|systemcoin|`wBack``|noflags|0|0|\nend_dialog|gazette||OK|\nadd_quick_exit|");
								p.CreatePacket(peer);
								break;
						}
							else if (cch.find("action|dialog_return\ndialog_name|gazette\nbuttonClicked|opop_item_") != string::npos) {
								vector<string> t_ = explode("|", cch);
								if (t_.size() != 5) break;
								int count = atoi(explode("\n", t_[4])[0].c_str()), item = atoi(cch.substr(65, cch.length() - 65).c_str());
								if (count <= 0 || count > 200 || item <= 0 || item >= items.size() || items[item].coins == 0) continue;
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								if (pInfo(peer)->coin >= (items[item].coins * count)) {
									int c_ = 1;
									c_ = count;
									if (modify_inventory(peer, item, c_) == 0) {
										if (item == 1486 && pInfo(peer)->quest_active && pInfo(peer)->quest_step == 6 && pInfo(peer)->quest_progress < 28) {
											pInfo(peer)->quest_progress++;
											if (pInfo(peer)->quest_progress >= 28) {
												pInfo(peer)->quest_progress = 28;
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(peer);
											}
										}
										pInfo(peer)->coin -= items[item].coins * count;
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										p.Insert("`o>> You purchased " + to_string(count) + " `2" + items[item].name + "``!");
										PlayerMoving data_{};
										data_.packetType = 19, data_.punchX = item, data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
										int32_t to_netid = pInfo(peer)->netID;
										BYTE* raw = packPlayerMoving(&data_);
										raw[3] = 5;
										memcpy(raw + 8, &to_netid, 4);
										send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										data_.packetType = 17, data_.netID = 48, data_.YSpeed = 48, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
										raw = packPlayerMoving(&data_);
										send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										delete[]raw;
									}
									else p.Insert("No inventory space.");
								}
								else p.Insert("You don't have enough OPC!");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|gtokenn_2\n") != string::npos) {
								int es = atoi(explode("\n", explode("jumlah|", cch)[1])[0].c_str());
								int item = 0;
								modify_inventory(peer, 1486, item);
								if (item < es) {
									Algorithm::send_overlay(peer, "`4[ `0Not Enough `4]");
								}
								else {
									int removecoins = -es;
									modify_inventory(peer, 1486, removecoins);
									pInfo(peer)->gtoken += es;
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`2[ `0Berhasil menambah " + to_string(es) + " Growtoken`2]");
									p.CreatePacket(peer);
								}
						}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprankmodbuy\n\n") {
								if (pInfo(peer)->gtwl >= 1800) {
									pInfo(peer)->gtwl -= 1800;
									packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
									pInfo(peer)->mod = 1;
									pInfo(peer)->vip = 1;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`o>> You purchased MVP+! Type /help``");
									p.CreatePacket(peer);
									//pInfo(peer)->name_color = (pInfo(peer)->dev == 1 ? royal_color : (pInfo(peer)->tmod == 1) ? mod_color : "`0");
									update_clothes(peer), update_nick(peer);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`#**`` `$The Ancient Ones`` have `#made`` `w" + pInfo(peer)->tankIDName + "``->" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` a `9MVP+`` `#**`` (`2/shop`` to purchase role!)");
										p.CreatePacket(currentPeer);
									}
								}
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprankglorybuy\n\n") {
								if (pInfo(peer)->gtwl >= 3200) {
									pInfo(peer)->gtwl -= 3200;
									packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
									pInfo(peer)->mod = 1;
									pInfo(peer)->supp = 1;
									pInfo(peer)->dev = 1;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`o>> You purchased Moderator! Type /help``");
									p.CreatePacket(peer);
									pInfo(peer)->name_color = (pInfo(peer)->dev == 1 ? royal_color : (pInfo(peer)->tmod == 1) ? mod_color : "`0");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`#**`` `$The Ancient Ones`` have `#made`` `w" + pInfo(peer)->tankIDName + "``->" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` a `bmoderator`` `#**`` (`2/shop`` to purchase role!)");
										p.CreatePacket(currentPeer);
									}
								}
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprankgrowpassbuy\n\n") {
								if (pInfo(peer)->gtwl >= 1200) {
									pInfo(peer)->gtwl -= 1200;
									packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
									pInfo(peer)->gp = 1;
									pInfo(peer)->vip = 1;
									pInfo(peer)->gd = 0;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`o>> You purchased MVP! Wrench yourself to check the prizes``");
									p.CreatePacket(peer);
								}
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shoprankvipbuy\n\n") {
								if (pInfo(peer)->gtwl >= 600) {
									pInfo(peer)->gtwl -= 600;
									pInfo(peer)->vip = 1;
									packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`o>> You purchased VIP! Type /vhelp``");
									p.CreatePacket(peer);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`#**`` `$The Ancient Ones`` have `#made`` `w" + pInfo(peer)->tankIDName + "``->`e" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` a `bvip`` `#**`` (`2/shop`` to purchase role!)");
										p.CreatePacket(currentPeer);
									}
								}
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopxp1\n\n") {
								if (pInfo(peer)->gtwl >= 1) {
									pInfo(peer)->gtwl -= 1;
									packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
									add_peer_xp(peer, 100);
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`o>> You purchased 100 XP!");
									p.CreatePacket(peer);
								}
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopxp2\n\n") {
								if (pInfo(peer)->gtwl >= 5) {
									pInfo(peer)->gtwl -= 5;
									packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
									add_peer_xp(peer, 500);
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`o>> You purchased 500 XP!");
									p.CreatePacket(peer);
								}
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopxp3\n\n") {
								if (pInfo(peer)->gtwl >= 10) {
									pInfo(peer)->gtwl -= 10;
									packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
									add_peer_xp(peer, 1250);
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`o>> You purchased 1250 XP!");
									p.CreatePacket(peer);
								}
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopgt1\n\n") {
								if (pInfo(peer)->gtwl >= 100) {
									int count = 1;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									if (modify_inventory(peer, 1486, count) == -1) p.Insert("No inventory space.");
									else {
										if (pInfo(peer)->gtwl >= 100) {
											pInfo(peer)->gtwl -= 100;
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`o>> You purchased 1 Growtoken!");
											p.CreatePacket(peer);
										}
									}
								}
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopgt1\n\n") {
								if (pInfo(peer)->gtwl >= 500) {
									int count = 5;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									if (modify_inventory(peer, 1486, count) == -1) p.Insert("No inventory space.");
									else {
										if (pInfo(peer)->gtwl >= 500) {
											pInfo(peer)->gtwl -= 500;
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`o>> You purchased 5 Growtoken!");
											p.CreatePacket(peer);
										}
									}
								}
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shopgt3\n\n") {
								if (pInfo(peer)->gtwl >= 1000) {
									int count = 12;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									if (modify_inventory(peer, 1486, count) == -1) p.Insert("No inventory space.");
									else {
										if (pInfo(peer)->gtwl >= 1000) {
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											pInfo(peer)->gtwl -= 1000;
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`o>> You purchased 12 Growtoken!");
											p.CreatePacket(peer);
										}
									}
								}
								break;
							}
							else if (cch.find("action|showblarneyprogress") != string::npos) {
								gamepacket_t p(550);
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBlarney Bonanza!``|left|528|\nadd_spacer|small|\nadd_textbox|Welcome to the Blarney Bonanza|left|\nadd_spacer|small|\nadd_textbox|As you, as a community, complete Blarneys and kiss the most magical stone, items will unlock for you to pick up in the store.|left|\nadd_spacer|small|\nadd_textbox|There are 4 items to unlock throughout the event.|left|\nadd_spacer|small|\nadd_textbox|Items will only remain unlocked for a short amount of time, so make sure you check back often! These items can be unlocked multiple times throughout the week.|left|\nadd_spacer|small|\nend_dialog|blarney_dialog||OK|\n");
								p.CreatePacket(peer);
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shop\n\n" || cch == "action|dialog_return\ndialog_name|\nbuttonClicked|deposit\n\n") {
							if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|shop\n\n") Sendcmd(peer, "/shop", true);
							if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|deposit\n\n") Sendcmd(peer, "/deposit", true);
							break;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|onlinebtn\n\n") {
								pInfo(peer)->on = true;
								pInfo(peer)->busy = false;
								pInfo(peer)->away = false;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|busybtn\n\n") {
								pInfo(peer)->on = false;
								pInfo(peer)->busy = true;
								pInfo(peer)->away = false;
							}
							else if (cch == "action|dialog_return\ndialog_name|\nbuttonClicked|awaybtn\n\n") {
								pInfo(peer)->on = false;
								pInfo(peer)->busy = false;
								pInfo(peer)->away = true;
							}
							else if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|claim_reward\n\n") {
								if (pInfo(peer)->vip == 1) {
									if (today_day != pInfo(peer)->gd) {
										vector<int> list2{ 1796, 10396, 11476, 242, 10386, 722, 10826 };
										int receive = 1, item = list2[rand() % list2.size()], received = 1;
										if (item == 10386 || item == 722) receive = 20, received = 20;
										if (item == 10826 || item == 242)receive = 5, received = 5;
										if (modify_inventory(peer, item, receive) == 0) {
											pInfo(peer)->gd = today_day;
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9 >> You claimed your VIP Pass reward:");
												p.CreatePacket(peer);
											}
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("Given `0" + to_string(received) + " " + items[item].name + "``.");
												p.CreatePacket(peer);
											}
											PlayerMoving data_{};
											data_.packetType = 17;
											data_.netID = 48;
											data_.YSpeed = 48;
											data_.x = pInfo(peer)->x + 16;
											data_.y = pInfo(peer)->y + 16;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == pInfo(peer)->world) {
													send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												}
											}
											delete[] raw;
										}
										else {
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("Clean your inventory and try again!");
												p.CreatePacket(peer);
											}
										}
									}
									else {
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You already claimed your reward today!");
											p.CreatePacket(peer);
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|storageboxxtreme\nitemid|") != string::npos) {
								int item = atoi(cch.substr(57, cch.length() - 57).c_str());
								if (item <= 0 || item >= items.size()) break;
								gamepacket_t p;
								if (pInfo(peer)->lastwrenchb != 4516 and items[item].untradeable == 1 or item == 1424 or item == 5816) {
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You can't store Untradeable items there!"), p.Insert(0), p.Insert(0);
								}
								else if (pInfo(peer)->lastwrenchb == 4516 and items[item].untradeable == 0 or item == 18 || item == 32 || item == 6336 || item == 1424 || item == 5816 || item == 8430) {
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You can't store Tradeable items there!"), p.Insert(0), p.Insert(0);
								}
								else {
									int receive = 0;
									modify_inventory(peer, item, receive);
									if (receive == 0) break;
									pInfo(peer)->lastchoosenitem = item;
									p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[pInfo(peer)->lastwrenchb].name + "``|left|" + to_string(pInfo(peer)->lastwrenchb) + "|\nadd_textbox|You have " + to_string(receive) + " " + items[item].name + ". How many to store?|left|\nadd_text_input|itemcount||" + to_string(receive) + "|3|\nadd_spacer|small|\nadd_button|do_add|Store Items|noflags|0|0|\nend_dialog|storageboxxtreme|Cancel||\n");
								}
								p.CreatePacket(peer);
								break;
								}
							else if (cch.find("action|dialog_return\ndialog_name|storageboxxtreme\nbuttonClicked|itm") != string::npos) {
								int itemnr = atoi(cch.substr(67, cch.length() - 67).c_str()), itemcount = 0;
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									if (pInfo(peer)->tankIDName == world_->owner_name) {
										for (int i_ = 0; i_ < world_->sbox1.size(); i_++) {
											if (world_->sbox1[i_].x == pInfo(peer)->lastwrenchx and world_->sbox1[i_].y == pInfo(peer)->lastwrenchy) {
												itemcount++;
												if (itemnr == itemcount) {
													pInfo(peer)->lastchoosennr = itemnr;
													gamepacket_t p;
													p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[pInfo(peer)->lastwrenchb].name + "``|left|" + to_string(pInfo(peer)->lastwrenchb) + "|\nadd_textbox|You have `w" + to_string(world_->sbox1[i_].count) + " " + items[world_->sbox1[i_].id].name + "`` stored.|left|\nadd_textbox|Withdraw how many?|left|\nadd_text_input|itemcount||" + to_string(world_->sbox1[i_].count) + "|3|\nadd_spacer|small|\nadd_button|do_take|Remove Items|noflags|0|0|\nadd_button|cancel|Back|noflags|0|0|\nend_dialog|storageboxxtreme|Exit||\n"), p.CreatePacket(peer);
												}
											}
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|donation_box_edit\nitemid|") != string::npos) {
								int item = atoi(cch.substr(58, cch.length() - 58).c_str()), got = 0;
								modify_inventory(peer, item, got);
								if (got == 0) break;
								if (items[item].untradeable == 1 || item == 1424 || items[item].blockType == BlockTypes::FISH) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[```4You can't place that in the box, you need it!`7]``"), p.CreatePacket(peer);
								}
								else if (items[item].rarity == 1) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[```4This box only accepts items rarity 2+ or greater`7]``"), p.CreatePacket(peer);
								}
								else {
									pInfo(peer)->lastchoosenitem = item;
									gamepacket_t p;
									p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|" + items[item].name + "``|left|" + to_string(item) + "|\nadd_textbox|How many to put in the box as a gift? (Note: You will `4LOSE`` the items you give!)|left|\nadd_text_input|count|Count:|" + to_string(got) + "|5|\nadd_text_input|sign_text|Optional Note:||128|\nadd_spacer|small|\nadd_button|give|`4Give the item(s)``|noflags|0|0|\nadd_spacer|small|\nadd_button|cancel|`wCancel``|noflags|0|0|\nend_dialog|give_item|||\n");
									p.CreatePacket(peer);
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|donation_box_edit\nbuttonClicked|takeall\n") != string::npos) {
								bool took = false, fullinv = false;
								gamepacket_t p3;
								p3.Insert("OnTalkBubble"), p3.Insert(pInfo(peer)->netID);
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) break;
									WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
									if (!items[block_->fg].donation) break;
									for (int i_ = 0; i_ < block_->donates.size(); i_++) {
										int receive = block_->donates[i_].count;
										if (modify_inventory(peer, block_->donates[i_].item, block_->donates[i_].count) == 0) {
											took = true;
											gamepacket_t p;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->ispatrol == false) continue;
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9[PATROL] `0" + pInfo(peer)->tankIDName + " `oreceive `0" + items[block_->donates[i_].item].name + " `o" + to_string(receive) + "x from `0" + block_->donates[i_].name + "`oin `9" + pInfo(peer)->world + "`o.");
												p.CreatePacket(currentPeer);
											}
											p.Insert("OnConsoleMessage");
											p.Insert("`7[``" + pInfo(peer)->tankIDName + " receives `5" + to_string(receive) + "`` `w" + items[block_->donates[i_].item].name + "`` from `w" + block_->donates[i_].name + "``, how nice!`7]``");
											block_->donates.erase(block_->donates.begin() + i_);
											i_--;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
												p.CreatePacket(currentPeer);
											}
										}
										else fullinv = true;
									}
									if (block_->donates.size() == 0) {
										WorldBlock block_ = world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, &block_));
										BYTE* blc = raw + 56;
										form_visual(blc, block_, *world_, peer, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
											send_raw(currentPeer, 4, raw, 112 + alloc_(world_, &block_), ENET_PACKET_FLAG_RELIABLE);
										}
										delete[] raw, blc;
									}
								}
								if (fullinv) {
									p3.Insert("I don't have enough room in my backpack to get the item(s) from the box!");
									gamepacket_t p2;
									p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("`2(Couldn't get all of the gifts)``"), p2.CreatePacket(peer);
								}
								else if (took) p3.Insert("`2Box emptied.``");
								p3.CreatePacket(peer);
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|surge\n") {
								if (pInfo(peer)->lastwrenchb == 4296 || pInfo(peer)->lastwrenchb == 8558) {
									setstats(peer, rand() % 30, "", items[pInfo(peer)->lastwrenchb].name);
									pInfo(peer)->lastwrenchb = 0;
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|give_item\nbuttonClicked|give\n\ncount|") != string::npos) {
								int count = atoi(cch.substr(69, cch.length() - 69).c_str()), got = 0;
								string text = cch.substr(80 + to_string(count).length(), cch.length() - 80 + to_string(count).length()).c_str();
								replace_str(text, "\n", "");
								modify_inventory(peer, pInfo(peer)->lastchoosenitem, got);
								if (text.size() > 128 || got <= 0 || count <= 0 || count > items.size()) break;
								if (count > got || items[pInfo(peer)->lastchoosenitem].untradeable == 1 || pInfo(peer)->lastchoosenitem == 1424 || items[pInfo(peer)->lastchoosenitem].blockType == BlockTypes::FISH) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									if (count > got) p.Insert("You don't have that to give!");
									else p.Insert("`7[```4You can't place that in the box, you need it!`7]``");
									p.CreatePacket(peer);
								}
								else {
									string name_ = pInfo(peer)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										World* world_ = &worlds[p - worlds.begin()];
										WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
										if (!items[block_->fg].donation) break;
										Donate donate_{};
										donate_.item = pInfo(peer)->lastchoosenitem, donate_.count = count, donate_.name = pInfo(peer)->tankIDName, donate_.text = text;
										block_->donates.push_back(donate_);
										{
											PlayerMoving data_{};
											data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
											BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
											BYTE* blc = raw + 56;
											form_visual(blc, *block_, *world_, peer, false, true);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
											delete[] raw, blc;
										}

										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->ispatrol == false) continue;
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`9[PATROL] `0" + pInfo(peer)->tankIDName + " `oplace `0" + items[pInfo(peer)->lastchoosenitem].name + " `o" + to_string(count) + "x into `0" + items[pInfo(peer)->lastwrenchb].name + "`oin `9" + pInfo(peer)->world + "`o.");
											p.CreatePacket(currentPeer);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
											{
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert("`7[```5[```w" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "`` places `5" + to_string(count) + "`` `2" + items[pInfo(peer)->lastchoosenitem].name + "`` into the " + items[pInfo(peer)->lastwrenchb].name + "`5]```7]``");
												p.Insert(0);
												p.CreatePacket(currentPeer);
											}
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`7[```5[```w" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "`` places `5" + to_string(count) + "`` `2" + items[pInfo(peer)->lastchoosenitem].name + "`` into the " + items[pInfo(peer)->lastwrenchb].name + "`5]```7]``");
												p.CreatePacket(currentPeer);
											}
										}
										modify_inventory(peer, pInfo(peer)->lastchoosenitem, count *= -1);
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|storageboxxtreme\nbuttonClicked|cancel") != string::npos) {
								edit_tile(peer, pInfo(peer)->lastwrenchx, pInfo(peer)->lastwrenchy, 32);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|storageboxxtreme\nbuttonClicked|do_take\n\nitemcount|") != string::npos) {
								int itemnr = pInfo(peer)->lastchoosennr, countofremoval = atoi(cch.substr(83, cch.length() - 83).c_str()), removed = 0, itemcount = 0;
								removed = countofremoval;
								if (countofremoval <= 0) break;
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									if (pInfo(peer)->tankIDName == world_->owner_name) {
										for (int i_ = 0; i_ < world_->sbox1.size(); i_++) {
											if (world_->sbox1[i_].x == pInfo(peer)->lastwrenchx and world_->sbox1[i_].y == pInfo(peer)->lastwrenchy) {
												itemcount++;
												if (itemnr == itemcount and countofremoval < world_->sbox1[i_].count) {
													if (world_->sbox1[i_].count <= 0) break;
													world_->sbox1[i_].count -= removed;
													if (modify_inventory(peer, world_->sbox1[i_].id, countofremoval) == 0) {
														gamepacket_t p, p2;
														p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Removed `w" + to_string(removed) + " " + items[world_->sbox1[i_].id].name + "`` in " + items[pInfo(peer)->lastwrenchb].name + "."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
														p2.Insert("OnConsoleMessage"), p2.Insert("Removed `w" + to_string(removed) + " " + items[world_->sbox1[i_].id].name + "`` in the " + items[pInfo(peer)->lastwrenchb].name + "."), p2.CreatePacket(peer);
														PlayerMoving data_{};
														data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = world_->sbox1[i_].id, data_.punchY = pInfo(peer)->netID;
														int32_t to_netid = pInfo(peer)->netID;
														BYTE* raw = packPlayerMoving(&data_);
														raw[3] = 5;
														memcpy(raw + 8, &to_netid, 4);
														send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
														delete[] raw;
														i_ = world_->sbox1.size();
													}
												}
												else if (itemnr == itemcount and world_->sbox1[i_].count == countofremoval) {
													if (world_->sbox1[i_].count <= 0) break;
													if (modify_inventory(peer, world_->sbox1[i_].id, countofremoval) == 0) {
														gamepacket_t p, p2;
														p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Removed `w" + to_string(removed) + " " + items[world_->sbox1[i_].id].name + "`` in " + items[pInfo(peer)->lastwrenchb].name + "."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
														p2.Insert("OnConsoleMessage"), p2.Insert("Removed `w" + to_string(removed) + " " + items[world_->sbox1[i_].id].name + "`` in the " + items[pInfo(peer)->lastwrenchb].name + "."), p2.CreatePacket(peer);
														PlayerMoving data_{};
														data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
														data_.packetType = 19, data_.plantingTree = 500;
														data_.punchX = world_->sbox1[i_].id, data_.punchY = pInfo(peer)->netID;
														int32_t to_netid = pInfo(peer)->netID;
														BYTE* raw = packPlayerMoving(&data_);
														raw[3] = 5;
														memcpy(raw + 8, &to_netid, 4);
														send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
														delete[] raw;
														world_->sbox1.erase(world_->sbox1.begin() + i_);
														i_ = world_->sbox1.size();
													}
												}
											}
										}
									}
								}
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|builder_reward\n\n" || cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|fishing_reward\n\n" || cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|geiger_reward\n\n" || cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|farmer_reward\n\n" || cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|provider_reward\n\n") {
								if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|farmer_reward\n\n") farmer_reward_show(peer);
								if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|provider_reward\n\n")provider_reward_show(peer);
								if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|geiger_reward\n\n") geiger_reward_show(peer);
								if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|fishing_reward\n\n") 	fishing_reward_show(peer);
								if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|builder_reward\n\n")	builder_reward_show(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|personalize_profile\nbuttonClicked|save") != string::npos) {
								pInfo(peer)->show_uid = atoi(explode("\n", explode("checkbox_show_uid|", cch)[1])[0].c_str()) == 1 ? true : false;
								pInfo(peer)->Show_Achievements = atoi(explode("\n", explode("checkbox_show_achievements|", cch)[1])[0].c_str()) == 1 ? true : false;
								pInfo(peer)->Show_OwnedWorlds = atoi(explode("\n", explode("checkbox_show_ownworld_count|", cch)[1])[0].c_str()) == 1 ? true : false;
								pInfo(peer)->Show_AccountCreated = atoi(explode("\n", explode("checkbox_show_account_created|", cch)[1])[0].c_str()) == 1 ? true : false;
								if (pInfo(peer)->home_world != "") pInfo(peer)->Show_HomeWorld = atoi(explode("\n", explode("checkbox_show_homeworld|", cch)[1])[0].c_str()) == 1 ? true : false;
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|personalize_profile\nbuttonClicked|discard") != string::npos) {
								pelerbiji(peer, true, "kerucim", 0);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|personalize_profile\nbuttonClicked|preview") != string::npos) {
								pInfo(peer)->show_uid = atoi(explode("\n", explode("checkbox_show_uid|", cch)[1])[0].c_str()) == 1 ? true : false;
								pInfo(peer)->Show_Achievements = atoi(explode("\n", explode("checkbox_show_achievements|", cch)[1])[0].c_str()) == 1 ? true : false;
								pInfo(peer)->Show_OwnedWorlds = atoi(explode("\n", explode("checkbox_show_ownworld_count|", cch)[1])[0].c_str()) == 1 ? true : false;
								pInfo(peer)->Show_AccountCreated = atoi(explode("\n", explode("checkbox_show_account_created|", cch)[1])[0].c_str()) == 1 ? true : false;
								if (pInfo(peer)->home_world != "") pInfo(peer)->Show_HomeWorld = atoi(explode("\n", explode("checkbox_show_homeworld|", cch)[1])[0].c_str()) == 1 ? true : false;
								time_t s__;
								s__ = time(NULL);
								int days_ = int(s__) / (60 * 60 * 24);
								DialogBuilder preview("`o");
								preview.add_label_icon(true, 18, (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` `0(```2" + (pInfo(peer)->admin && pInfo(peer)->d_name.empty() ? "???" : to_string(pInfo(peer)->level)) + "```0)``" + (pInfo(peer)->show_uid ? format("(`4{}``)``", pInfo(peer)->playerUID) : ""))
									.add_spacer(false);
								if (pInfo(peer)->Show_OwnedWorlds) {
									preview.add_spacer(false)
										.add_label(false, "`1Owned Worlds:`` " + to_string(pInfo(peer)->worlds_owned.size()));
								}
								if (pInfo(peer)->Show_AccountCreated) {
									preview.add_spacer(false)
										.add_label(false, "`1Account Age: `` " + to_string(days_ - pInfo(peer)->account_created) + " days");
								}
								if (pInfo(peer)->home_world != "" && pInfo(peer)->Show_HomeWorld) {
									preview.add_spacer(false)
										.add_label(false, "`1Home World:``")
										.add_disabled_button("visit_home_world_" + pInfo(peer)->home_world, "`$Visit " + pInfo(peer)->home_world + "``");
								}
								preview.add_spacer(false)
									.add_disabled_button("trade", "`wTrade``")
									.add_textbox("(No Battle Leash equipped)")
									.add_disabled_button("friend_add", "`wAdd as friend``")
									.add_disabled_button("ignore_player", "`wIgnore Player``")
									.add_disabled_button("report_player", "`wReport Player``")
									.end_dialog("personalize_profile", "", "Back")
									.add_quick_exit();
								enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(preview.to_string()).pack());
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|personalize_profile") != string::npos) {
								SendDialogPersonalizeProfile(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|bouncer_dialog\nbuttonClicked|gems_") != string::npos) {
							int wl = 0, dl = 0;
							modify_inventory(peer, 242, wl);
							modify_inventory(peer, 1796, dl);
							DialogBuilder confirm;
							int itemChoosed = atoi(cch.substr(67, cch.length() - 67).c_str());
							switch (itemChoosed) {
							case 50000: {
								confirm.add_label_icon(true, 242, "`eBuy World Locks?``")
									.add_spacer(false)
									.add_textbox("How many World Locks do you want to buy, for 100.000 ė each?")
									.add_text_input(5, "how", "", "1")
									.add_smalltext("`9You have " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", " + to_string(dl) + " Diamond Lock." : ".") + "<CR>You also have " + fixint(pInfo(peer)->gems) + " ė in your pocket.``")
									.add_spacer(false)
									.add_button("bouncer_gemsbuy", "`9Purchase``")
									.add_button("bouncer_backButton", "`wNo Thanks``")
									.embed_data(false, "gemsbuy", to_string(itemChoosed));
								break;
							}
							case 100000: {
								confirm.add_label_icon(true, 1796, "`eBuy Diamond Locks?``")
									.add_spacer(false)
									.add_textbox("How many Diamond Locks do you want to buy, for 200.000 ė each?")
									.add_text_input(5, "how", "", "1")
									.add_smalltext("`9You have " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", " + to_string(dl) + " Diamond Lock." : ".") + "<CR>You also have " + fixint(pInfo(peer)->gems) + " ė in your pocket.``")
									.add_spacer(false)
									.add_button("bouncer_gemsbuy", "`9Purchase``")
									.add_button("bouncer_backButton", "`wNo Thanks``")
									.embed_data(false, "gemsbuy", to_string(itemChoosed));
								break;
							}
							case 250000: {
								confirm.add_label_icon(true, 10410, "`eBuy Legendary Locks?``")
									.add_spacer(false)
									.add_textbox("How many Legendary Locks do you want to buy, for 500.000 ė each?")
									.add_text_input(5, "how", "", "1")
									.add_smalltext("`9You have " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", " + to_string(dl) + " Diamond Lock." : ".") + "<CR>You also have " + fixint(pInfo(peer)->gems) + " ė in your pocket.``")
									.add_spacer(false)
									.add_button("bouncer_gemsbuy", "`9Purchase``")
									.add_button("bouncer_backButton", "`wNo Thanks``")
									.embed_data(false, "gemsbuy", to_string(itemChoosed));
								break;
							}
							case 500000: {
								confirm.add_label_icon(true, 4802, "`eBuy Royal Locks?``")
									.add_spacer(false)
									.add_textbox("How many Royal Locks do you want to buy, for 1.000.000 ė each?")
									.add_text_input(5, "how", "", "1")
									.add_smalltext("`9You have " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", " + to_string(dl) + " Diamond Lock." : ".") + "<CR>You also have " + fixint(pInfo(peer)->gems) + " ė in your pocket.``")
									.add_spacer(false)
									.add_button("bouncer_gemsbuy", "`9Purchase``")
									.add_button("bouncer_backButton", "`wNo Thanks``")
									.embed_data(false, "gemsbuy", to_string(itemChoosed));
								break;
							}
							case 1000000: {
								confirm.add_label_icon(true, 7188, "`eBuy Blue Gem Locks?``")
									.add_spacer(false)
									.add_textbox("How many Blue Gem Locks do you want to buy, for 2.000.000 ė each?")
									.add_text_input(5, "how", "", "1")
									.add_smalltext("`9You have " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", " + to_string(dl) + " Diamond Lock." : ".") + "<CR>You also have " + fixint(pInfo(peer)->gems) + " ė in your pocket.``")
									.add_spacer(false)
									.add_button("bouncer_gemsbuy", "`9Purchase``")
									.add_button("bouncer_backButton", "`wNo Thanks``")
									.embed_data(false, "gemsbuy", to_string(itemChoosed));
								break;
							}
							case 50: {
								confirm.add_label_icon(true, 242, "`eBuy World Locks?``")
									.add_spacer(false)
									.add_textbox("How many World Locks do you want to buy, for 50 ā each?")
									.add_text_input(5, "how", "", "1")
									.add_smalltext("`9You have " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", " + to_string(dl) + " Diamond Lock." : ".") + "<CR>You also have " + fixint(pInfo(peer)->gems) + " ė in your pocket.``")
									.add_spacer(false)
									.add_button("bouncer_gemsbuy", "`9Purchase``")
									.add_button("bouncer_backButton", "`wNo Thanks``")
									.embed_data(false, "gemsbuy", to_string(itemChoosed));
								break;
							}
							case 100: {
								confirm.add_label_icon(true, 1796, "`eBuy Diamond Locks?``")
									.add_spacer(false)
									.add_textbox("How many Diamond Locks do you want to buy, for 100 ā each?")
									.add_text_input(5, "how", "", "1")
									.add_smalltext("`9You have " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", " + to_string(dl) + " Diamond Lock." : ".") + "<CR>You also have " + fixint(pInfo(peer)->gems) + " ė in your pocket.``")
									.add_spacer(false)
									.add_button("bouncer_gemsbuy", "`9Purchase``")
									.add_button("bouncer_backButton", "`wNo Thanks``")
									.embed_data(false, "gemsbuy", to_string(itemChoosed));
								break;
							}
							case 250: {
								confirm.add_label_icon(true, 10410, "`eBuy Legendary Locks?``")
									.add_spacer(false)
									.add_textbox("How many Legendary Locks do you want to buy, for 250 ā each?")
									.add_text_input(5, "how", "", "1")
									.add_smalltext("`9You have " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", " + to_string(dl) + " Diamond Lock." : ".") + "<CR>You also have " + fixint(pInfo(peer)->gems) + " ė in your pocket.``")
									.add_spacer(false)
									.add_button("bouncer_gemsbuy", "`9Purchase``")
									.add_button("bouncer_backButton", "`wNo Thanks``")
									.embed_data(false, "gemsbuy", to_string(itemChoosed));
								break;
							}
							case 500: {
								confirm.add_label_icon(true, 4802, "`eBuy Royal Locks?``")
									.add_spacer(false)
									.add_textbox("How many Royal Locks do you want to buy, for 500 ā each?")
									.add_text_input(5, "how", "", "1")
									.add_smalltext("`9You have " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", " + to_string(dl) + " Diamond Lock." : ".") + "<CR>You also have " + fixint(pInfo(peer)->gems) + " ė in your pocket.``")
									.add_spacer(false)
									.add_button("bouncer_gemsbuy", "`9Purchase``")
									.add_button("bouncer_backButton", "`wNo Thanks``")
									.embed_data(false, "gemsbuy", to_string(itemChoosed));
								break;
							}
							case 1000: {
								confirm.add_label_icon(true, 7188, "`eBuy Blue Gem Locks?``")
									.add_spacer(false)
									.add_textbox("How many Blue Gem Locks do you want to buy, for 1000 ā each?")
									.add_text_input(5, "how", "", "1")
									.add_smalltext("`9You have " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", " + to_string(dl) + " Diamond Lock." : ".") + "<CR>You also have " + fixint(pInfo(peer)->gems) + " ė in your pocket.``")
									.add_spacer(false)
									.add_button("bouncer_gemsbuy", "`9Purchase``")
									.add_button("bouncer_backButton", "`wNo Thanks``")
									.embed_data(false, "gemsbuy", to_string(itemChoosed));
								break;
							}
							default: break;
							}
							confirm.add_quick_exit();
							enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(confirm.to_string()).pack());
							break;
						}
						else if (cch.find("buttonClicked|bouncer_gemsbuy") != string::npos) {
							int addItem = 0, removeItem = 0, itemPrice = 0, totalPrice = 0, allwl = 0, wl = 0, dl = 0, cl = 0;
							int purchaseAmount = atoi(explode("\n", explode("how|", cch)[1])[0].c_str());
							if (purchaseAmount <= 0 || purchaseAmount > 200) continue;
							if (purchaseAmount == 0) break;
							int itemKind = atoi(explode("\n", explode("gemsbuy|", cch)[1])[0].c_str());
							modify_inventory(peer, 242, wl);
							modify_inventory(peer, 1796, dl);
							modify_inventory(peer, 7188, cl);
							allwl = wl + (dl * 100);
							int allcl = cl * 10000;
							switch (itemKind) {
							case 50: {
								itemPrice = 50;
								totalPrice = itemPrice *= purchaseAmount;
								if (allwl >= totalPrice || allcl >= totalPrice && totalPrice > 20000) {
									int c_ = purchaseAmount;
									if (modify_inventory(peer, 242, c_) == 0) {
										if (totalPrice <= 20000) {
											if (wl >= totalPrice) modify_inventory(peer, 242, totalPrice *= -1);
											else {
												modify_inventory(peer, 242, wl *= -1);
												modify_inventory(peer, 1796, dl *= -1);
												int givedl = (allwl - totalPrice) / 100;
												int givewl = (allwl - totalPrice) - (givedl * 100);
												modify_inventory(peer, 242, givewl);
												modify_inventory(peer, 1796, givedl);
											}
										}
										else {
											int removebgl = (totalPrice / 10000) * -1;
											modify_inventory(peer, 7188, removebgl);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world == pInfo(currentPeer)->world) {
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9[" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " bought " + to_string(purchaseAmount) + " " + items[242].name + " for " + to_string(totalPrice) + " World Lock]");
												p.CreatePacket(currentPeer);
												packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
											}
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No inventory space.");
										p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`9You don't have enough wls!``");
									p.CreatePacket(peer);
								}
								break;
							}
							case 100: {
								itemPrice = 100;
								totalPrice = itemPrice *= purchaseAmount;
								if (allwl >= totalPrice || allcl >= totalPrice && totalPrice > 20000) {
									int c_ = purchaseAmount;
									if (modify_inventory(peer, 1796, c_) == 0) {
										if (totalPrice <= 20000) {
											if (wl >= totalPrice) modify_inventory(peer, 242, totalPrice *= -1);
											else {
												modify_inventory(peer, 242, wl *= -1);
												modify_inventory(peer, 1796, dl *= -1);
												int givedl = (allwl - totalPrice) / 100;
												int givewl = (allwl - totalPrice) - (givedl * 100);
												modify_inventory(peer, 242, givewl);
												modify_inventory(peer, 1796, givedl);
											}
										}
										else {
											int removebgl = (totalPrice / 10000) * -1;
											modify_inventory(peer, 7188, removebgl);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world == pInfo(currentPeer)->world) {
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9[" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " bought " + to_string(purchaseAmount) + " " + items[1796].name + " for " + to_string(totalPrice) + " World Lock]");
												p.CreatePacket(currentPeer);
												packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
											}
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No inventory space.");
										p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`9You don't have enough wls!``");
									p.CreatePacket(peer);
								}
								break;
							}
							case 250: {
								itemPrice = 250;
								totalPrice = itemPrice *= purchaseAmount;
								if (allwl >= totalPrice || allcl >= totalPrice && totalPrice > 20000) {
									int c_ = purchaseAmount;
									if (modify_inventory(peer, 10410, c_) == 0) {
										if (totalPrice <= 20000) {
											if (wl >= totalPrice) modify_inventory(peer, 242, totalPrice *= -1);
											else {
												modify_inventory(peer, 242, wl *= -1);
												modify_inventory(peer, 1796, dl *= -1);
												int givedl = (allwl - totalPrice) / 100;
												int givewl = (allwl - totalPrice) - (givedl * 100);
												modify_inventory(peer, 242, givewl);
												modify_inventory(peer, 1796, givedl);
											}
										}
										else {
											int removebgl = (totalPrice / 10000) * -1;
											modify_inventory(peer, 7188, removebgl);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world == pInfo(currentPeer)->world) {
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9[" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " bought " + to_string(purchaseAmount) + " " + items[10410].name + " for " + to_string(totalPrice) + " World Lock]");
												p.CreatePacket(currentPeer);
												packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
											}
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No inventory space.");
										p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`9You don't have enough wls!``");
									p.CreatePacket(peer);
								}
								break;
							}
							case 500: {
								itemPrice = 500;
								totalPrice = itemPrice *= purchaseAmount;
								if (allwl >= totalPrice || allcl >= totalPrice && totalPrice > 20000) {
									int c_ = purchaseAmount;
									if (modify_inventory(peer, 4802, c_) == 0) {
										if (totalPrice <= 20000) {
											if (wl >= totalPrice) modify_inventory(peer, 242, totalPrice *= -1);
											else {
												modify_inventory(peer, 242, wl *= -1);
												modify_inventory(peer, 1796, dl *= -1);
												int givedl = (allwl - totalPrice) / 100;
												int givewl = (allwl - totalPrice) - (givedl * 100);
												modify_inventory(peer, 242, givewl);
												modify_inventory(peer, 1796, givedl);
											}
										}
										else {
											int removebgl = (totalPrice / 10000) * -1;
											modify_inventory(peer, 7188, removebgl);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world == pInfo(currentPeer)->world) {
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9[" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " bought " + to_string(purchaseAmount) + " " + items[4802].name + " for " + to_string(totalPrice) + " World Lock]");
												p.CreatePacket(currentPeer);
												packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
											}
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No inventory space.");
										p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`9You don't have enough wls!``");
									p.CreatePacket(peer);
								}
								break;
							}
							case 1000: {
								itemPrice = 1000;
								totalPrice = itemPrice *= purchaseAmount;
								if (allwl >= totalPrice || allcl >= totalPrice && totalPrice > 20000) {
									int c_ = purchaseAmount;
									if (modify_inventory(peer, 7188, c_) == 0) {
										if (totalPrice <= 20000) {
											if (wl >= totalPrice) modify_inventory(peer, 242, totalPrice *= -1);
											else {
												modify_inventory(peer, 242, wl *= -1);
												modify_inventory(peer, 1796, dl *= -1);
												int givedl = (allwl - totalPrice) / 100;
												int givewl = (allwl - totalPrice) - (givedl * 100);
												modify_inventory(peer, 242, givewl);
												modify_inventory(peer, 1796, givedl);
											}
										}
										else {
											int removebgl = (totalPrice / 10000) * -1;
											modify_inventory(peer, 7188, removebgl);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world == pInfo(currentPeer)->world) {
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9[" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " bought " + to_string(purchaseAmount) + " " + items[7188].name + " for " + to_string(totalPrice) + " World Lock]");
												p.CreatePacket(currentPeer);
												packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
											}
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No inventory space.");
										p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`9You don't have enough wls!``");
									p.CreatePacket(peer);
								}
								break;
							}
							case 50000: {
								itemPrice = 100000;
								totalPrice = itemPrice *= purchaseAmount;
								if (pInfo(peer)->gems >= totalPrice) {
									int c_ = purchaseAmount;
									if (modify_inventory(peer, 242, c_) == 0) {
										{
											gamepacket_t p;
											p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems -= totalPrice), p.Insert(1), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
											if (pInfo(peer)->supp >= 2) p.Insert((float)33796, (float)1, (float)0);
											p.CreatePacket(peer);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world == pInfo(currentPeer)->world) {
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9[" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " bought " + to_string(purchaseAmount) + " " + items[242].name + " for " + fixint(totalPrice) + " ė]");
												p.CreatePacket(currentPeer);
												packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
											}
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No Inventory Space");
										p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`9You don't have enough gems!``");
									p.CreatePacket(peer);
								}
								break;
							}
							case 100000: {
								itemPrice = 200000;
								totalPrice = itemPrice *= purchaseAmount;
								if (pInfo(peer)->gems >= totalPrice) {
									int c_ = purchaseAmount;
									if (modify_inventory(peer, 1796, c_) == 0) {
										{
											gamepacket_t p;
											p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems -= totalPrice), p.Insert(1), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
											if (pInfo(peer)->supp >= 2) p.Insert((float)33796, (float)1, (float)0);
											p.CreatePacket(peer);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world == pInfo(currentPeer)->world) {
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9[" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " bought " + to_string(purchaseAmount) + " " + items[1796].name + " for " + fixint(totalPrice) + " ė]");
												p.CreatePacket(currentPeer);
												packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
											}
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No Inventory Space");
										p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`9You don't have enough gems!``");
									p.CreatePacket(peer);
								}
								break;
							}
							case 250000: {
								itemPrice = 500000;
								totalPrice = itemPrice *= purchaseAmount;
								if (pInfo(peer)->gems >= totalPrice) {
									int c_ = purchaseAmount;
									if (modify_inventory(peer, 10410, c_) == 0) {
										{
											gamepacket_t p;
											p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems -= totalPrice), p.Insert(1), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
											if (pInfo(peer)->supp >= 2) p.Insert((float)33796, (float)1, (float)0);
											p.CreatePacket(peer);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world == pInfo(currentPeer)->world) {
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9[" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " bought " + to_string(purchaseAmount) + " " + items[10410].name + " for " + fixint(totalPrice) + " ė]");
												p.CreatePacket(currentPeer);
												packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
											}
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No Inventory Space");
										p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`9You don't have enough gems!``");
									p.CreatePacket(peer);
								}
								break;
							}
							case 500000: {
								itemPrice = 1000000;
								totalPrice = itemPrice *= purchaseAmount;
								if (pInfo(peer)->gems >= totalPrice) {
									int c_ = purchaseAmount;
									if (modify_inventory(peer, 4802, c_) == 0) {
										{
											gamepacket_t p;
											p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems -= totalPrice), p.Insert(1), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
											if (pInfo(peer)->supp >= 2) p.Insert((float)33796, (float)1, (float)0);
											p.CreatePacket(peer);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world == pInfo(currentPeer)->world) {
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9[" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " bought " + to_string(purchaseAmount) + " " + items[4802].name + " for " + fixint(totalPrice) + " ė]");
												p.CreatePacket(currentPeer);
												packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
											}
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No Inventory Space");
										p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`9You don't have enough gems!``");
									p.CreatePacket(peer);
								}
								break;
							}
							case 1000000: {
								itemPrice = 2000000;
								totalPrice = itemPrice *= purchaseAmount;
								if (pInfo(peer)->gems >= totalPrice) {
									int c_ = purchaseAmount;
									if (modify_inventory(peer, 7188, c_) == 0) {
										{
											gamepacket_t p;
											p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems -= totalPrice), p.Insert(1), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
											if (pInfo(peer)->supp >= 2) p.Insert((float)33796, (float)1, (float)0);
											p.CreatePacket(peer);
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world == pInfo(currentPeer)->world) {
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`9[" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " bought " + to_string(purchaseAmount) + " " + items[7188].name + " for " + fixint(totalPrice) + " ė]");
												p.CreatePacket(currentPeer);
												packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
											}
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("No Inventory Space");
										p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`9You don't have enough gems!``");
									p.CreatePacket(peer);
								}
								break;
							}
							default: continue;
							}
							break;
						}
						else if (cch.find("buttonClicked|bouncer_backButton") != string::npos) {
							DialogBuilder bouncer;
							int wl = 0, dl = 0;
							int GemsPrice = 0, LockPrice = 0;
							modify_inventory(peer, 242, wl);
							modify_inventory(peer, 1796, dl);
							bouncer.add_label_icon(true, 12314, "The Bouncer")
								.add_smalltext("Ho there, friend! Bouncer's my name, and jewelry are my game. I Love 'em all, Gems even Locks! If you can part with some jewels, I'll give you something special in return. Whaddya say?")
								.add_smalltext("" + (wl + dl != 0 ? "`9Smells like you are carrying " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", and " + to_string(dl) + " Diamond Lock" : "") + "``" : "`9Hmm, smells like you don't care any world locks``") + "")
								.add_smalltext("`9You've also got " + fixint(pInfo(peer)->gems) + " ė on your pocket``")
								.add_spacer(false)
								.add_label_icon(false, 9436, "Purchase with Gems");
							// The Bouncer List
							for (int i = 0; i < items.size(); i++) {
								if (i == 242) GemsPrice = 50000, bouncer.add_static_icon_button("gems_" + to_string(GemsPrice) + "", i, items[i].ori_name, "");
								if (i == 1796) GemsPrice = 100000, bouncer.add_static_icon_button("gems_" + to_string(GemsPrice) + "", i, items[i].ori_name, "");
								if (i == 10410) GemsPrice = 250000, bouncer.add_static_icon_button("gems_" + to_string(GemsPrice) + "", i, items[i].ori_name, "");
								if (i == 4802) GemsPrice = 500000, bouncer.add_static_icon_button("gems_" + to_string(GemsPrice) + "", i, items[i].ori_name, "");
								if (i == 7188) GemsPrice = 1000000, bouncer.add_static_icon_button("gems_" + to_string(GemsPrice) + "", i, items[i].ori_name, "");
							}
							bouncer.end_list()
								//.add_label_icon(false, 242, "Purchase with Locks");
							//for (int i = 0; i < items.size(); i++) {
								//if (i == 242) LockPrice = 50, bouncer.add_static_icon_button("gems_" + to_string(LockPrice) + "", i, items[i].ori_name, "");
								//if (i == 1796) LockPrice = 100, bouncer.add_static_icon_button("gems_" + to_string(LockPrice) + "", i, items[i].ori_name, "");
								//if (i == 10410) LockPrice = 250, bouncer.add_static_icon_button("gems_" + to_string(LockPrice) + "", i, items[i].ori_name, "");
								//if (i == 4802) LockPrice = 500, bouncer.add_static_icon_button("gems_" + to_string(LockPrice) + "", i, items[i].ori_name, "");
								//if (i == 7188) LockPrice = 1000, bouncer.add_static_icon_button("gems_" + to_string(LockPrice) + "", i, items[i].ori_name, "");
							//}
							// The end of Bouncer List
							//bouncer.end_list()
								.end_dialog("bouncer_dialog", "Exit", "");
							enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(bouncer.to_string()).pack());
							break;
						}
						
							else if (cch == "action|dialog_return\ndialog_name|backpack_menu\nbuttonClicked|backpack_upgrade\n\n") {
								if (pInfo(peer)->gems >= (1000 * ((pInfo(peer)->b_l * pInfo(peer)->b_l) + 25))*2) {
									if (pInfo(peer)->b_l * 10 > 200) {
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("You have reached max slots!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
									}
									else {
										pInfo(peer)->gems -= (1000 * ((pInfo(peer)->b_l * pInfo(peer)->b_l) + 25))*2;
										pInfo(peer)->b_l++;
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										gamepacket_t p;
										p.Insert("OnSetBux");
										p.Insert(pInfo(peer)->gems);
										p.Insert(0);
										p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
										if (pInfo(peer)->supp >= 2) {
											p.Insert((float)33796, (float)1, (float)0);
										}
										p.CreatePacket(peer);
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("Congratulations! You have upgraded your Backpack!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
										backpack_show(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(peer);
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|backpack_menu\nbuttonClicked|") != string::npos) {
								int choosen_item = atoi(cch.substr(61, cch.length() - 61).c_str());
								if (choosen_item >= pInfo(peer)->bp.size() || choosen_item > 200 || choosen_item > pInfo(peer)->b_l * 10) break;
								for (int i_ = 0; i_ < pInfo(peer)->bp.size(); i_++) {
									if (choosen_item == i_) {
										if (pInfo(peer)->bp[choosen_item].first <= 0 || pInfo(peer)->bp[choosen_item].first >= items.size()) break;
										int pickedup = pInfo(peer)->bp[choosen_item].second;
										if (modify_inventory(peer, pInfo(peer)->bp[choosen_item].first, pInfo(peer)->bp[choosen_item].second) == 0) {
											{
												gamepacket_t p, p2;
												p.Insert("OnConsoleMessage"), p.Insert("You picked up " + to_string(pickedup) + " " + items[pInfo(peer)->bp[choosen_item].first].name + "."), p.CreatePacket(peer);
												p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p.Insert("You picked up " + to_string(pickedup) + " " + items[pInfo(peer)->bp[choosen_item].first].name + "."), p2.CreatePacket(peer);
											}
											PlayerMoving data_{};
											data_.packetType = 19, data_.punchX = pInfo(peer)->bp[choosen_item].first, data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
											int32_t to_netid = pInfo(peer)->netID;
											BYTE* raw = packPlayerMoving(&data_);
											raw[3] = 5;
											memcpy(raw + 8, &to_netid, 4);
											send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											delete[]raw;
											pInfo(peer)->bp.erase(pInfo(peer)->bp.begin() + i_);
										}
										else {
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have enough inventory space!"), p.CreatePacket(peer);
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|backpack_menu\nitemid|") != string::npos) {
								if (pInfo(peer)->bp.size() <= pInfo(peer)->b_l * 10) {
									int got = 0, item = atoi(cch.substr(54, cch.length() - 54).c_str());
									modify_inventory(peer, item, got);
									if (got <= 0) break;
									if (items[item].untradeable == 1 || item == 1424 || item == 5816 || items[item].blockType == BlockTypes::LOCK) {
										//|| items[item].blockType == BlockTypes::CONSUMABLE || items[item].blockType == BlockTypes::RANDOM_BLOCK || items[item].blockType == BlockTypes::BACKGROUND || items[item].blockType == BlockTypes::CLOTHING || items[item].blockType == BlockTypes::FOREGROUND || items[item].blockType == BlockTypes::SEED || items[item].blockType == BlockTypes::WEATHER || items[item].blockType == BlockTypes::BEDROCK) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("You can't store Untradeable items there!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(peer);
									}
									else {
										pInfo(peer)->bp.push_back(make_pair(item, got));
										modify_inventory(peer, item, got *= -1);
										PlayerMoving data_{};
										data_.packetType = 19, data_.punchX = item, data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
										int32_t to_netid = pInfo(peer)->netID;
										BYTE* raw = packPlayerMoving(&data_);
										raw[3] = 5;
										memcpy(raw + 8, &to_netid, 4);
										send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										delete[]raw;
										backpack_show(peer);
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|dialog_eq_aura\nbutton_item_selection|") != string::npos) {
								int item = atoi(cch.substr(70, cch.length() - 70).c_str());
								if (item > 0 && item < items.size()) {
									if (items[item].toggleable) {
										pInfo(peer)->eq_a_1 = item;
										gamepacket_t p;
										p.Insert("OnDialogRequest");
										p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEQ Aura``|left|12634|\nadd_spacer|small|\nadd_textbox|Play music wherever you are with the EQ Aura! Choose a musical block from your inventory to play the song.|left|\nadd_spacer|small|" + (string(pInfo(peer)->eq_a_1 != 0 ? "\nadd_label_with_icon|small|`w" + items[pInfo(peer)->eq_a_1].name + "``|left|" + to_string(pInfo(peer)->eq_a_1) + "|\nadd_spacer|small|" : "")) + "\nadd_item_picker|button_item_selection|`wChange Block Item``|Choose Musical Block Item!|\nadd_button|restore_default|`wRemove Block Item``|noflags|0|0|\nadd_spacer|small|\nadd_spacer|small|\nend_dialog|dialog_eq_aura|Cancel|Update|\nadd_quick_exit|");
										p.CreatePacket(peer);
									}
									else {
										gamepacket_t p;
										p.Insert("OnDialogRequest");
										p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEQ Aura``|left|12634|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|`4Invalid item! You can only use musical block items! Please choose something else.``|left|\nadd_spacer|small|\nadd_textbox|Play music wherever you are with the EQ Aura! Choose a musical block from your inventory to play the song.|left|\nadd_spacer|small|" + (string(pInfo(peer)->eq_a != 0 ? "\nadd_label_with_icon|small|`w" + items[pInfo(peer)->eq_a].name + "``|left|" + to_string(pInfo(peer)->eq_a) + "|\nadd_spacer|small|" : "")) + "\nadd_item_picker|button_item_selection|`wChange Block Item``|Choose Musical Block Item!|\nadd_button|restore_default|`wRemove Block Item``|noflags|0|0|\nadd_spacer|small|\nadd_spacer|small|\nend_dialog|dialog_eq_aura|Cancel|Update|\nadd_quick_exit|");
										p.CreatePacket(peer);
									}
								}
								break;
						}
							else if (cch.find("action|dialog_return\ndialog_name|dialog_eq_aura\nbuttonClicked|restore_default") != string::npos) {
								pInfo(peer)->eq_a_1 = 0;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEQ Aura``|left|12634|\nadd_spacer|small|\nadd_textbox|Play music wherever you are with the EQ Aura! Choose a musical block from your inventory to play the song.|left|\nadd_spacer|small|" + (string(pInfo(peer)->eq_a_1 != 0 ? "\nadd_label_with_icon|small|`w" + items[pInfo(peer)->eq_a_1].name + "``|left|" + to_string(pInfo(peer)->eq_a_1) + "|\nadd_spacer|small|" : "")) + "\nadd_item_picker|button_item_selection|`wChange Block Item``|Choose Musical Block Item!|\nadd_button|restore_default|`wRemove Block Item``|noflags|0|0|\nadd_spacer|small|\nadd_spacer|small|\nend_dialog|dialog_eq_aura|Cancel|Update|\nadd_quick_exit|");
								p.CreatePacket(peer);
								break;
						}
							if (cch.find("action|dialog_return\ndialog_name|spotify_dialog\nbuttonClicked|play_") != string::npos) {
								int song = atoi(cch.substr(67, cch.length() - 67).c_str());
								pInfo(peer)->spotify = song;
								spotify_update(peer);
								spotify_menu(peer);
								break;
							}
							/*if (cch.find("action|dialog_return\ndialog_name|spotify_dialog\nbuttonClicked|play2") != string::npos) {
								pInfo(peer)->spotify = 2;
								spotify_update(peer);
								spotify_menu(peer);
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|spotify_dialog\nbuttonClicked|play3") != string::npos) {
								pInfo(peer)->spotify = 3;
								spotify_update(peer);
								spotify_menu(peer);
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|spotify_dialog\nbuttonClicked|play4") != string::npos) {
								pInfo(peer)->spotify = 4;
								spotify_update(peer);
								spotify_menu(peer);
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|spotify_dialog\nbuttonClicked|play5") != string::npos) {
								pInfo(peer)->spotify = 5;
								spotify_update(peer);
								spotify_menu(peer);
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|spotify_dialog\nbuttonClicked|play6") != string::npos) {
								pInfo(peer)->spotify = 6;
								spotify_update(peer);
								spotify_menu(peer);
								break;
							}*/
							else if (cch.find("action|dialog_return\ndialog_name|spotify_dialog\nbuttonClicked|stop") != string::npos) {
								pInfo(peer)->spotify = 0;
								Algorithm::send_console(peer, "Reenter world if it doesn't stopped");
								spotify_update(peer);
								spotify_menu(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|dialog_eq_aura") != string::npos) {
								if (pInfo(peer)->eq_a_1 != 0 && !pInfo(peer)->eq_a_update) pInfo(peer)->eq_a = pInfo(peer)->eq_a_1, pInfo(peer)->eq_a_update = true;
								if (pInfo(peer)->eq_a_1 == 0) pInfo(peer)->eq_a_1 = 0, pInfo(peer)->eq_a = 0;
								update_clothes(peer);
								break;
						}
							else if (cch.find("action|dialog_return\ndialog_name|\nbuttonClicked|trans_") != string::npos) {
								int item = atoi(cch.substr(54, cch.length() - 54).c_str());
								if (item <= 0 || item >= items.size()) break;
								if (item == 256) {
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnFlagMay2019"), p.Insert(256);
									pInfo(peer)->flagmay = 256;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (pInfo(peer)->world == pInfo(currentPeer)->world) p.CreatePacket(currentPeer);
									}
								}
								int got = 0;
								modify_inventory(peer, item, got);
								if (got == 0) break;
								if (items[item].flagmay == 256) break;
								gamepacket_t p(0, pInfo(peer)->netID);
								pInfo(peer)->flagmay = items[item].flagmay;
								p.Insert("OnFlagMay2019"), p.Insert(items[item].flagmay);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (pInfo(peer)->world == pInfo(currentPeer)->world) p.CreatePacket(currentPeer);
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|t_claimreward") != string::npos) {
								int reward = atoi(cch.substr(72, cch.length() - 72).c_str()), lvl = 0, count = 1;
								vector<int> list{ 98, 228, 1746, 1778, 1830, 5078, 1966, 6948, 6946, 4956 };
								if (reward <= 0 || reward > list.size()) break;
								if (list[reward - 1] == 228 || list[reward - 1] == 1746 || list[reward - 1] == 1778) count = 200;
								if (find(pInfo(peer)->t_p.begin(), pInfo(peer)->t_p.end(), lvl = reward * 5) == pInfo(peer)->t_p.end()) {
									if (pInfo(peer)->t_lvl >= lvl) {
										if (modify_inventory(peer, list[reward - 1], count) == 0) {
											pInfo(peer)->t_p.push_back(lvl);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											{
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert("Congratulations! You have received your Farmer Reward!");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(peer);
											}
											PlayerMoving data_{};
											data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
											delete[] raw;
											{
												PlayerMoving data_{};
												data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16, data_.packetType = 19, data_.plantingTree = 100, data_.punchX = list[reward - 1], data_.punchY = pInfo(peer)->netID;
												int32_t to_netid = pInfo(peer)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 5;
												memcpy(raw + 8, &to_netid, 4);
												send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												delete[] raw;
											}
											farmer_reward_show(peer);
										}
										else {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("You have full inventory space!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|view_inventory\nbuttonClicked|") != string::npos) {
								if (pInfo(peer)->coown) {
								int item = atoi(cch.substr(62, cch.length() - 62).c_str()), got = 0;
								pInfo(peer)->choosenitem = item;
								if (item <= 0 || item > items.size()) break;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
										modify_inventory(currentPeer, pInfo(peer)->choosenitem, got);
										gamepacket_t p;
										p.Insert("OnDialogRequest");
										p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Take`` `w" + items[pInfo(peer)->choosenitem].name + " from`` `#" + pInfo(currentPeer)->tankIDName + "``|left|" + to_string(pInfo(peer)->choosenitem) + "|\nadd_textbox|How many to `4take``? (player has " + to_string(got) + ")|left|\nadd_text_input|count||" + to_string(got) + "|5|\nend_dialog|take_item|Cancel|OK|");
										p.CreatePacket(peer);
									}
								}
							}
							break;
						}
						else if (cch.find("action|dialog_return\ndialog_name|take_item\ncount|") != string::npos) {
							if (pInfo(peer)->superdev) {
								int count = atoi(cch.substr(49, cch.length() - 49).c_str()), receive = atoi(cch.substr(49, cch.length() - 49).c_str());
								int remove = count * -1;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
										if (count <= 0 || count > 200) break;
										if (modify_inventory(peer, pInfo(peer)->choosenitem, count) == 0) {
											int total = 0;
											modify_inventory(currentPeer, pInfo(peer)->choosenitem, total += remove);
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("Collected `w" + to_string(receive) + " " + items[pInfo(peer)->choosenitem].name + "``." + (items[pInfo(peer)->choosenitem].rarity > 363 ? "" : " Rarity: `w" + to_string(items[pInfo(peer)->choosenitem].rarity) + "``") + "");
											p.CreatePacket(peer);
										}
									}
								}
							}
							break;
						}						
							else if (cch.find("action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|p_claimreward") != string::npos) {
								int reward = atoi(cch.substr(72, cch.length() - 72).c_str()), lvl = 0, count = 1;
								vector<int> list{ 1008,1044,872,10450,870,5084,876,6950,6952,1674 };
								if (reward <= 0 || reward > list.size()) break;
								if (list[reward - 1] == 1008) count = 5;
								if (list[reward - 1] == 1044) count = 50;
								if (list[reward - 1] == 872) count = 200;
								if (list[reward - 1] == 10450) count = 3;
								if (find(pInfo(peer)->p_p.begin(), pInfo(peer)->p_p.end(), lvl = reward * 5) == pInfo(peer)->p_p.end()) {
									if (pInfo(peer)->p_lvl >= lvl) {
										if (modify_inventory(peer, list[reward - 1], count) == 0) {
											pInfo(peer)->p_p.push_back(lvl);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											{
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert("Congratulations! You have received your Provider Reward!");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(peer);
											}
											PlayerMoving data_{};
											data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
											delete[] raw;
											{
												PlayerMoving data_{};
												data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16, data_.packetType = 19, data_.plantingTree = 100, data_.punchX = list[reward - 1], data_.punchY = pInfo(peer)->netID;
												int32_t to_netid = pInfo(peer)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 5;
												memcpy(raw + 8, &to_netid, 4);
												send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												delete[] raw;
											}
											provider_reward_show(peer);
										}
										else {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("You have full inventory space!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|g_claimreward") != string::npos) {
							int reward = atoi(cch.substr(72, cch.length() - 72).c_str()), lvl = 0, count = 1;
							vector<int> list{ 4654,262,826,828,9712,3146,2266,5072,5070,9716 };
							if (reward <= 0 || reward > list.size()) break;
							if (list[reward - 1] == 262 || list[reward - 1] == 826 || list[reward - 1] == 828) count = 50;
							if (list[reward - 1] == 3146) count = 10;
							if (find(pInfo(peer)->g_p.begin(), pInfo(peer)->g_p.end(), lvl = reward * 5) == pInfo(peer)->g_p.end()) {
								if (pInfo(peer)->g_lvl >= lvl) {
									if (modify_inventory(peer, list[reward - 1], count) == 0) {
										pInfo(peer)->g_p.push_back(lvl);
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("Congratulations! You have received your Geiger Hunting Reward!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
										PlayerMoving data_{};
										data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
										BYTE* raw = packPlayerMoving(&data_);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
										delete[] raw;
										{
											PlayerMoving data_{};
											data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16, data_.packetType = 19, data_.plantingTree = 100, data_.punchX = list[reward - 1], data_.punchY = pInfo(peer)->netID;
											int32_t to_netid = pInfo(peer)->netID;
											BYTE* raw = packPlayerMoving(&data_);
											raw[3] = 5;
											memcpy(raw + 8, &to_netid, 4);
											send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											delete[] raw;
										}
										geiger_reward_show(peer);
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("You have full inventory space!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(peer);
									}
								}
							}
							break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|f_claimreward") != string::npos) {
							int reward = atoi(cch.substr(72, cch.length() - 72).c_str()), lvl = 0, count = 1;
							vector<int> list{ 3010, 3018, 3020, 3044, 5740, 3042, 3098, 3100, 3040, 10262 };
							if (reward <= 0 || reward > list.size()) break;
							if (list[reward - 1] == 3018) count = 200;
							if (list[reward - 1] == 3020 || list[reward - 1] == 3098) count = 50;
							if (list[reward - 1] == 3044) count = 25;
							if (find(pInfo(peer)->ff_p.begin(), pInfo(peer)->ff_p.end(), lvl = reward * 5) == pInfo(peer)->ff_p.end()) {
								if (pInfo(peer)->ff_lvl >= lvl) {
									if (modify_inventory(peer, list[reward - 1], count) == 0) {
										pInfo(peer)->ff_p.push_back(lvl);
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("Congratulations! You have received your Fishing Reward!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
										PlayerMoving data_{};
										data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
										BYTE* raw = packPlayerMoving(&data_);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
										delete[] raw;
										{
											PlayerMoving data_{};
											data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16, data_.packetType = 19, data_.plantingTree = 100, data_.punchX = list[reward - 1], data_.punchY = pInfo(peer)->netID;
											int32_t to_netid = pInfo(peer)->netID;
											BYTE* raw = packPlayerMoving(&data_);
											raw[3] = 5;
											memcpy(raw + 8, &to_netid, 4);
											send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											delete[] raw;
										}
										fishing_reward_show(peer);
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("You have full inventory space!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(peer);
									}
								}
							}
							break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|roadtoglory\nbuttonClicked|claimreward") != string::npos) {
								int count = atoi(cch.substr(70, cch.length() - 70).c_str());
								if (count < 1 || count >10) break;
								if (std::find(pInfo(peer)->glo_p.begin(), pInfo(peer)->glo_p.end(), count) == pInfo(peer)->glo_p.end()) {
									if (pInfo(peer)->level >= count * 10) {
										pInfo(peer)->glo_p.push_back(count);
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										gamepacket_t p;
										p.Insert("OnSetBux");
										p.Insert(pInfo(peer)->gems += count * 100000);
										p.Insert(0);
										p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
										if (pInfo(peer)->supp >= 2) {
											p.Insert((float)33796, (float)1, (float)0);
										}
										p.CreatePacket(peer);
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("Congratulations! You have received your Road to Glory Reward!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
										PlayerMoving data_{};
										data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
										BYTE* raw = packPlayerMoving(&data_);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
										delete[] raw;
										glory_show(peer);
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|bulletin_edit\nbuttonClicked|clear\n") != string::npos) {
								{
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(items[pInfo(peer)->lastwrenchb].blockType == BlockTypes::MAILBOX ? "`2Mailbox emptied.``" : "`2Text cleared.``"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
								}
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
										if (world_->bulletin[i_].x == pInfo(peer)->lastwrenchx and world_->bulletin[i_].y == pInfo(peer)->lastwrenchy) {
											world_->bulletin.erase(world_->bulletin.begin() + i_);
											i_--;
										}
									}
									if (items[pInfo(peer)->lastwrenchb].blockType == BlockTypes::MAILBOX) {
										WorldBlock block_ = world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, &block_));
										BYTE* blc = raw + 56;
										form_visual(blc, block_, *world_, peer, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
											send_raw(currentPeer, 4, raw, 112 + alloc_(world_, &block_), ENET_PACKET_FLAG_RELIABLE);
										}
										delete[] raw, blc;
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|createstore") != string::npos) {
								if (pInfo(peer)->creatorlist) {
									int harga = atoi(explode("\n", explode("price|", cch)[1])[0].c_str());
									int id = atoi(explode("\n", explode("idds|", cch)[1])[0].c_str());
									int berapa = atoi(explode("\n", explode("count|", cch)[1])[0].c_str());
									int x = atoi(explode("\n", explode("njerX|", cch)[1])[0].c_str());
									int y = atoi(explode("\n", explode("gtwY|", cch)[1])[0].c_str());
									string namajson = explode("\n", explode("namaJson|", cch)[1])[0];
									string description = explode("\n", explode("desk|", cch)[1])[0];
									//string namaitem = explode("\n", explode("items|", cch)[1])[0];
									string namarttex = explode("\n", explode("namerttex|", cch)[1])[0];
									if ((namajson.length() || description.length() || namarttex.length()) < 1) break;
									if (id > items.size()) break;
									int konto = 0;
									modify_inventory(peer, id, konto);
									ofstream o("database/shop/-" + namajson + ".json");
									if (!o.is_open()) cout << "invalid to load shop. make sure the folder is exists!" << GetLastError() << endl;
									json j;
									j["g"] = harga;
									j["p"] = items[id].name;
									j["itemai"].push_back(make_pair(id, berapa));
									o << j << endl;
									StoreGemsData save{};
									save.itemid = id, save.price = harga, save.desc = description, save.x = x, save.y = y, save.jsonname = namajson, save.rttex = namarttex, save.itemname = items[id].name;
									store.push_back(save);
									storegemjson("save");
									//buttonshop.push_back("\nadd_button|" + namajson + "|`o" + namaitem + "``|interface/large/store_buttons/" + namarttex + ".rttex|`2You Get:`` 1 " + namaitem + ".<CR><CR>`5Description:`` " + description + "``|" + to_string(x) + "|" + to_string(y) + "|" + to_string(harga) + "|0|||-1|-1||-1|-1||1||||||0|0|");
									gamepacket_t packet;
									packet.Insert("OnConsoleMessage");
									packet.Insert("`o>> You just generated new store buttons!");
									packet.CreatePacket(peer);
									packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
									break;
								}
							}
							if (cch.find("action|dialog_return\ndialog_name|changeClist") != string::npos) {
								if (pInfo(peer)->tankIDName == clist1) {
									//string description = explode("\n", explode("desk|", cch)[1])[0];
									string creatorname = explode("\n", explode("namanjir|", cch)[1])[0];
									int number = atoi(explode("\n", explode("berapa|", cch)[1])[0].c_str());
									if (number == 2 || number == 3 || number < 1 || number > 12) {
										Algorithm::send_overlay(peer, "`4INVALID");
										break;
									}
									if (creatorname.length() < 1) {
										Algorithm::send_overlay(peer, "`4INVALID");
										break;
									}
									else {
										string list = to_string(number);
											std::ifstream p("./config/config.json");
											json J;
											p >> J;
											p.close();
										 J["clist"+list] = creatorname;
											std::ofstream out("./config/config.json");
											out << std::setw(4) << J;
											out.close();
											load_configss();
											Algorithm::send_overlay(peer, "`2Successfully changed creator name");
											break;
									}
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|generateshop") != string::npos) {
								if (pInfo(peer)->creatorlist) {
									int harga = atoi(explode("\n", explode("price|", cch)[1])[0].c_str());
									int id = atoi(explode("\n", explode("pathID|", cch)[1])[0].c_str());
									ofstream o("shop/-" + to_string(id) + ".json");
									if (!o.is_open()) cout << "invalid to load shop. make sure the folder is exists!" << GetLastError() << endl;
									json j;
									j["price"] = harga;
									j["id"] = id;
									//j["itemai"].push_back(make_pair(id, berapa));
									o << j << endl;
								shops.push_back("\nadd_button_with_icon|farm_price_" + to_string(id) + "|`c" + to_string(harga) + "|noflags|" + to_string(id) + "|");
									gamepacket_t packet;
									packet.Insert("OnConsoleMessage");
									packet.Insert("`o>> You have created new custom store buttons!");
									packet.CreatePacket(peer);
									packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
									std::string filename = "./config/shopbutton.json";
									json jsonData;
									std::ifstream configFile(filename);
									configFile >> jsonData;
									configFile.close();
									jsonData["custombutton"].push_back("\nadd_button_with_icon|farm_price_" + to_string(id) + "|`c" + to_string(harga) + "|noflags|" + to_string(id) + "||");
									std::ofstream outFile(filename);
									outFile << std::setw(4) << jsonData;
									outFile.close();
									break;
								}
								}
							else if (cch.find("action|dialog_return\ndialog_name|cal_cu") != string::npos) {
								int one = atoi(explode("\n", explode("angka_1|", cch)[1])[0].c_str());
								int two = atoi(explode("\n", explode("angka_2|", cch)[1])[0].c_str());
								string tipe = explode("\n", explode("tipe_|", cch)[1])[0];
								int done = 0;

								if (tipe == "+") {
									done = one + two;
									Algorithm::send_overlay(peer, "TOTAL: `2" + to_string(done));
								}
								if (tipe == "-") {
									done = one - two;
									Algorithm::send_overlay(peer, "TOTAL: `2" + to_string(done));
								}
								if (tipe == "x") {
									done = one * two;
									Algorithm::send_overlay(peer, "TOTAL: `2" + to_string(done));
								}
								if (tipe == ":") {
									done = one / two;
									Algorithm::send_overlay(peer, "TOTAL: `2" + to_string(done));
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|socialportal\nbuttonClicked|com_link") != string::npos) {
									//Algorithm::send_overlay(peer, "`4Under Construction");
								sendmessage(peer, "dialog", "add_label_with_icon|big|Community Link|left|1366|\nadd_spacer|small|"
									"\nadd_url_button|comment|`wJoin WhatsApp Group||" + whatsapp_link + "|Launch WhatsApp?|0|0|\n"
									"add_url_button|comment|`wJoin Discord Server||" + discord_link + "|Launch Discord?|0|0|\nadd_quick_exit|\nend_dialog|gazette|Close||");
								}
								if (cch.find("action|dialog_return\ndialog_name|socialportal\nbuttonClicked|cdg50") != string::npos) {
									Algorithm::send_overlay(peer, "`4Under Construction");
									break;
								}
							else if (cch.find("action|dialog_return\ndialog_name|remove_bulletin") != string::npos) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									int letter = 0;
									World* world_ = &worlds[p - worlds.begin()];
									for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
										if (world_->bulletin[i_].x == pInfo(peer)->lastwrenchx and world_->bulletin[i_].y == pInfo(peer)->lastwrenchy) {
											letter++;
											if (pInfo(peer)->lastchoosennr == letter) {
												world_->bulletin.erase(world_->bulletin.begin() + i_);
												{
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(peer)->netID);
													p.Insert("`2Bulletin removed.``");
													p.Insert(0), p.Insert(0);
													p.CreatePacket(peer);
												}
											}
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|bulletin_edit\nbuttonClicked|edit") != string::npos) {
								int count = atoi(cch.substr(65, cch.length() - 65).c_str()), letter = 0;
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
										if (world_->bulletin[i_].x == pInfo(peer)->lastwrenchx and world_->bulletin[i_].y == pInfo(peer)->lastwrenchy) {
											letter++;
											if (count == letter) {
												pInfo(peer)->lastchoosennr = count;
												gamepacket_t p;
												p.Insert("OnDialogRequest");
												p.Insert("set_default_color|`o\nadd_label_with_icon|small|Remove`` \"`w"+ world_->bulletin[i_].text +"\"`` from your board?|left|"+to_string(pInfo(peer)->lastwrenchb) + "|\nend_dialog|remove_bulletin|Cancel|OK|");
												p.CreatePacket(peer);
											}
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|5958") != string::npos) {
								vector<string> t_ = explode("|", cch);
								if (t_.size() == 7) {
									string name_ = pInfo(peer)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										World* world_ = &worlds[p - worlds.begin()];
										world_->fresh_world = true;
										WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
										if (not block_access(peer, world_, block_) or block_->fg != 5958) break;
										int minutes = atoi(explode("\n", t_[6])[0].c_str());
										if (minutes < 1 || minutes > 60) {
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("It is either too long or too low."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);

										}
										else block_->shelf_4 = minutes;
										block_->shelf_1 = atoi(explode("\n", t_[3])[0].c_str());
										block_->shelf_2 = atoi(explode("\n", t_[4])[0].c_str());
										block_->shelf_3 = atoi(explode("\n", t_[5])[0].c_str());
										if (block_->shelf_1 != 0 || block_->shelf_2 != 0 || block_->shelf_3 != 0) {
											bool found_ = false;
											for (int i_ = 0; i_ < world_->machines.size(); i_++) {
												WorldMachines* machine_ = &world_->machines[i_];
												if (machine_->x == pInfo(peer)->lastwrenchx and machine_->y == pInfo(peer)->lastwrenchy) {
													machine_->enabled = block_->enabled;
													machine_->target_item = block_->shelf_4;
													block_->pr = 1;
													found_ = true;
													break;
												}
											}
											if (not found_) {
												WorldMachines new_machine;
												new_machine.enabled = block_->enabled;
												new_machine.x = pInfo(peer)->lastwrenchx, new_machine.y = pInfo(peer)->lastwrenchy;
												new_machine.id = block_->fg;
												new_machine.target_item = block_->shelf_4;
												block_->pr = 1;
												world_->machines.push_back(new_machine);
												if (find(World_Stuff.t_worlds.begin(), World_Stuff.t_worlds.end(), world_->name) == World_Stuff.t_worlds.end()) {
													World_Stuff.t_worlds.push_back(world_->name);
												}
											}
										}
									}
								}
								break;
								}
							else if (cch.find("action|dialog_return\ndialog_name|advbegins\nnameEnter|") != string::npos) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									world_->fresh_world = true;
									WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
									if (block_->fg == 4722) {
										if (block_access(peer, world_, block_)) {
											string text = cch.substr(53, cch.length() - 54).c_str();
											if (text.size() > 32) break;
											block_->heart_monitor = text;
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID), p.Insert("Updated adventure!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world or pInfo(currentPeer)->adventure_begins == false) continue;
												pInfo(currentPeer)->adventure_begins = false;
											}
										}
									}
								}
								break;
						}
							else if (cch.find("action|dialog_return\ndialog_name|bulletin_edit\nbuttonClicked|send\n\nsign_text|") != string::npos) {
							vector<string> t_ = explode("|", cch);
							if (t_.size() < 4) break;
								string text = explode("\n", t_[4])[0].c_str();
								replace_str(text, "\n", "");
								if (text.length() <= 2 || text.length() >= 100) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("That's not interesting enough to post.");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(peer);
								}
								else {
									string name_ = pInfo(peer)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										{
											World* world_ = &worlds[p - worlds.begin()];
											int letter = 0;
											for (int i_ = 0; i_ < world_->bulletin.size(); i_++) if (world_->bulletin[i_].x == pInfo(peer)->lastwrenchx and world_->bulletin[i_].y == pInfo(peer)->lastwrenchy) letter++;
											if (letter == 21) world_->bulletin.erase(world_->bulletin.begin() + 0);
											WorldBulletin bulletin_{};
											bulletin_.x = pInfo(peer)->lastwrenchx, bulletin_.y = pInfo(peer)->lastwrenchy;
											if (pInfo(peer)->name_color != "`0") bulletin_.name = (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "``";
											else bulletin_.name = "`0" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "``";
											bulletin_.text = text;
											world_->bulletin.push_back(bulletin_);
											{
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert(items[pInfo(peer)->lastwrenchb].blockType == BlockTypes::MAILBOX ? "`2You place your letter in the mailbox.``" : "`2Bulletin posted.``");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(peer);
											}
											if (items[pInfo(peer)->lastwrenchb].blockType == BlockTypes::MAILBOX) {
												WorldBlock block_ = world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
												PlayerMoving data_{};
												data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
												BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, &block_));
												BYTE* blc = raw + 56;
												form_visual(blc, block_, *world_, peer, false, true);
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
													if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
													send_raw(currentPeer, 4, raw, 112 + alloc_(world_, &block_), ENET_PACKET_FLAG_RELIABLE);
												}
												delete[] raw, blc;
											}
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|storageboxxtreme\nbuttonClicked|do_add\n\nitemcount|") != string::npos) {
								int count = atoi(cch.substr(82, cch.length() - 82).c_str());
								if (pInfo(peer)->lastchoosenitem <= 0 || pInfo(peer)->lastchoosenitem >= items.size()) break;
								if (pInfo(peer)->lastwrenchb != 4516 and items[pInfo(peer)->lastchoosenitem].untradeable == 1 or pInfo(peer)->lastchoosenitem == 1424 or pInfo(peer)->lastchoosenitem == 5816 or items[pInfo(peer)->lastchoosenitem].blockType == BlockTypes::FISH) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You can't store Untradeable items there!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
								}
								else if (pInfo(peer)->lastwrenchb == 4516 and items[pInfo(peer)->lastchoosenitem].untradeable == 0 or pInfo(peer)->lastchoosenitem == 1424 or pInfo(peer)->lastchoosenitem == 5816 || items[pInfo(peer)->lastchoosenitem].blockType == BlockTypes::FISH || pInfo(peer)->lastchoosenitem == 18 || pInfo(peer)->lastchoosenitem == 32 || pInfo(peer)->lastchoosenitem == 6336 || pInfo(peer)->lastchoosenitem == 8430) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You can't store Tradeable items there!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
								}
								else {
									int got = 0, receive = 0;
									modify_inventory(peer, pInfo(peer)->lastchoosenitem, got);
									if (count <= 0 || count > got) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
									}
									else {
										receive = count * -1;
										string name_ = pInfo(peer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											World* world_ = &worlds[p - worlds.begin()];
											world_->fresh_world = true;
											WorldBlock block_ = world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
											if (items[pInfo(peer)->lastchoosenitem].untradeable == 1 && block_.fg != 4516) break;
											if (items[block_.fg].blockType != BlockTypes::STORAGE) break;
											gamepacket_t p1, p2;
											p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("Stored `w" + to_string(count) + " " + items[pInfo(peer)->lastchoosenitem].name + "`` in " + items[pInfo(peer)->lastwrenchb].name + "."), p1.Insert(0), p1.Insert(0), p1.CreatePacket(peer);
											p2.Insert("OnConsoleMessage"), p2.Insert("Stored `w" + to_string(count) + " " + items[pInfo(peer)->lastchoosenitem].name + "`` in the " + items[pInfo(peer)->lastwrenchb].name + "."), p2.CreatePacket(peer);
											modify_inventory(peer, pInfo(peer)->lastchoosenitem, receive);
											bool dublicated = true;
											for (int i_ = 0; i_ < world_->sbox1.size(); i_++) {
												if (dublicated) {
													if (world_->sbox1[i_].x == pInfo(peer)->lastwrenchx and world_->sbox1[i_].y == pInfo(peer)->lastwrenchy and world_->sbox1[i_].id == pInfo(peer)->lastchoosenitem and world_->sbox1[i_].count + count <= 200) {
														world_->sbox1[i_].count += count;
														dublicated = false;
													}
												}
											}
											if (dublicated) {
												WorldSBOX1 sbox1_{};
												sbox1_.x = pInfo(peer)->lastwrenchx, sbox1_.y = pInfo(peer)->lastwrenchy;
												sbox1_.id = pInfo(peer)->lastchoosenitem, sbox1_.count = count;
												world_->sbox1.push_back(sbox1_);
											}
											PlayerMoving data_{};
											data_.packetType = 19, data_.netID = -1, data_.plantingTree = 0;
											data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
											data_.XSpeed = pInfo(peer)->x + 16, data_.YSpeed = pInfo(peer)->y + 16;
											data_.punchX = pInfo(peer)->lastchoosenitem;
											BYTE* raw = packPlayerMoving(&data_);
											raw[3] = 6;
											send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											delete[] raw;
											edit_tile(peer, pInfo(peer)->lastwrenchx, pInfo(peer)->lastwrenchy, 32);
										}
									}
								}
								break;
								}
							/*else if (cch.find("action|dialog_return\ndialog_name|storageboxxtreme\nbuttonClicked|do_add\n\nitemcount|") != string::npos) {
								int count = atoi(cch.substr(82, cch.length() - 82).c_str());
								if (pInfo(peer)->lastchoosenitem <= 0 || pInfo(peer)->lastchoosenitem >= items.size()) break;
								if (pInfo(peer)->lastwrenchb != 4516 and items[pInfo(peer)->lastchoosenitem].untradeable == 1 or pInfo(peer)->lastchoosenitem == 1424 or items[pInfo(peer)->lastchoosenitem].blockType == BlockTypes::FISH) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You can't store Untradeable items there!"), p.CreatePacket(peer);
								}
								else if (pInfo(peer)->lastwrenchb == 4516 and items[pInfo(peer)->lastchoosenitem].untradeable == 0 or pInfo(peer)->lastchoosenitem == 1424 || items[pInfo(peer)->lastchoosenitem].blockType == BlockTypes::FISH || pInfo(peer)->lastchoosenitem == 18 || pInfo(peer)->lastchoosenitem == 32 || pInfo(peer)->lastchoosenitem == 6336) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You can't store Tradeable items there!"), p.CreatePacket(peer);
								}
								else {
									int got = 0, receive = 0;
									modify_inventory(peer, pInfo(peer)->lastchoosenitem, got);
									if (count <= 0 || count > got) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
									}
									else {
										receive = count * -1;
										string name_ = pInfo(peer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											World* world_ = &worlds[p - worlds.begin()];
											WorldBlock block_ = world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
											if (items[pInfo(peer)->lastchoosenitem].untradeable == 1 && block_.fg != 4516) break;
											gamepacket_t p1, p2;
											p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("Stored `w" + to_string(count) + " " + items[pInfo(peer)->lastchoosenitem].name + "`` in " + items[pInfo(peer)->lastwrenchb].name + "."), p1.CreatePacket(peer);
											p2.Insert("OnConsoleMessage"), p2.Insert("Stored `w" + to_string(count) + " " + items[pInfo(peer)->lastchoosenitem].name + "`` in the " + items[pInfo(peer)->lastwrenchb].name + "."), p2.CreatePacket(peer);
											modify_inventory(peer, pInfo(peer)->lastchoosenitem, receive);
											bool dublicated = true;
											for (int i_ = 0; i_ < world_->sbox1.size(); i_++) {
												if (dublicated) {
													if (world_->sbox1[i_].x == pInfo(peer)->lastwrenchx and world_->sbox1[i_].y == pInfo(peer)->lastwrenchy and world_->sbox1[i_].id == pInfo(peer)->lastchoosenitem and world_->sbox1[i_].count + count <= 200) {
														world_->sbox1[i_].count += count;
														dublicated = false;
													}
												}
											}
											if (dublicated) {
												WorldSBOX1 sbox1_{};
												sbox1_.x = pInfo(peer)->lastwrenchx, sbox1_.y = pInfo(peer)->lastwrenchy;
												sbox1_.id = pInfo(peer)->lastchoosenitem, sbox1_.count = count;
												world_->sbox1.push_back(sbox1_);
											}
											PlayerMoving data_{};
											data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = pInfo(peer)->lastchoosenitem, data_.punchY = pInfo(peer)->netID;
											int32_t to_netid = pInfo(peer)->netID;
											BYTE* raw = packPlayerMoving(&data_);
											raw[3] = 5;
											memcpy(raw + 8, &to_netid, 4);
											send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											delete[] raw;
											edit_tile(peer, pInfo(peer)->lastwrenchx, pInfo(peer)->lastwrenchy, 32);
										}
									}
								}
								break;
							}*/
							else if (cch.find("action|dialog_return\ndialog_name|punish_view\nbuttonClicked|oan_") != string::npos) {
								if (pInfo(peer)->owner == 1) {
									if (to_lower(pInfo(peer)->last_wrenched) == clist1) break;
									long long int seconds = atoi(cch.substr(63, cch.length() - 63).c_str());
									string reason = cch.substr(72 + to_string(seconds).length(), cch.length() - 72 + to_string(seconds).length()).c_str();
									replace_str(reason, "\n", "");
									writelog(pInfo(peer)->tankIDName + " " + (seconds == 0 ? "unbanned" : "banned") + " (" + reason + ") - " + pInfo(peer)->last_wrenched);
									string path_ = "database/players/" + pInfo(peer)->last_wrenched + "_.json";
									if (_access_s(path_.c_str(), 0) == 0) {
										json r_;
										ifstream f_(path_, ifstream::binary);
										if (f_.fail()) continue;
										f_ >> r_;
										f_.close();
										{
											json f_ = r_["b_t"].get<int>();
											if (seconds == 729) r_["b_s"] = (6.307e+7 * 1000);
											else if (seconds == 31)r_["b_s"] = (2.678e+6 * 1000);
											else r_["b_s"] = (seconds * 1000);
											r_["b_r"] = reason;
											r_["b_b"] = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``";
											r_["b_t"] = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											if (seconds == 0) {
												r_["b_t"] = 0;
												r_["b_s"] = 0;
												r_["b_r"] = "";
												r_["b_b"] = "";
												r_["b_t"] = 0;
												add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "UNBANNED: " + pInfo(peer)->last_wrenched + "``", "");
											}
											else {
												if (seconds == 729) seconds = 6.307e+7;
												if (seconds == 31) seconds = 2.678e+6;
												add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "BANNED (" + reason + "): " + pInfo(peer)->last_wrenched + "``", "`#" + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
											}
										}
										{
											ofstream f_(path_, ifstream::binary);
											f_ << r_;
											f_.close();
										}
									}

								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|punish_view\nbuttonClicked|ban_") != string::npos) {
								if (pInfo(peer)->creatorlist == 1) {
									if (to_lower(pInfo(peer)->last_wrenched) == clist1) break;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
											long long int seconds = atoi(cch.substr(63, cch.length() - 63).c_str()), sec_time = 0;
											string reason = cch.substr(72 + to_string(seconds).length(), cch.length() - 72 + to_string(seconds).length()).c_str();
											replace_str(reason, "\n", "");
											if (reason == "") {
												gamepacket_t p;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You did not put the reason for a ban!"), p.CreatePacket(peer);
											}
											else {
												sec_time = seconds;
												if (seconds == 729) sec_time = 6.307e+7;
												if (seconds == 31)sec_time = 2.678e+6;
												writelog(pInfo(peer)->tankIDName + " banned (" + reason + ") - " + pInfo(currentPeer)->tankIDName);
												add_ban(currentPeer, sec_time, reason, pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``");
												add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "BANNED (" + reason + "): " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``", "`#" + ((sec_time / 86400 > 0) ? to_string(sec_time / 86400) + " days" : (sec_time / 3600 > 0) ? to_string(sec_time / 3600) + " hours" : (sec_time / 60 > 0) ? to_string(sec_time / 60) + " minutes" : to_string(sec_time) + " seconds"));
											}
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|punish_view\nbuttonClicked|ipban") != string::npos) {
								if (pInfo(peer)->creatorlist == 1) {
									if (to_lower(pInfo(peer)->last_wrenched) == clist1) break;
									string his_ip = "";
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
											add_ban(currentPeer, 6.307e+7, "No reason", pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``");
											writelog(pInfo(peer)->tankIDName + " ip banned (" + pInfo(currentPeer)->ip + ") - " + pInfo(currentPeer)->tankIDName);
											add_ipban(currentPeer);
										}
									}
									if (not his_ip.empty()) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->ip == pInfo(peer)->ip) {
												add_ban(currentPeer, 6.307e+7, "No reason", pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``");
												writelog(pInfo(peer)->tankIDName + " ip banned (" + pInfo(currentPeer)->ip + ") - " + pInfo(currentPeer)->tankIDName);
												add_ipban(currentPeer);
											}
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|punish_view\nbuttonClicked|duc_") != string::npos) {
								if (pInfo(peer)->owner == 1) {
									if (to_lower(pInfo(peer)->last_wrenched) == clist1) break;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
											int seconds = atoi(cch.substr(63, cch.length() - 63).c_str());
											string reason = cch.substr(72 + to_string(seconds).length(), cch.length() - 72 + to_string(seconds).length()).c_str();
											replace_str(reason, "\n", "");
											if (reason == "") {
												gamepacket_t p;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You did not put the reason for a ban!"), p.CreatePacket(peer);
											}
											else {
												writelog(pInfo(peer)->tankIDName + " duct-taped (" + reason + ") - " + pInfo(currentPeer)->tankIDName);
												add_mute(currentPeer, seconds, reason, pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``");
												add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "DUCT-TAPED (" + reason + "): " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``", "`#" + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
											}
										}
									}
								}
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|popup\nbuttonClicked|alist2") != string::npos) {
								backpack_show(peer);
								break;
							}
							/*if (cch.find("action|dialog_return\ndialog_name|mailboxp\nbuttonClicked|mailchat") != string::npos) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|Mail a Player|left|656|\nadd_spacer|small|\nadd_textbox|Who player would you like to mail him/her?|left|\nadd_text_input|player|Input Player Name:||30|\nadd_spacer|small|\nadd_text_input|msg|Insert The Message:||50|\nend_dialog|mailboxplayer|Nevermind|Send The Message|");
								p.CreatePacket(peer);
								break;
							}
						 if (cch.find("action|dialog_return\ndialog_name|mailboxplayer") != string::npos) {
								string player = explode("\n", explode("player|", cch)[1])[0];
								string message = explode("\n", explode("msg|", cch)[1])[0];
								if (player.length() < 2) {
									Algorithm::send_overlay(peer, "Please put the player name");
									break;
								}
								std::string filename = "./database/player/" + player + ".json";
								json jsonData;
								std::ifstream configFile(filename);
								configFile >> jsonData;
								configFile.close();
								if (!configFile.is_open()) {
									std::cout << "Failed to open "+player+".json" << std::endl;
								}
								vector<string>pesan = jsonData["mailbox"].get<vector<string>>();
							 if (has_playmod(pInfo(peer), "Mail Cooldown")) {
									Algorithm::send_console(peer, "You need to wait until the cooldowns is ended");
									break;
								}
							     if (message.length() < 3) {
									Algorithm::send_console(peer, "Minimum message is 3 Character");
									break;
								}
								else if (player == pInfo(peer)->tankIDName) {
									Algorithm::send_console(peer, "Sending Mail to yourself? what a stupid thing");
									break;
								}
								else {
									PlayMods new_playmod{};
									new_playmod.id = 114, new_playmod.time = time(nullptr) + 1800;
									pInfo(peer)->playmods.push_back(new_playmod);
									{
									jsonData["mailbox"].push_back("\nadd_textbox|`ofrom " + pInfo(peer)->tankIDName + ":|left|\nadd_textbox|" + message + "|left|");
									std::ofstream outFile(filename);
									outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
									outFile.close();
									Algorithm::send_overlay(peer, "`2Successfully sent mail");
									save_player(pInfo(peer), true);
									break;
								}
							}
						}*/
							if (cch.find("action|dialog_return\ndialog_name|consumerole") != string::npos) {
								if (cch.find("buttonClicked|consumevip") != string::npos) {
									int c = -1;
									int have = 0;
									modify_inventory(peer, 9854, have);
									if (have < 1 || have > 200) break;
									if (has_playmod(pInfo(peer), "VIP")) {
										Algorithm::send_overlay(peer, "That role already applied on you");
										break;
									}
									if (modify_inventory(peer, 9854, c) == 0) {
										PlayMods new_playmod{};
										new_playmod.id = 103, new_playmod.time = time(nullptr) + 2678400;
										pInfo(peer)->playmods.push_back(new_playmod);
										Algorithm::send_console(peer, "VIP Role activated (VIP Active mod added 30Day's left)");
										break;
									}
								}
								if (cch.find("buttonClicked|consumemod") != string::npos) {
									int c = -1;
									int have = 0;
									modify_inventory(peer, 9852, have);
									if (have < 1 || have > 200) break;
									if (has_playmod(pInfo(peer), "Moderator Role")) {
										Algorithm::send_overlay(peer, "That role already applied on you");
										break;
									}
									if (modify_inventory(peer, 9852, c) == 0) {
										PlayMods new_playmod{};
										new_playmod.id = 105, new_playmod.time = time(nullptr) + 2678400;
										pInfo(peer)->playmods.push_back(new_playmod);
										Algorithm::send_console(peer, "Moderator Role activated (Moderator Role mod added 30Day's left)");
										break;
									}
								}
								if (cch.find("buttonClicked|consumecheat") != string::npos) {
									int c = -1;
									int have = 0;
									modify_inventory(peer, 10400, have);
									if (have < 1 || have > 200) break;
									if (has_playmod(pInfo(peer), "Cheater Role")) {
										Algorithm::send_overlay(peer, "That role already applied on you");
										break;
									}
									if (modify_inventory(peer, 10400, c) == 0) {
										PlayMods new_playmod{};
										new_playmod.id = 106, new_playmod.time = time(nullptr) + 86400;
										pInfo(peer)->playmods.push_back(new_playmod);
										Algorithm::send_console(peer, "Cheater Role activated (Cheater Role mod added 1Day's left)");
										break;
									}
								}
							}
							if (cch.find("action|dialog_return\ndialog_name|bank_depositajg") != string::npos) {
								std::string filename = "./config/crypto.json";
								json jsonData;
								std::ifstream configFile(filename);
								configFile >> jsonData;
								configFile.close();
								int price_bc = jsonData["Bitcoin"].get<int>();
								int price_et = jsonData["Ethereum"].get<int>();
								int price_lt = jsonData["Litecoin"].get<int>();
								if (cch.find("buttonClicked|buy_bc") != string::npos) {
								int bgls = 0, c_ = 0;
								c_ = pInfo(peer)->gems;
								if (c_ == 0) break;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBuy Bitcoin````|left|10002|\nadd_image_button||interface/large/crypto_banner_buy.rttex|bannerlayout|||\nadd_spacer|small|\nadd_label|small|How Many Would you like to buy? (you have " + to_string(c_) + " Gems)|left|\nadd_text_input|bgl_count|`wAmount:``|1|4|\nadd_spacer|small|\nadd_button|confirm_bc|Confirm|noflags|0|0|\nend_dialog|bank_deposit|Nevermind.||");
								p.CreatePacket(peer);
								break;
							}
								if (cch.find("buttonClicked|buy_et") != string::npos) {
									int bgls = 0, c_ = 0;
									c_ = pInfo(peer)->gems;
									if (c_ == 0) break;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBuy Ethereum````|left|10012|\nadd_image_button||interface/large/crypto_banner_buy.rttex|bannerlayout|||\nadd_spacer|small|\nadd_label|small|How Many Would you like to buy? (you have " + to_string(c_) + " Gems)|left|\nadd_text_input|bgls_count|`wAmount:``|1|4|\nadd_spacer|small|\nadd_button|confirm_et|Confirm|noflags|0|0|\nend_dialog|bank_deposit|Nevermind.||");
									p.CreatePacket(peer);
									break;
								}
								if (cch.find("buttonClicked|buy_lc") != string::npos) {
									int bgls = 0, c_ = 0;
									c_ = pInfo(peer)->gems;
									if (c_ == 0) break;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBuy Litecoin````|left|10014|\nadd_image_button||interface/large/crypto_banner_buy.rttex|bannerlayout|||\nadd_spacer|small|\nadd_label|small|How Many Would you like to buy? (you have " + to_string(c_) + " Gems)|left|\nadd_text_input|bgls_count|`wAmount:``|1|4|\nadd_spacer|small|\nadd_button|confirm_lc|Confirm|noflags|0|0|\nend_dialog|bank_deposit|Nevermind.||");
									p.CreatePacket(peer);
									break;
								}
								if (cch.find("buttonClicked|sell_bc") != string::npos) {
									int bgls = 0, c_ = 0;
									c_ = pInfo(peer)->bitcoin;
									if (c_ == 0) break;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSell Bitcoin````|left|10002|\nadd_label|small|How Many Would you like to sell? (you have " + to_string(c_) + " Bitcoin)|left|\nadd_text_input|bgl_count|`wAmount:``|1|4|\nadd_spacer|small|\nadd_button|confirm_sbc|Confirm|noflags|0|0|\nend_dialog|bank_deposit|Nevermind.||");
									p.CreatePacket(peer);
									break;
								}
								if (cch.find("buttonClicked|sell_et") != string::npos) {
									int bgls = 0, c_ = 0;
									c_ = pInfo(peer)->ethereum;
									if (c_ == 0) break;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSell Ethereum````|left|10012|\nadd_label|small|How Many Would you like to sell? (you have " + to_string(c_) + " Ethereum)|left|\nadd_text_input|bgls_count|`wAmount:``|1|4|\nadd_spacer|small|\nadd_button|confirm_set|Confirm|noflags|0|0|\nend_dialog|bank_deposit|Nevermind.||");
									p.CreatePacket(peer);
									break;
								}
								if (cch.find("buttonClicked|donate") != string::npos) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wLock's Donation````|left|242|\nadd_label|small|We here accepting any world lock type and any count we will appeciated you because you donated world lock for new player's !|left|\nadd_textbox|You can choose which Lock what you want donate|left|\nadd_text_input|bgls_count|`wAmount Donation:``|1|4|\nadd_spacer|small|\nadd_button|donat_wl|World Lock|left|\nadd_button|donat_dl|Diamond Lock|left|\nadd_button|donat_bgl|Blue Gem Lock|left|\nadd_button|donat_ggl|Golden Gem Lock|noflags|0|0|\nend_dialog|bank_deposit|Nevermind.||");
									p.CreatePacket(peer);
									break;
								}
								if (cch.find("buttonClicked|sell_lc") != string::npos) {
									int bgls = 0, c_ = 0;
									c_ = pInfo(peer)->litecoin;
									if (c_ == 0) break;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSell Litecoin````|left|100014|\nadd_label|small|How Many Would you like to sell? (you have " + to_string(c_) + " Litecoin)|left|\nadd_text_input|bgls_count|`wAmount:``|1|4|\nadd_spacer|small|\nadd_button|confirm_slc|Confirm|noflags|0|0|\nend_dialog|bank_deposit|Nevermind.||");
									p.CreatePacket(peer);
									break;
								}
								if (cch.find("buttonClicked|belimvp") != string::npos) {
									int wl = 0;
									wl = pInfo(peer)->total_recycle_wl;
									if (wl < 50000000) {
										Algorithm::send_overlay(peer, "You can't claim it when your not reach the goal");
										break;
									}
									else if (pInfo(peer)->gp == 1) {
										Algorithm::send_bubble(peer, pInfo(peer)->netID, "You already had that role");
										break;
									}
									else {
										pInfo(peer)->gp = 1;
										Algorithm::send_overlay(peer, "`2Successfully Claim Grow Pass as a Reward!");
										break;
									}
									break;
								}
							else if (cch.find("buttonClicked|confirm_bc") != string::npos) {
								try {
									int count = atoi(explode("\n", explode("bgl_count|", cch)[1])[0].c_str());
									int got = 0, receive = 0;
									got = pInfo(peer)->gems;
									if (count <= 0) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
										break;
									}
									else if (got < (count * price_bc)) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
										Algorithm::send_console(peer, "You don't have that many!");
										break;
									}
									else if (got >= (count * price_bc)) {
										receive = count * price_bc;
										string name_ = pInfo(peer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											gamepacket_t p1, p2;
											p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("`oYou Bought `w" + to_string(count) + "`9 Bitcoin `oFor `5"+ to_string(receive) + " Gems"), p1.CreatePacket(peer);
											p2.Insert("OnConsoleMessage"), p2.Insert("`oYou Bought `w" + to_string(count) + "`9 Bitcoin `oFor `5" + to_string(receive) + " Gems"), p2.CreatePacket(peer);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											pInfo(peer)->bitcoin += count;
											gamepacket_t p;
											p.Insert("OnSetBux");
											p.Insert(pInfo(peer)->gems -= receive);
											p.Insert(0);
											Crypto_Update.crypto_history.push_back("\nadd_label_with_icon|small|" + pInfo(peer)->tankIDName + " Bought " + to_string(count) + " Bitcoin for `5" + to_string(receive) + " Gems `w[`1Rate: " + to_string(price_bc) + " Gems`w]|left|10002|");
											pInfo(peer)->history_crypto.push_back("\nadd_label_with_icon|small|You Bought " + to_string(count) + " Bitcoin for `5" + to_string(receive) + " Gems `w[`1Rate: " + to_string(price_bc) + " Gems`w]|left|10002|");
											p.CreatePacket(peer);
											save_player(pInfo(peer), false);
										}
									}
								}
								catch (...) {
									break;
								}
							}
							else if (cch.find("buttonClicked|confirm_et") != string::npos) {
								try {
									int count = atoi(explode("\n", explode("bgls_count|", cch)[1])[0].c_str());
									int got = 0, receive = 0;
									got = pInfo(peer)->gems;
									if (count <= 0) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
										break;
									}
									else if (got < (count * price_et)) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
										Algorithm::send_console(peer, "You don't have that many!");
										break;
									}
									else if (got >= (count * price_et)) {
										receive = count * price_et;
										string name_ = pInfo(peer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											gamepacket_t p1, p2;
											p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("`oYou Bought `w" + to_string(count) + "`# Ethereum `oFor `5" + to_string(receive) + " Gems"), p1.CreatePacket(peer);
											p2.Insert("OnConsoleMessage"), p2.Insert("`oYou Bought `w" + to_string(count) + "`# Ethereum `oFor `5" + to_string(receive) + " Gems"), p2.CreatePacket(peer);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											pInfo(peer)->ethereum += count;
											gamepacket_t p;
											p.Insert("OnSetBux");
											p.Insert(pInfo(peer)->gems -= receive);
											p.Insert(0);
											Crypto_Update.crypto_history.push_back("\nadd_label_with_icon|small|" + pInfo(peer)->tankIDName + " Bought " + to_string(count) + " Ethereum for `5" + to_string(receive) + " Gems `w[`1Rate: " + to_string(price_et) + " Gems`w]|left|10012|");
											pInfo(peer)->history_crypto.push_back("\nadd_label_with_icon|small|You Bought " + to_string(count) + " Ethereum for `5" + to_string(receive) + " Gems `w[`1Rate: " + to_string(price_et) + " Gems`w]|left|10012|");
											p.CreatePacket(peer);
											save_player(pInfo(peer), false);
										}
									}
								}
								catch (...) {
									break;
								}
							}
							else if (cch.find("buttonClicked|confirm_lc") != string::npos) {
								try {
									int count = atoi(explode("\n", explode("bgls_count|", cch)[1])[0].c_str());
									int got = 0, receive = 0;
									got = pInfo(peer)->gems;
									if (count <= 0) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
										break;
									}
									else if (got < (count * price_lt)) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
										Algorithm::send_console(peer, "You don't have that many!");
										break;
									}
									else if (got >= (count * price_lt)){
										receive = count * price_lt;
										string name_ = pInfo(peer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											gamepacket_t p1, p2;
											p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("`oYou Bought `w" + to_string(count) + "`1 Litecoin `oFor `5" + to_string(receive) + " Gems"), p1.CreatePacket(peer);
											p2.Insert("OnConsoleMessage"), p2.Insert("`oYou Bought `w" + to_string(count) + "`1 Litecoin `oFor `5" + to_string(receive) + " Gems"), p2.CreatePacket(peer);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											pInfo(peer)->litecoin += count;
											gamepacket_t p;
											p.Insert("OnSetBux");
											p.Insert(pInfo(peer)->gems -= receive);
											p.Insert(0);
											Crypto_Update.crypto_history.push_back("\nadd_label_with_icon|small|" + pInfo(peer)->tankIDName + " Bought " + to_string(count) + " Litecoin for `5" + to_string(receive) + " Gems `w[`1Rate: " + to_string(price_lt) + " Gems`w]|left|10014|");
											pInfo(peer)->history_crypto.push_back("\nadd_label_with_icon|small|You Bought " + to_string(count) + " Litecoin for `5" + to_string(receive) + " Gems `w[`1Rate: " + to_string(price_lt) + " Gems`w]|left|10014|");
											p.CreatePacket(peer);
											save_player(pInfo(peer), false);
										}
									}
								}
								catch (...) {
									break;
								}
							}
							else if (cch.find("buttonClicked|confirm_sbc") != string::npos) {
								try {
									int count = atoi(explode("\n", explode("bgl_count|", cch)[1])[0].c_str());
									int got = 0, receive = 0;
									int harga = 0;
									int jual = (price_bc / 40);
									harga = (price_bc - jual);
									got = pInfo(peer)->bitcoin;
									if (count <= 0) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
										break;
									}
									else if (got < count) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
										Algorithm::send_console(peer, "You don't have that many");
										break;
									}
									else if (got >= count) {
										receive = count * harga;
										string name_ = pInfo(peer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											gamepacket_t p1, p2;
											p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("`oYou Sold `w" + to_string(count) + "`9 Bitcoin `oFor `5" + to_string(receive) + " Gems"), p1.CreatePacket(peer);
											p2.Insert("OnConsoleMessage"), p2.Insert("`oYou Sold `w" + to_string(count) + "`9 Bitcoin `oFor `5" + to_string(receive) + " Gems"), p2.CreatePacket(peer);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											pInfo(peer)->bitcoin -= count;
											gamepacket_t p;
											p.Insert("OnSetBux");
											p.Insert(pInfo(peer)->gems += receive);
											p.Insert(0);
											Crypto_Update.crypto_history.push_back("\nadd_label_with_icon|small|" + pInfo(peer)->tankIDName + " Sold " + to_string(count) + " Bitcoin for `5" + to_string(receive) + " Gems `w[`1Rate: " + to_string(harga) + " Gems`w]|left|10002|");
											pInfo(peer)->history_crypto.push_back("\nadd_label_with_icon|small|You Sold " + to_string(count) + " Bitcoin for `5" + to_string(receive) + " Gems `w[`1Rate: " + to_string(harga) + " Gems`w]|left|10002|");
											p.CreatePacket(peer);
											save_player(pInfo(peer), false);
										}
									}
								}
								catch (...) {
									break;
								}
								}
							else if (cch.find("buttonClicked|confirm_set") != string::npos) {
									try {
										int count = atoi(explode("\n", explode("bgls_count|", cch)[1])[0].c_str());
										int got = 0, receive = 0;
										got = pInfo(peer)->ethereum;
										int harga = 0;
										int jual = (price_et / 40);
										harga = (price_et - jual);
										if (count <= 0) {
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
											break;
										}
										else if (got < count) {
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
											Algorithm::send_console(peer, "You don't have that many");
											break;
										}
										else if (got >= count) {
											receive = count * harga;
											string name_ = pInfo(peer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												gamepacket_t p1, p2;
												p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("`oYou Sold `w" + to_string(count) + "`# Ethereum `oFor `5" + to_string(receive) + " Gems"), p1.CreatePacket(peer);
												p2.Insert("OnConsoleMessage"), p2.Insert("`oYou Sold `w" + to_string(count) + "`# Ethereum `oFor `5" + to_string(receive) + " Gems"), p2.CreatePacket(peer);
												packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
												pInfo(peer)->ethereum -= count;
												gamepacket_t p;
												p.Insert("OnSetBux");
												p.Insert(pInfo(peer)->gems += receive);
												p.Insert(0);
												Crypto_Update.crypto_history.push_back("\nadd_label_with_icon|small|" + pInfo(peer)->tankIDName + " Sold " + to_string(count) + " Ethereum for `5" + to_string(receive) + " Gems `w[`1Rate: " + to_string(harga) + " Gems`w]|left|10012|");
												pInfo(peer)->history_crypto.push_back("\nadd_label_with_icon|small|You Sold " + to_string(count) + " Ethereum for `5" + to_string(receive) + " Gems `w[`1Rate: " + to_string(harga) + " Gems`w]|left|10012|");
												p.CreatePacket(peer);
												save_player(pInfo(peer), false);
											}
										}
									}
									catch (...) {
										break;
									}
								}
							else if (cch.find("buttonClicked|donat_wl") != string::npos) {
								try {
									int count = atoi(explode("\n", explode("bgls_count|", cch)[1])[0].c_str());
									int got = 0, receive = 0;
									modify_inventory(peer, 242, got);
									if (count <= 0) {
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("We accepting any count but, please atleast donate 1 World Lock!"), p.CreatePacket(peer);
										break;
									}
									else if (got < count) {
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("We know you want to donate that much but you don't have that much World Lock!"), p.CreatePacket(peer);
										Algorithm::send_console(peer, "You don't have that many");
										break;
									}
									else {
										receive = count * -1;
										modify_inventory(peer, 242, receive);
										string name_ = pInfo(peer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											gamepacket_t p1, p2;
											p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("Thank You for your Donation"), p1.CreatePacket(peer);
											p2.Insert("OnConsoleMessage"), p2.Insert("Thank you for the Donation"), p2.CreatePacket(peer);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											pInfo(peer)->total_recycle_wl += count;
											Growch_Update.total_s4tb = (Growch_Update.total_s4tb + count);
											grow4good(peer, false, "wl", count);
											save_player(pInfo(peer), false);
										}
									}
								}
								catch (...) {
									break;
								}
							}
							else if (cch.find("buttonClicked|donat_dl") != string::npos) {
								try {
									int count = atoi(explode("\n", explode("bgls_count|", cch)[1])[0].c_str());
									int got = 0, receive = 0;
									modify_inventory(peer, 1796, got);
									if (count <= 0) {
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("We accepting any count but, please atleast donate 1 Diamond Lock!"), p.CreatePacket(peer);
										break;
									}
									else if (got < count) {
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("We know you want to donate that much but you don't have that much Diamond Lock!"), p.CreatePacket(peer);
										Algorithm::send_console(peer, "You don't have that many");
										break;
									}
									else {
										receive = count * -1;
										int dapat = count * 100;
										modify_inventory(peer, 1796, receive);
										string name_ = pInfo(peer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											gamepacket_t p1, p2;
											p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("Thank You for your Donation"), p1.CreatePacket(peer);
											p2.Insert("OnConsoleMessage"), p2.Insert("Thank you for the Donation"), p2.CreatePacket(peer);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											Growch_Update.total_s4tb = (Growch_Update.total_s4tb + dapat);
											pInfo(peer)->total_recycle_wl += count * 100;
											save_player(pInfo(peer), false);
										}
									}
								}
								catch (...) {
									break;
								}
							}
							else if (cch.find("buttonClicked|donat_bgl") != string::npos) {
								try {
									int count = atoi(explode("\n", explode("bgls_count|", cch)[1])[0].c_str());
									int got = 0, receive = 0;
									modify_inventory(peer, 7188, got);
									if (count <= 0) {
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("We accepting any count but, please atleast donate 1 Blue Gem Lock!"), p.CreatePacket(peer);
										break;
									}
									else if (got < count) {
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("We know you want to donate that much but you don't have that much Blue Gem Lock!"), p.CreatePacket(peer);
										Algorithm::send_console(peer, "You don't have that many");
										break;
									}
									else {
										receive = count * -1;
										int dapat = count * 10000;
										modify_inventory(peer, 7188, receive);
										string name_ = pInfo(peer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											gamepacket_t p1, p2;
											p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("Thank You for your Donation"), p1.CreatePacket(peer);
											p2.Insert("OnConsoleMessage"), p2.Insert("Thank you for the Donation"), p2.CreatePacket(peer);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											Growch_Update.total_s4tb = (Growch_Update.total_s4tb + dapat);
											pInfo(peer)->total_recycle_wl += count * 10000;
											save_player(pInfo(peer), false);
										}
									}
								}
								catch (...) {
									break;
								}
							}
							else if (cch.find("buttonClicked|donat_ggl") != string::npos) {
								try {
									int count = atoi(explode("\n", explode("bgls_count|", cch)[1])[0].c_str());
									int got = 0, receive = 0;
									modify_inventory(peer, 8470, got);
									if (count <= 0) {
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("We accepting any count but, please atleast donate 1 Golden Gem Lock!"), p.CreatePacket(peer);
										break;
									}
									else if (got < count) {
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("We know you want to donate that much but you don't have that much Golden Gem Lock!"), p.CreatePacket(peer);
										Algorithm::send_console(peer, "You don't have that many");
										break;
									}
									else {
										receive = count * -1;
										int dapat = count * 1000000;
										modify_inventory(peer, 8470, receive);
										string name_ = pInfo(peer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											gamepacket_t p1, p2;
											p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("Thank You for your Donation"), p1.CreatePacket(peer);
											p2.Insert("OnConsoleMessage"), p2.Insert("Thank you for the Donation"), p2.CreatePacket(peer);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											pInfo(peer)->total_recycle_wl += count * 1000000;
											Growch_Update.total_s4tb = (Growch_Update.total_s4tb + dapat);
											save_player(pInfo(peer), false);
										}
									}
								}
								catch (...) {
									break;
								}
							}
							else if (cch.find("buttonClicked|confirm_slc") != string::npos) {
										try {
											int count = atoi(explode("\n", explode("bgls_count|", cch)[1])[0].c_str());
											int got = 0, receive = 0;
											got = pInfo(peer)->litecoin;
											int harga = 0;
											int jual = (price_lt / 40);
											harga = (price_lt - jual);
											if (count <= 0) {
												gamepacket_t p;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
												break;
											}
											else if (got < count) {
												gamepacket_t p;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You don't have that many!"), p.CreatePacket(peer);
												Algorithm::send_console(peer, "You don't have that many");
												break;
											}
											else if (got >= count) {
												receive = count * harga;
												string name_ = pInfo(peer)->world;
												vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
												if (p != worlds.end()) {
													gamepacket_t p1, p2;
													p1.Insert("OnTalkBubble"), p1.Insert(pInfo(peer)->netID), p1.Insert("`oYou Sold `w" + to_string(count) + "`1 Litecoin `oFor `5" + to_string(receive) + " Gems"), p1.CreatePacket(peer);
													p2.Insert("OnConsoleMessage"), p2.Insert("`oYou Sold `w" + to_string(count) + "`1 Litecoin `oFor `5" + to_string(receive) + " Gems"), p2.CreatePacket(peer);
													packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
													pInfo(peer)->litecoin -= count;
													gamepacket_t p;
													p.Insert("OnSetBux");
													p.Insert(pInfo(peer)->gems += receive);
													p.Insert(0);
													Crypto_Update.crypto_history.push_back("\nadd_label_with_icon|small|" + pInfo(peer)->tankIDName + " Sold " + to_string(count) + " Litecoin for `5" + to_string(receive) + " Gems `w[`1Rate: "+ to_string(harga) + " Gems`w]|left|10014|");
													pInfo(peer)->history_crypto.push_back("\nadd_label_with_icon|small|You Sold " + to_string(count) + " Litecoin for `5" + to_string(receive) + " Gems `w[`1Rate: " + to_string(harga) + " Gems`w]|left|10002|");
													p.CreatePacket(peer);
													save_player(pInfo(peer), false);
												}
											}
										}
										catch (...) {
											break;
										}
									}
							else if (cch.find("buttonClicked|tradecrypto") != string::npos) {
								historycr(peer);
								break;
							}
							else if (cch.find("buttonClicked|bgls_takes") != string::npos) {
								int bgls = pInfo(peer)->bank_p;
								if (bgls == 0 || bgls <= 0) break;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWithdraw Blue Gem Locks````|left|7188|\nadd_label|small|Withdraw how many? (you have `3" + setGems(bgls) + "``) in the bank!|left|\nadd_text_input|bgl_withdraw|`wAmount:``|0|3|\nadd_spacer|small|\nadd_button|7188w_bgl|`^Withdraw``|noflags|0|0|\nend_dialog|bank_deposit|Nevermind.||");
								p.CreatePacket(peer);
								break;
							}
							/* int maubrp = 0;
							int bank = 0, maubrp = 0;
							bank = pInfo(peer)->bank_p;
							int gots = 0;
							modify_inventory(peer, 7188, gots);
							if (bank < maubrp) {
								gamepacket_t a;
								a.Insert("OnConsoleMessage"), a.Insert("Your BGL in bank doesnt enough");
								a.CreatePacket(peer);
								return;
							}
							if (maubrp > 200) return;
							if (to_string(maubrp).find_first_not_of("1234567890") != string::npos) return;
							int gotw = 0;
							modify_inventory(peer, 7188, gotw += maubrp);
							pInfo(peer)->bank_p -= maubrp;
							gamepacket_t a;
							ATIATI ERROR WKWKWK
							break;
							} */
							else if (cch.find("buttonClicked|7188w_bgl") != string::npos) {
								try {
									int maubrp = atoi(explode("\n", explode("bgl_withdraw|", cch)[1])[0].c_str());
									//int maubrp = 0;
									int bank = 0;
									bank = pInfo(peer)->bank_p;
									int fler = 0;
									modify_inventory(peer, 7188, fler);
									if (bank < maubrp) {
										gamepacket_t a;
										a.Insert("OnConsoleMessage"), a.Insert("Your BGL in bank doesnt enough");
										a.CreatePacket(peer);
										break;
									}
									if (maubrp > 200) break;
									if (to_string(maubrp).find_first_not_of("1234567890") != string::npos) break;
									int oky = 0;
									modify_inventory(peer, 7188, oky += maubrp);
									pInfo(peer)->bank_p -= maubrp;
									gamepacket_t a;
									a.Insert("OnConsoleMessage"), a.Insert("You withdraw " + to_string(maubrp) + " From");
									break;
								}
								catch (...) {
									break;
								}
							}
							break;
						}
						if (cch.find("action|dialog_return\ndialog_name|grow4goodtasks_dialog") != string::npos) {
							if (cch.find("buttonClicked|tab_rewards") != string::npos) {
								grow4good_reward(peer);
								break;
							}
							if (cch.find("buttonClicked|tab_tasks") != string::npos) {
								grow4good(peer, true, "tab_tasks", 0);
								break;
							}
							else if (cch.find("buttonClicked|claimreward") != string::npos) {
								if (pInfo(peer)->grow4good_points < 240) break;
								else {
									int dapat = 1;
									pInfo(peer)->grow4good_points -= 240;
									vector<int> list = {7962, 9526, 10394, 5138, 5140, 5142, 10836, 10838};
									int item = list[rand() % list.size()];
									if (item == 7962) dapat = 50;
									else if (item == 9526) dapat = 50;
									modify_inventory(peer, item, dapat);
									Algorithm::send_bubble(peer, pInfo(peer)->netID, "You Received "+to_string(dapat) + " " + items[item].name + "");
									break;
								}
							}
						}
						else if (cch.find("action|dialog_return\ndialog_name|btn_bet") != string::npos) {
							Sendcmd(peer, "/casino", true);
							break;
                        }
							else if (cch.find("action|dialog_return\ndialog_name|Geoff") != string::npos) {
									if (cch.find("buttonClicked|Bet_Gems") != string::npos) {
										gamepacket_t p;
										p.Insert("OnDialogRequest");
										p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Bet with gems!``|left|112|\nadd_text_input|count||1|5|\nadd_button|Ok_Gems|Okay!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nadd_smalltext|`6You're currently have : " + setGems(pInfo(peer)->gems) + "!``|left|\nend_dialog|Geoff|Nevermind||");
										p.CreatePacket(peer);
									}
									else if (cch.find("buttonClicked|Ok_Gems") != string::npos) {
										try {
											int Total = atoi(explode("\n", explode("count|", cch)[1])[0].c_str());
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
											if (Total > pInfo(peer)->gems) p.Insert("Sorry, you doesn't have enough gems!");
											else if (Total <= 0) p.Insert("Sorry, that's doesn't seems fair!");
											else {
												pInfo(peer)->gems -= Total;
												pInfo(peer)->Bet_What = 0, pInfo(peer)->Gems = Total, pInfo(peer)->Already_Bet = true;
												p.Insert("Succesfully, you has been bet! " + setGems(Total) + " gems!");
												{
													gamepacket_t p;
													p.Insert("OnSetBux");
													p.Insert(pInfo(peer)->gems);
													p.Insert(1);
													p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
													if (pInfo(peer)->supp >= 2) {
														p.Insert((float)33796, (float)1, (float)0);
													}
													p.CreatePacket(peer);
												}
											}
											p.Insert(0), p.Insert(0), p.CreatePacket(peer);
										}
										catch (...) {
											break;
										}
									}
									else if (cch.find("buttonClicked|ok") != string::npos) {
										try {
											int ID = atoi(explode("\n", explode("itemID|", cch)[1])[0].c_str());
											int Total = atoi(explode("\n", explode("count|", cch)[1])[0].c_str());
											int A = -Total, B = Total;
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
											if (modify_inventory(peer, ID, Total) == 0) {
												modify_inventory(peer, ID, A);
												pInfo(peer)->Offer = ID;
												pInfo(peer)->Bet_What = 1, pInfo(peer)->Gems = Total, pInfo(peer)->Already_Bet = true;
												p.Insert("Succesfully, you has been bet! " + setGems(B) + " " + items[ID].name + "!");
											}
											else if (Total <= 0) p.Insert("Sorry, that's doesn't seems fair!");
											else {
												p.Insert("You didn't have enough of them!");
											}
											p.Insert(0), p.Insert(0), p.CreatePacket(peer);
										}
										catch (...) {
											break;
										}
									}
									else if (cch.find("buttonClicked|change_amount") != string::npos) {
										gamepacket_t p;
										p.Insert("OnDialogRequest");
										if (pInfo(peer)->Bet_What == 0) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Bet with gems!``|left|112|\nadd_text_input|count||1|5|\nadd_button|Ok_Gems|Okay!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nadd_smalltext|`6You're currently have : " + setGems(pInfo(peer)->gems) + "!``|left|\nend_dialog|Geoff|Nevermind||");
										else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Bet with locks!``|left|" + to_string(pInfo(peer)->Offer == 0 ? 1796 : pInfo(peer)->Offer) + "|\nadd_text_input|count||1|5|\nadd_button|Ok_Locks|Okay!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nadd_smalltext|`6You're currently Choose : " + items[pInfo(peer)->Offer].name + "!``|left|\nend_dialog|Geoff|Nevermind||");
										p.CreatePacket(peer);
									}
									else if (cch.find("buttonClicked|Bet") != string::npos) {
										int get37 = rand() % 37, get37_2 = rand() % 37;
										string color = "", color2 = "";
										if (get37 == 36 || get37 == 34 || get37 == 32 || get37 == 30 || get37 == 27 || get37 == 25 || get37 == 23 || get37 == 21 || get37 == 19 || get37 == 18 || get37 == 16 || get37 == 12 || get37 == 9 || get37 == 7 || get37 == 5 || get37 == 3 || get37 == 1) color = "`4";
										else if (get37 == 0) color = "`2";
										else color = "`b";
										if (get37_2 == 36 || get37_2 == 34 || get37_2 == 32 || get37_2 == 30 || get37_2 == 27 || get37_2 == 25 || get37_2 == 23 || get37_2 == 21 || get37_2 == 19 || get37_2 == 18 || get37_2 == 16 || get37_2 == 12 || get37_2 == 9 || get37_2 == 7 || get37_2 == 5 || get37_2 == 3 || get37_2 == 1) color2 = "`4";
										else if (get37_2 == 0) color2 = "`2";
										else color2 = "`b";
										string wheel = "`7[``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` spun the wheel and got " + color + to_string(get37) + "``!`7]``";
										string wheel2 = "`7[``Hoster spun the wheel and got " + color2 + to_string(get37_2) + "``!`7]``";
										gamepacket_t p(2000), p1(2000), p2(4000), a(4000), b(6000);
										p1.Insert("OnConsoleMessage"); p1.Insert(wheel);
										p2.Insert("OnConsoleMessage"); p2.Insert(wheel2);
										p.Insert("OnTalkBubble"), a.Insert("OnTalkBubble"), b.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID), a.Insert(pInfo(peer)->netID), b.Insert(pInfo(peer)->netID);
										p.Insert(wheel); a.Insert(wheel2);
										if (get37 > get37_2 and get37_2 != 0 or get37 == 0 and get37_2 != 0) {
											pInfo(peer)->gems += pInfo(peer)->Gems * 2;
											{
												gamepacket_t p(6000);
												p.Insert("OnSetBux");
												p.Insert(pInfo(peer)->gems);
												p.Insert(1);
												p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
												if (pInfo(peer)->supp >= 2) {
													p.Insert((float)33796, (float)1, (float)0);
												}
												p.CreatePacket(peer);
											}
											b.Insert("Congrats you won the bet!");
											packet_(peer, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|6000");
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == pInfo(peer)->world) {
													PlayerMoving data_{};
													data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
													data_.plantingTree = 6000;
													BYTE* raw = packPlayerMoving(&data_);
													send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
													delete[] raw;
												}
											}
										}
										else if (get37 == get37_2) {
											b.Insert("You tie with the Hoster! You both knocked!");
											packet_(peer, "action|play_sfx\nfile|audio/loser.wav\ndelayMS|6000");
										}
										else {
											b.Insert("Sorry, you lost the game!");
											packet_(peer, "action|play_sfx\nfile|audio/loser.wav\ndelayMS|6000");
										}
										pInfo(peer)->Bet_What = 0, pInfo(peer)->Gems = 0, pInfo(peer)->Already_Bet = false;
										p2.CreatePacket(peer); p1.CreatePacket(peer); p.CreatePacket(peer), a.CreatePacket(peer), b.CreatePacket(peer);
									}
									else if (cch.find("buttonClicked|back") != string::npos) {
										pInfo(peer)->Offer = 0;
										string Dialog;
										auto SmallLock = 0, BigLock = 0, BoxedLock = 0, HugeLock = 0, WorldLock = 0, DiamondLock = 0, BlueGemLock = 0;
										for (auto i = 0; i < pInfo(peer)->inv.size(); i++) {
											if (pInfo(peer)->inv[i].id == 202 && pInfo(peer)->inv[i].count > 0) {
												SmallLock = pInfo(peer)->inv[i].count;
												break;
											}
										}
										for (auto i = 0; i < pInfo(peer)->inv.size(); i++) {
											if (pInfo(peer)->inv[i].id == 204 && pInfo(peer)->inv[i].count > 0) {
												BigLock = pInfo(peer)->inv[i].count;
												break;
											}
										}
										for (auto i = 0; i < pInfo(peer)->inv.size(); i++) {
											if (pInfo(peer)->inv[i].id == 10000 && pInfo(peer)->inv[i].count > 0) {
												BoxedLock = pInfo(peer)->inv[i].count;
												break;
											}
										}
										for (auto i = 0; i < pInfo(peer)->inv.size(); i++) {
											if (pInfo(peer)->inv[i].id == 206 && pInfo(peer)->inv[i].count > 0) {
												HugeLock = pInfo(peer)->inv[i].count;
												break;
											}
										}
										for (auto i = 0; i < pInfo(peer)->inv.size(); i++) {
											if (pInfo(peer)->inv[i].id == 242 && pInfo(peer)->inv[i].count > 0) {
												WorldLock = pInfo(peer)->inv[i].count;
												break;
											}
										}
										for (auto i = 0; i < pInfo(peer)->inv.size(); i++) {
											if (pInfo(peer)->inv[i].id == 1796 && pInfo(peer)->inv[i].count > 0) {
												DiamondLock = pInfo(peer)->inv[i].count;
												break;
											}
										}
										for (auto i = 0; i < pInfo(peer)->inv.size(); i++) {
											if (pInfo(peer)->inv[i].id == 7188 && pInfo(peer)->inv[i].count > 0) {
												BlueGemLock = pInfo(peer)->inv[i].count;
												break;
											}
										}
										gamepacket_t p;
										p.Insert("OnDialogRequest");
										p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Hoster, the gambler``|left|9436|\nadd_smalltext|Hello there! How're you guys doing right now? Sounds cool would you like bet with me, if you win you get double what you offer and if you lose you walk with `4nothing``!|left|\nadd_smalltext|`6*Note: If the server down/disconnect and you're in betting, all what you bet will lose! Be carefull...|left|\nadd_spacer|small|" + Dialog + "\nadd_spacer|small|\nadd_textbox|Your bet :|left|" + (string(pInfo(peer)->Already_Bet ? (pInfo(peer)->Bet_What == 0 ? "\nadd_button_with_icon|change_amount||frame|" + to_string(pInfo(peer)->Offer) + "||\nadd_custom_margin|x:-40;y:0|\nadd_textbox|Current Bet : " + setGems(pInfo(peer)->Gems) + " gems!|left||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_margin|x:0;y:-80|" : "\nadd_button_with_icon|change_amount||frame|" + to_string(pInfo(peer)->Offer) + "||\nadd_custom_margin|x:-40;y:0|\nadd_textbox|Current Bet : " + to_string(pInfo(peer)->Gems) + " " + items[pInfo(peer)->Offer].name + "|left||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_margin|x:0;y:-80|") : "\nadd_button|Bet_Gems|Bet for amount of gems!|off|0|0|")) + "\nadd_spacer|small|" + (string(pInfo(peer)->Already_Bet ? "\nadd_button|Bet|Lets Play!|noflags|0|0|" : "\nadd_textbox|You didn't bet anything!|left|\nadd_spacer|small|")) + "\nend_dialog|Geoff|Nevermind||");
										p.CreatePacket(peer);
									}
									break;
							}
						else if (cch.find("action|killstore") != string::npos) {
							break;
						}
						else if (cch.find("action|drop") != string::npos) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (pInfo(peer)->inv.size() < 0) break;
							if (pInfo(peer)->Cheat_FastDrop) {
								if (p != worlds.end()) {
									vector<string> t_ = explode("|", cch);
									if (t_.size() < 4) break;
									int id_ = atoi(explode("\n", t_[3])[0].c_str()), c_ = 0;
									if (id_ <= 0 or id_ >= items.size()) break;
									int dropCount = 0;
									World* world_ = &worlds[p - worlds.begin()];
									modify_inventory(peer, id_, c_);
									dropCount = 0 - c_;
									if (find(world_->active_jammers.begin(), world_->active_jammers.end(), 4758) != world_->active_jammers.end()) {
										if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->coown and !guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end()) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("The Mini-Mod says no dropping items in this world!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
											break;
										}
									}
									if (items[id_].untradeable or id_ == 1424 or id_ == 5816) {
										gamepacket_t p;
										p.Insert("OnTextOverlay");
										p.Insert("You can't drop that.");
										p.CreatePacket(peer);
										break;
									}
									string name_ = pInfo(peer)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										World* world_ = &worlds[p - worlds.begin()];
										WorldDrop drop_{};
										drop_.id = id_;
										drop_.count = c_;
										drop_.uid = uint16_t(world_->drop.size()) + 1;
										int a_ = rand() % 12;
										drop_.x = (pInfo(peer)->state == 16 ? pInfo(peer)->x - (a_ + 20) : (pInfo(peer)->x + 20) + a_);
										drop_.y = pInfo(peer)->y + rand() % 16;
										if (drop_.x / 32 < 0 or drop_.x / 32 >= 100 or drop_.y / 32 < 0 or drop_.y / 32 >= 60) {
											gamepacket_t p;
											p.Insert("OnTextOverlay");
											p.Insert("You can't drop that here, face somewhere with open space.");
											p.CreatePacket(peer);
											break;
										}
										BlockTypes type_ = FOREGROUND;
										WorldBlock* block_ = &world_->blocks[(pInfo(peer)->state == 16 ? drop_.x / 32 : round((double)drop_.x / 32)) + (drop_.y / 32 * 100)];
										if (items[block_->fg].collisionType == 1 || block_->fg == 6 || items[block_->fg].entrance || items[block_->fg].toggleable and is_false_state(world_->blocks[(pInfo(peer)->state == 16 ? drop_.x / 32 : round((double)drop_.x / 32)) + (drop_.y / 32 * 100)], 0x00400000)) {
											gamepacket_t p;
											p.Insert("OnTextOverlay");
											p.Insert(items[block_->fg].blockType == BlockTypes::MAIN_DOOR ? "You can't drop items on the white door." : "You can't drop that here, face somewhere with open space.");
											p.CreatePacket(peer);
											break;
										}
										int count_ = 0;
										bool dublicated = false;
										for (int i_ = 0; i_ < world_->drop.size(); i_++) {
											if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16) {
												count_ += 1;
											}
											if (world_->drop[i_].id == id_) if (world_->drop[i_].count + drop_.count < 200) dublicated = true;
										}
										if (!dublicated) {
											if (count_ > 20) {
												gamepacket_t p;
												p.Insert("OnTextOverlay");
												p.Insert("You can't drop that here, find an emptier spot!");
												p.CreatePacket(peer);
												break;
											}
										}
										int dropped = c_; bool Growganoth = false;
										if (modify_inventory(peer, id_, dropCount) == 0) {

											if (world_->name == "GROWGANOTH" && Halloween) {
												if (drop_.x / 32 >= 47 and drop_.x / 32 <= 52 and drop_.y / 32 == 15) {
													vector<int> Maw_Prize{};
													bool Guaranteed_Drops = false, Consumable = false;
													int Reward = 0, Give = 1, Give_Back = abs(dropped);
													if (items[id_].consume_prize != 0 && items[id_].consume_needed != 0) Growganoth = true, Consumable = true;
													if (items[id_].rarity != 0 && items[id_].rarity < 367) {
														if (items[id_].rarity >= 1) Maw_Prize.push_back(1208);
														if (items[id_].rarity >= 5) Maw_Prize.insert(Maw_Prize.end(), { 1992,5256,11348 });
														if (items[id_].rarity >= 10) Maw_Prize.insert(Maw_Prize.end(), { 1222,11342,1198,12786 });
														if (items[id_].rarity >= 15) Maw_Prize.insert(Maw_Prize.end(), { 1982,1200 });
														if (items[id_].rarity >= 20) Maw_Prize.insert(Maw_Prize.end(), { 4160,1220,10198 });
														if (items[id_].rarity >= 25) Maw_Prize.insert(Maw_Prize.end(), { 5240,1202 });
														if (items[id_].rarity >= 30) Maw_Prize.insert(Maw_Prize.end(), { 1238,5238,4162,10316,10196,10196 });
														if (items[id_].rarity >= 35) Maw_Prize.insert(Maw_Prize.end(), { 9044,1168 });
														if (items[id_].rarity >= 40) Maw_Prize.insert(Maw_Prize.end(), { 3116,4164,1172,12788 });
														if (items[id_].rarity >= 45) Maw_Prize.push_back(1230);
														if (items[id_].rarity >= 50) Maw_Prize.insert(Maw_Prize.end(), { 1192,11340,1194,10202 });
														if (items[id_].rarity >= 55) Maw_Prize.insert(Maw_Prize.end(), { 1226,7108 });
														if (items[id_].rarity >= 60) Maw_Prize.insert(Maw_Prize.end(), { 1196,12784 });
														if (items[id_].rarity >= 65) Maw_Prize.insert(Maw_Prize.end(), { 1236,9046 });
														if (items[id_].rarity >= 70) Maw_Prize.insert(Maw_Prize.end(), { 1980,1972,7110,1182,1994,1184,1186,1188,11330 });
														if (items[id_].rarity >= 73) Maw_Prize.insert(Maw_Prize.end(), { 10204,3102,4154,5232,5224,5222 });
														if (items[id_].rarity >= 75) Maw_Prize.push_back(1988);
														if (items[id_].rarity >= 80) Maw_Prize.insert(Maw_Prize.end(), { 4158,7128,1170,12790 });
														if (items[id_].rarity >= 85) Maw_Prize.push_back(1984);
														if (items[id_].rarity >= 90) Maw_Prize.insert(Maw_Prize.end(), { 1216,1218,5248,7114,10322,7112 });
														if (items[id_].rarity >= 97) Maw_Prize.push_back(3106);
														if (items[id_].rarity >= 100) Maw_Prize.push_back(7130);
														if (items[id_].rarity >= 101) Maw_Prize.push_back(3110);
														Reward = Maw_Prize[rand() % Maw_Prize.size()];
														Growganoth = true;
													}
													if (id_ == 10328) {
														gamepacket_t p;
														p.Insert("OnProgressUIUpdateValue"); p.Insert(pInfo(peer)->Darking_Sacrifice); p.Insert(0); p.CreatePacket(peer);
														Maw_Prize = { 12772, 12416, 12396, 12418, 12420, 12780, 10236  ,  4152  , 3114  , 1250  , 11314  , 3108  , 1956  , 11332  , 11336  , 11334  , 9042  ,9048  , 3126  , 10186  , 1990  , 1968  , 4166  , 5208  , 9056  , 7122  , 4172  , 4156  , 1234  , 5250  , 5254  , 5252  , 4138  , 4146  , 4140  , 4142  , 4148  , 4144  , 2000  , 1960  , 5210  , 1948  , 1214  , 7100  , 1966  , 1962  , 4188  , 4186  , 4190  , 10192  , 4136  , 10212  , 5236  , 5216  , 5218  , 5220  , 5214  , 4248  , 4182  , 4246  , 3098  , 5244  , 5256  , 10232  , 3118  , 10194  , 4192  , 1178  , 11316  , 1232  , 3124  , 11312  , 9040  , 10190  , 9034  , 3122  , 9050  , 9054  , 9052  , 7126  , 10200  , 10234  , 7124  , 11320  , 1210, 9018, 9538 };
														if (rand() % 1000 < 1 or pInfo(peer)->tankIDName == "Ritshu" and pInfo(peer)->hand == 5176) Maw_Prize = { 5176, 1970, 12414, 9114, 11322, 7104, 10206, 11318, 10184, 3100, 7102 };
														Reward = Maw_Prize[rand() % Maw_Prize.size()];
														Growganoth = true;
														int Give_Again = Give_Back - 1;
														if (abs(dropped) > 1) modify_inventory(peer, id_, Give_Again);
														dropped = 1;
													}
													if (id_ == 1950) Growganoth = true, Guaranteed_Drops = true, Reward = 4152;
													if (id_ == 2722) Growganoth = true, Guaranteed_Drops = true, Reward = 3114;
													if (id_ == 910) Growganoth = true, Guaranteed_Drops = true, Reward = 1250;
													if (id_ == 11046) Growganoth = true, Guaranteed_Drops = true, Reward = 11314;
													if (id_ == 94 or id_ == 2636 or id_ == 604 or id_ == 1956) Growganoth = true, Guaranteed_Drops = true, Reward = 3108;
													if (id_ == 276 or id_ == 274) Growganoth = true, Guaranteed_Drops = true, Reward = 1956;
													if (id_ == 6300) Growganoth = true, Guaranteed_Drops = true, Reward = 7102;
													if (id_ == 10730) Growganoth = true, Guaranteed_Drops = true, Reward = 11332;
													if (id_ == 10734) Growganoth = true, Guaranteed_Drops = true, Reward = 11350;
													if (id_ == 10732) Growganoth = true, Guaranteed_Drops = true, Reward = 11334;
													if (id_ == 6176) Growganoth = true, Guaranteed_Drops = true, Reward = 9042;
													if (id_ == 3040) Growganoth = true, Guaranteed_Drops = true, Reward = 3100;
													if (id_ == 6144) Growganoth = true, Guaranteed_Drops = true, Reward = 7104;
													if (id_ == 7998) Growganoth = true, Guaranteed_Drops = true, Reward = 9048;
													if (id_ == 1162) Growganoth = true, Guaranteed_Drops = true, Reward = 3126;
													if (id_ == 9322) Growganoth = true, Guaranteed_Drops = true, Reward = 10184;
													if (id_ == 7696) Growganoth = true, Guaranteed_Drops = true, Reward = 10186;
													if (id_ == 1474) Growganoth = true, Guaranteed_Drops = true, Reward = 1990;
													if (id_ == 1506) Growganoth = true, Guaranteed_Drops = true, Reward = 1968;
													if (id_ == 2386) Growganoth = true, Guaranteed_Drops = true, Reward = 4166;
													if (id_ == 9364) Growganoth = true, Guaranteed_Drops = true, Reward = 10206;
													if (id_ == 10576) Growganoth = true, Guaranteed_Drops = true, Reward = 11322;
													if (id_ == 4960) Growganoth = true, Guaranteed_Drops = true, Reward = 5208;
													if (id_ == 6196) Growganoth = true, Guaranteed_Drops = true, Reward = 9056;
													if (id_ == 4326) Growganoth = true, Guaranteed_Drops = true, Reward = 7122;
													if (id_ == 2860 or id_ == 2268) Growganoth = true, Guaranteed_Drops = true, Reward = 4172;
													if (id_ == 1114) Growganoth = true, Guaranteed_Drops = true, Reward = 4156;
													if (id_ == 362) Growganoth = true, Guaranteed_Drops = true, Reward = 1234;
													if (id_ == 11574) Growganoth = true, Guaranteed_Drops = true, Reward = 12772;
													if (id_ == 4334) Growganoth = true, Guaranteed_Drops = true, Reward = 5250;
													if (id_ == 4338) Growganoth = true, Guaranteed_Drops = true, Reward = 5252;
													if (id_ == 1408) Growganoth = true, Guaranteed_Drops = true, Reward = 5254;
													if (id_ == 3288) Growganoth = true, Guaranteed_Drops = true, Reward = 4138;
													if (id_ == 3290) Growganoth = true, Guaranteed_Drops = true, Reward = 4140;
													if (id_ == 3292) Growganoth = true, Guaranteed_Drops = true, Reward = 4142;
													if (id_ == 3294) Growganoth = true, Guaranteed_Drops = true, Reward = 4144;
													if (id_ == 3296) Growganoth = true, Guaranteed_Drops = true, Reward = 4146;
													if (id_ == 3298) Growganoth = true, Guaranteed_Drops = true, Reward = 4148;
													if (id_ == 900 or id_ == 7752 or id_ == 7754 or id_ == 7136 or id_ == 1576 or id_ == 1378 or id_ == 7758 or id_ == 7760 or id_ == 7748) Growganoth = true, Guaranteed_Drops = true, Reward = 2000;
													if (id_ == 1746) Growganoth = true, Guaranteed_Drops = true, Reward = 1960;
													if (id_ == 5018) Growganoth = true, Guaranteed_Drops = true, Reward = 5210;
													if (id_ == 1252) Growganoth = true, Guaranteed_Drops = true, Reward = 1948;
													if (id_ == 1190) Growganoth = true, Guaranteed_Drops = true, Reward = 1214;
													if (id_ == 2868) Growganoth = true, Guaranteed_Drops = true, Reward = 7100;
													if (id_ == 11638) Growganoth = true, Guaranteed_Drops = true, Reward = 12780;
													if (id_ == 11534) Growganoth = true, Guaranteed_Drops = true, Reward = 12416;
													if (id_ == 1830) Growganoth = true, Guaranteed_Drops = true, Reward = 1966;
													if (items[id_].name.find("Chemical") != string::npos and id_ != 1962) Growganoth = true, Guaranteed_Drops = true, Reward = 1962;
													if (id_ == 3556) {
														Maw_Prize.insert(Maw_Prize.end(), { 4186, 4188 });
														Growganoth = true, Guaranteed_Drops = true, Reward = Maw_Prize[rand() % Maw_Prize.size()];
													}
													if (id_ == 762) Growganoth = true, Guaranteed_Drops = true, Reward = 4190;
													if (id_ == 3818) Growganoth = true, Guaranteed_Drops = true, Reward = 10192;
													if (id_ == 366) Growganoth = true, Guaranteed_Drops = true, Reward = 4136;
													if (id_ == 9262) Growganoth = true, Guaranteed_Drops = true, Reward = 10212;
													if (id_ == 5236) Growganoth = true, Guaranteed_Drops = true, Reward = 1294;
													if (id_ == 1246) Growganoth = true, Guaranteed_Drops = true, Reward = 5214;
													if (id_ == 1242) Growganoth = true, Guaranteed_Drops = true, Reward = 5216;
													if (id_ == 1244) Growganoth = true, Guaranteed_Drops = true, Reward = 5218;
													if (id_ == 1248) Growganoth = true, Guaranteed_Drops = true, Reward = 5220;
													if (id_ == 7026 or id_ == 7028 or id_ == 7030) Growganoth = true, Guaranteed_Drops = true, Reward = 12396;
													if (id_ == 3016 or id_ == 3018 or id_ == 5526 or id_ == 5528) Growganoth = true, Guaranteed_Drops = true, Reward = 4248;
													if (id_ == 3012 or id_ == 3014 or id_ == 2914) Growganoth = true, Guaranteed_Drops = true, Reward = 4246;
													if (id_ == 242) Growganoth = true, Guaranteed_Drops = true, Reward = 1212;
													if (id_ == 2972) Growganoth = true, Guaranteed_Drops = true, Reward = 4182;
													if (id_ == 1460) Growganoth = true, Guaranteed_Drops = true, Reward = 1970;
													if (id_ == 2392) Growganoth = true, Guaranteed_Drops = true, Reward = 9114;
													if (id_ == 3218 or id_ == 3020) Growganoth = true, Guaranteed_Drops = true, Reward = 3098;
													if (id_ == 3792) Growganoth = true, Guaranteed_Drops = true, Reward = 5244;
													if (id_ == 10634) Growganoth = true, Guaranteed_Drops = true, Reward = 11318;
													if (id_ == 1198) Growganoth = true, Guaranteed_Drops = true, Reward = 5256;
													if (id_ == 8468) Growganoth = true, Guaranteed_Drops = true, Reward = 10232;
													if (id_ == 2984) Growganoth = true, Guaranteed_Drops = true, Reward = 3118;
													if (id_ == 4360) Growganoth = true, Guaranteed_Drops = true, Reward = 10194;
													if (id_ == 10148) Growganoth = true, Guaranteed_Drops = true, Reward = 12418;
													if (items[id_].name.find("Sheet Music: ") != string::npos and id_ != 4192 or id_ == 412) Growganoth = true, Guaranteed_Drops = true, Reward = 4192;
													if (id_ == 5012 or id_ == 1018 or id_ == 592) Growganoth = true, Guaranteed_Drops = true, Reward = 1178;
													if (id_ == 10406) Growganoth = true, Guaranteed_Drops = true, Reward = 11316;
													if (id_ == 10652) Growganoth = true, Guaranteed_Drops = true, Reward = 12420;
													if (id_ == 882) Growganoth = true, Guaranteed_Drops = true, Reward = 1232;
													if (id_ == 1934) Growganoth = true, Guaranteed_Drops = true, Reward = 3124;
													if (id_ == 10626) Growganoth = true, Guaranteed_Drops = true, Reward = 11312;
													if (id_ == 6160) Growganoth = true, Guaranteed_Drops = true, Reward = 9040;
													if (id_ == 3794) Growganoth = true, Guaranteed_Drops = true, Reward = 10190;
													if (id_ == 8018) Growganoth = true, Guaranteed_Drops = true, Reward = 9034;
													if (id_ == 2390) Growganoth = true, Guaranteed_Drops = true, Reward = 3122;
													if (id_ == 9050) Growganoth = true, Guaranteed_Drops = true, Reward = 5246;
													if (id_ == 9052) Growganoth = true, Guaranteed_Drops = true, Reward = 5246;
													if (id_ == 9054) Growganoth = true, Guaranteed_Drops = true, Reward = 5246;
													if (id_ == 6798) Growganoth = true, Guaranteed_Drops = true, Reward = 7126;
													if (id_ == 9722 or id_ == 9724) Growganoth = true, Guaranteed_Drops = true, Reward = 10200;
													if (id_ == 9388) Growganoth = true, Guaranteed_Drops = true, Reward = 10234;
													if (id_ == 4732) Growganoth = true, Guaranteed_Drops = true, Reward = 7124;
													if (id_ == 10804) Growganoth = true, Guaranteed_Drops = true, Reward = 11320;
													if (id_ == 11666) Growganoth = true, Guaranteed_Drops = true, Reward = 12414;
													if (items[id_].name.find("Weather Machine - ") != string::npos and id_ != 932 or id_ == 8836 or id_ == 1210) Growganoth = true, Guaranteed_Drops = true, Reward = 1210;
													if (id_ != 0 and Reward == 0) Growganoth = true;
													if (Growganoth) {
														gamepacket_t a, b;
														a.Insert("OnTalkBubble"), a.Insert(pInfo(peer)->netID);
														b.Insert("OnConsoleMessage");
														if (Reward != 0) {
															gamepacket_t p, p2;
															if (Consumable) a.Insert("`4Growganoth turns your " + items[id_].ori_name + " into an " + items[items[id_].consume_prize].ori_name + " and hatches it with evil!``"), b.Insert("`4Growganoth turns your " + items[id_].ori_name + " into an " + items[items[id_].consume_prize].ori_name + " and hatches it with evil!``"), b.CreatePacket(peer);
															else a.Insert("`4Growganoth is pleased by your offering and grants a reward! Also, he eats you.``"), b.Insert("`4Growganoth is pleased by your offering and grants a reward! Also, he eats you.``"), b.CreatePacket(peer);
															p.Insert("OnConsoleMessage"), p.Insert("" + (string(abs(dropped) != 1 ? to_string(abs(dropped)) + " " : "")) + "`2" + items[id_].ori_name + "`` was devoured by Growganoth!"), p.CreatePacket(peer);
															p2.Insert("OnConsoleMessage");
															if (Guaranteed_Drops) {
																if (modify_inventory(peer, Reward, Give_Back) == 0) {
																	p2.Insert((string(abs(dropped) != 1 ? to_string(abs(dropped)) : "A")) + " `2" + items[Reward].ori_name + "`` was bestowed upon you!");
																	p2.CreatePacket(peer);
																}
																else {
																	modify_inventory(peer, id_, Give_Back);
																	p2.Insert("Nothing was upon to you! you didn't have enough inventory!");
																	p2.CreatePacket(peer);
																}
															}
															else {
																if (modify_inventory(peer, Reward, Give) == 0) {
																	p2.Insert("A `2" + items[Reward].ori_name + "`` was bestowed upon you!");
																	p2.CreatePacket(peer);
																}
																else {
																	if (id_ == 10328) Give_Back = 1;
																	modify_inventory(peer, id_, Give_Back);
																	p2.Insert("Nothing was upon to you! you didn't have enough inventory!");
																	p2.CreatePacket(peer);
																}
															}
															if (Guaranteed_Drops) {
																gamepacket_t a, b;
																a.Insert("OnTalkBubble"), a.Insert(pInfo(peer)->netID);
																b.Insert("OnConsoleMessage"); a.Insert("`4Growganoth rejects your puny offering and eats you instead!``"), b.Insert("`4Growganoth rejects your puny offering and eats you instead!``"), b.CreatePacket(peer);
																a.Insert(0), a.Insert(0), a.CreatePacket(peer);
															}
															if (Reward == 9488 || Reward == 1970 || Reward == 12414 || Reward == 9114 || Reward == 11322 || Reward == 7104 || Reward == 10206 || Reward == 11318 || Reward == 10184 || Reward == 3100 || Reward == 7102) {
																if (id_ == 10328) {
																	gamepacket_t p;
																	p.Insert("OnConsoleMessage"), p.Insert("`4Growganoth`` honors " + (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name) + "`` with a `5Rare " + items[Reward].name + "`` for their Dark King's Offering!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																		p.CreatePacket(currentPeer);
																	}
																	lastsbworld = pInfo(peer)->world;
																}
															}
														}
														else {
															a.Insert("`4Growganoth rejects your puny offering and eats you instead!``"), b.Insert("`4Growganoth rejects your puny offering and eats you instead!``"), b.CreatePacket(peer);
															modify_inventory(peer, id_, Give_Back);
														}
														a.Insert(0), a.Insert(0), a.CreatePacket(peer);
														SendRespawn(peer, true, 0, 1);
													}
												}
												else {
													int Give_Back = abs(dropped);
													gamepacket_t p;
													p.Insert("OnTextOverlay");
													p.Insert("Not close enough to the maw!");
													p.CreatePacket(peer);
													modify_inventory(peer, id_, Give_Back);
													break;
												}
											}

											add_cctv(peer, "dropped", to_string(abs(dropped)) + " " + items[id_].name);
											if (!Growganoth) dropas_(world_, drop_, pInfo(peer)->netID);
										}
									}
								}
							}
							else {
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									vector<string> t_ = explode("|", cch);
									if (t_.size() < 4) break;
									int id_ = atoi(explode("\n", t_[3])[0].c_str()), c_ = 0;
									if (id_ <= 0 or id_ >= items.size()) break;
									if (find(world_->active_jammers.begin(), world_->active_jammers.end(), 4758) != world_->active_jammers.end()) {
										if (world_->owner_name != (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) and not pInfo(peer)->coown and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end()) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("The Mini-Mod says no dropping items in this world!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
											break;
										}
									}
									if (items[id_].untradeable or id_ == 1424) {
										gamepacket_t p;
										p.Insert("OnTextOverlay");
										p.Insert("You can't drop that.");
										p.CreatePacket(peer);
										break;
									}
									string name_ = pInfo(peer)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										World* world_ = &worlds[p - worlds.begin()];
										int a_ = rand() % 12;
										int x = (pInfo(peer)->state == 16 ? pInfo(peer)->x - (a_ + 20) : (pInfo(peer)->x + 20) + a_);
										int y = pInfo(peer)->y + rand() % 16;
										//BlockTypes type_ = FOREGROUND;
										int where_ = (pInfo(peer)->state == 16 ? x / 32 : round((double)x / 32)) + (y / 32 * 100);
										if (where_ < 0 || x < 0 || y < 0 || where_ > 5399) continue;
										WorldBlock* block_ = &world_->blocks[where_];
										if (items[block_->fg].collisionType == 1 || block_->fg == 6 || items[block_->fg].entrance || items[block_->fg].toggleable and is_false_state(world_->blocks[(pInfo(peer)->state == 16 ? x / 32 : round((double)x / 32)) + (y / 32 * 100)], 0x00400000)) {
											gamepacket_t p;
											p.Insert("OnTextOverlay");
											p.Insert(items[block_->fg].blockType == BlockTypes::MAIN_DOOR ? "You can't drop items on the white door." : "You can't drop that here, face somewhere with open space.");
											p.CreatePacket(peer);
											break;
										}
										int count_ = 0;
										bool dublicated = false;
										for (int i_ = 0; i_ < world_->drop.size(); i_++) {
											if (abs(world_->drop[i_].y - y) <= 16 and abs(world_->drop[i_].x - x) <= 16) {
												count_ += 1;
											}
											if (world_->drop[i_].id == id_) if (world_->drop[i_].count < 200) dublicated = true;
										}
										if (!dublicated) {
											if (count_ > 20) {
												gamepacket_t p;
												p.Insert("OnTextOverlay");
												p.Insert("You can't drop that here, find an emptier spot!");
												p.CreatePacket(peer);
												break;
											}
										}
									}
									modify_inventory(peer, id_, c_);
									{
										gamepacket_t p;
										p.Insert("OnDialogRequest");
										p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[id_].ori_name + "``|left|" + to_string(id_) + "|\nadd_textbox|How many to drop?|left|\nadd_text_input|count||" + to_string(c_) + "|5|\nembed_data|itemID|" + to_string(id_) + "" + (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->owner and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end()) ? "\nadd_textbox|If you are trying to trade an item with another player, use your wrench on them instead to use our Trade System! `4Dropping items is not safe!``|left|" : "") + "\nend_dialog|drop_item|Cancel|OK|");
										p.CreatePacket(peer);
										break;
									}
								}
							}
							break;
							}
							else if (cch.find("action|setRoleIcon") != string::npos || cch.find("action|setRoleSkin") != string::npos) {
								vector<string> t_ = explode("|", cch);
								if (t_.size() < 3) break;
								string id_ = explode("\n", t_[2])[0];
								if (not isdigit(id_[0])) break;
								uint32_t role_t = atoi(id_.c_str());
								if (cch.find("action|setRoleIcon") != string::npos) {
									if (role_t == 6) pInfo(peer)->roleIcon = role_t;
									else if (role_t == 0 and pInfo(peer)->t_lvl >= 50) pInfo(peer)->roleIcon = role_t;
									else if (role_t == 1 and pInfo(peer)->bb_lvl >= 50) pInfo(peer)->roleIcon = role_t;
									else if (role_t == 2 and pInfo(peer)->titleDoctor) pInfo(peer)->roleIcon = role_t;
									else if (role_t == 3 and pInfo(peer)->titleFisher) pInfo(peer)->roleIcon = role_t;
									else if (role_t == 4 and pInfo(peer)->titleChef) pInfo(peer)->roleIcon = role_t;
									else if (role_t == 5 and pInfo(peer)->titleStartopia) pInfo(peer)->roleIcon = role_t;
								}
								else {
									if (role_t == 6) pInfo(peer)->roleSkin = role_t;
									else if (role_t == 0 and pInfo(peer)->t_lvl >= 50) pInfo(peer)->roleSkin = role_t;
									else if (role_t == 1 and pInfo(peer)->bb_lvl >= 50) pInfo(peer)->roleSkin = role_t;
									else if (role_t == 2 and pInfo(peer)->unlockRoleSkin) pInfo(peer)->roleSkin = role_t;
									else if (role_t == 3 and pInfo(peer)->unlockRoleSkin) pInfo(peer)->roleSkin = role_t;
									else if (role_t == 4 and pInfo(peer)->unlockRoleSkin) pInfo(peer)->roleSkin = role_t;
									else if (role_t == 5 and pInfo(peer)->unlockRoleSkin) pInfo(peer)->roleSkin = role_t;
								}
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnSetRoleSkinsAndIcons"), p.Insert(pInfo(peer)->roleSkin), p.Insert(pInfo(peer)->roleIcon), p.Insert(0);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
									p.CreatePacket(currentPeer);
								}
								break;
						}

							else if (cch.find("action|setSkin") != string::npos) {
								vector<string> t_ = explode("|", cch);
								if (t_.size() < 3) break;
								string id_ = explode("\n", t_[2])[0];
								if (not isdigit(id_[0])) break;
								char* endptr = NULL;
								unsigned int skin_ = strtoll(id_.c_str(), &endptr, 10);
								if (skin_ == 3317842336 and pInfo(peer)->supp == 2 or skin_ == 3578898848 and pInfo(peer)->supp == 2 or skin_ == 3531226367 and pInfo(peer)->supp == 2 or skin_ == 4023103999 and pInfo(peer)->supp == 2 or skin_ == 1345519520 and pInfo(peer)->supp == 2 or skin_ == 194314239 and pInfo(peer)->supp == 2) pInfo(peer)->skin = skin_;
								else if (skin_ == 3578898848 and pInfo(peer)->gp or skin_ == 3317842336 and pInfo(peer)->gp) pInfo(peer)->skin = skin_;
								else if (skin_ != 1348237567 and skin_ != 1685231359 and skin_ != 2022356223 and skin_ != 2190853119 and skin_ != 2527912447 and skin_ != 2864971775 and skin_ != 3033464831 and skin_ != 3370516479) {
									if (pInfo(peer)->supp >= 1) {
										if (skin_ != 2749215231 and skin_ != 3317842431 and skin_ != 726390783 and skin_ != 713703935 and skin_ != 3578898943 and skin_ != 4042322175) break;
										else pInfo(peer)->skin = skin_;
									}
									else break;
								}
								else pInfo(peer)->skin = skin_;
								update_clothes(peer);
								break;
							}
							else if (cch.find("action|trash") != string::npos) {
							vector<string> t_ = explode("|", cch);
							if (t_.size() < 4) break;
							int id_ = atoi(explode("\n", t_[3])[0].c_str()), c_ = 0;
							if (id_ <= 0 or id_ >= items.size()) break;
							gamepacket_t p;
							if (id_ == 18 || id_ == 32 || id_ == 6336 || id_ == 8430) {
								packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
								p.Insert("OnTextOverlay"), p.Insert("You'd be sorry if you lost that!"), p.CreatePacket(peer);
								break;
							}
							modify_inventory(peer, id_, c_); // gauna itemo kieki
							if (pInfo(peer)->Cheat_FastTrash) {
								int adaBrp = c_, hapusBrp = 0;
								hapusBrp = 0 - c_;
								if (items[id_].untradeable) {
									int has_ = 0;
									modify_inventory(peer, id_, has_);
									if (has_ < c_) break;
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Recycle`` " + to_string(adaBrp) + " `w" + items[id_].name + "``|left|" + to_string(id_) + "|\nembed_data|itemID|" + to_string(id_) + "\nembed_data|count|" + to_string(adaBrp) + "\nadd_textbox|You are recycling an `9UNTRADEABLE`` item. Are you absolutely sure you want to do this? There is no way to get the item back if you select yes.|left|\nend_dialog|trash_item2|NO!|Yes, I am sure|");
									p.CreatePacket(peer);
									break;
								}
								if (modify_inventory(peer, id_, hapusBrp) == 0) {
									packet_(peer, "action|play_sfx\nfile|audio/trash.wav\ndelayMS|0");
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									if (pInfo(peer)->supp != 0) {
										int item = id_, maxgems = 0, receivegems = 0;
										int count = adaBrp;
										if (id_ % 2 != 0) item -= 1;
										maxgems = items[item].max_gems2;
										if (items[item].max_gems2 != 0) if (maxgems != 0) for (int i = 0; i < count; i++) receivegems += rand() % maxgems;
										if (items[item].max_gems3 != 0) receivegems = count * items[item].max_gems3;
										if (receivegems != 0) {
											pInfo(peer)->gems += receivegems;
											gamepacket_t p;
											p.Insert("OnSetBux");
											p.Insert(pInfo(peer)->gems);
											p.Insert(0);
											p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
											if (pInfo(peer)->supp >= 2) {
												p.Insert((float)33796, (float)1, (float)0);
											}
											p.CreatePacket(peer);
										}
										p.Insert((items[id_].blockType == BlockTypes::FISH ? (to_string(abs(c_))) + "lb." : to_string(adaBrp)) + " `w" + items[id_].ori_name + "`` recycled, `0" + setGems(receivegems) + "`` gems earned.");
									}
									else p.Insert((items[id_].blockType == BlockTypes::FISH ? (to_string(abs(c_))) + "lb." : to_string(adaBrp)) + " `w" + items[id_].ori_name + "`` trashed.");
									p.CreatePacket(peer);
									break;
								}
								break;
							}
							else {
								p.Insert("OnDialogRequest");
								if (pInfo(peer)->supp == 0) p.Insert("set_border_color|255,255,255,255\nset_bg_color|128,0,128,170\nset_default_color|`o\nadd_label_with_icon|big|`4Trash`` `w" + items[id_].ori_name + "``|left|" + to_string(id_) + "|\nadd_textbox|How many to `4destroy``? (you have " + to_string(c_) + ")|left|\nadd_text_input|count||0|5|\nembed_data|itemID|" + to_string(id_) + "\nend_dialog|trash_item|Cancel|OK|");
								else {
									int item = id_, maxgems = 0, maximum_gems = 0;
									if (id_ % 2 != 0) item -= 1;
									maxgems = items[item].max_gems2;
									if (items[item].max_gems3 != 0) maximum_gems = items[item].max_gems3;
									string recycle_text = "0" + (maxgems == 0 ? "" : "-" + to_string(maxgems)) + "";
									if (maximum_gems != 0) recycle_text = to_string(maximum_gems);
									p.Insert("set_border_color|255,255,255,255\nset_bg_color|128,0,128,170\nset_default_color|`o\nadd_label_with_icon|big|`4Recycle`` `w" + items[id_].ori_name + "``|left|" + to_string(id_) + "|\nadd_textbox|You will get " + recycle_text + " gems per item.|\nadd_textbox|How many to `4destroy``? (you have " + to_string(c_) + ")|left|\nadd_text_input|count||0|5|\nembed_data|itemID|" + to_string(id_) + "\nend_dialog|trash_item|Cancel|OK|");
								}
								p.CreatePacket(peer);
								break;
							}
							break;
						}
						else if (cch.find("action|info") != string::npos) {
							vector<string> t_ = explode("|", cch);
							if (t_.size() < 4) break;
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							int id_ = atoi(explode("\n", t_[3])[0].c_str());
							if (id_ > items.size() || id_ <= 0) break;
							if (id_ % 2 != 0) p.Insert("set_default_color|`o\nadd_label_with_ele_icon|big|`wAbout " + items[id_].ori_name + "``|left|" + to_string(id_) + "|" + to_string(items[id_ - 1].chi) + "|\nadd_spacer|small|\nadd_textbox|Plant this seed to grow a `0" + items[id_ - 1].ori_name + " Tree.``|left|\nadd_spacer|small|\nadd_textbox|Rarity: `0" + to_string(items[id_].rarity) + "``|left|\nadd_spacer|small|\nend_dialog|continue||OK|\n");
							else {
								string extra_ = "\nadd_textbox|";
								if (id_ == 18) {
									extra_ += "You've punched `w" + to_string(pInfo(peer)->punch_count) + "`` times.";
								} if (items[id_].blockType == BlockTypes::LOCK) {
									extra_ += "A lock makes it so only you (and designated friends) can edit an area.";
								} if (id_ == 5890) {
									extra_ += "|\nadd_smalltext|You can check " + items[id_].name + " here|left|\nadd_small_font_button|spfs|Check Extra Skills|left|\nadd_textbox|";
								} if (id_ == 5892) {
									extra_ += "|\nadd_smalltext|You can check " + items[id_].name + " here|left|\nadd_small_font_button|amfs|Check Extra Skills|left|\nadd_textbox|";
								} if (id_ == 5894) {
									extra_ += "|\nadd_smalltext|You can check " + items[id_].name + " here|left|\nadd_small_font_button|gdfs|Check Extra Skills|left|\nadd_textbox|";
								}
								if (items[id_].itemharga == true) extra_ += "<CR>This item is obtainable from /find and must pay 40K Gems";
								if (items[id_].itemfind == true) extra_ += "<CR>This item is obtainable from /find";
								if (items[id_].r_1 == 0 or items[id_].r_2 == 0) {
									if (items[id_].properties & Property_Untradable) {
									}
									else extra_ += "<CR>This item can't be spliced.";
								}
								else {
									extra_ += "Rarity: `w" + to_string(items[id_].rarity) + "``<CR><CR>To grow, plant a `w" + items[id_ + 1].name + "``.   (Or splice a `w" + items[items[id_].r_1].name + "`` with a `w" + items[items[id_].r_2].name + "``)<CR>";
								} if (items[id_].properties & Property_Dropless or items[id_].rarity == 999) {
									if (items[id_].properties & Property_Untradable) {

									}
									else {
										if (items[id_].r_1 != 0 or items[id_].r_2 != 0) {
										}
										else extra_ += "<CR>`1This item never drops any seeds.``";
									}
								} if (items[id_].properties & Property_Untradable) {
									extra_ += "<CR>`1This item cannot be dropped or traded.``";
								} if (items[id_].properties & Property_AutoPickup) {
									extra_ += "<CR>`1This item can't be destroyed - smashing it will return it to your backpack if you have room!``";
								}
								if (items[id_].properties & Property_MultiFacing && items[id_].properties & Property_Wrenchable) {
									extra_ += "<CR>`1This item can be placed in two directions, depending on the direction you're facing.``";
								}
								else {
									if (items[id_].properties & Property_Wrenchable) {
										extra_ += "<CR>`1This item has special properties you can adjust with the Wrench.``";
									}
									if (items[id_].properties & Property_MultiFacing) {
										extra_ += "<CR>`1This item can be placed in two directions, depending on the direction you're facing.``";
									}
								}
								if (items[id_].properties & Property_NoSelf) {
									extra_ += "<CR>`1This item has no use... by itself.``";
								}
								int punya = 0, punyaa = 0, kntl = 0;
								modify_inventory(peer, 7188, punya);
								modify_inventory(peer, 8470, punyaa);
								modify_inventory(peer, 2696, kntl);
								if (id_ == 7188 and punya >= 100) {
									extra_ += "|left|\nadd_smalltext|Convert 100 BGL to 1 GGL|left|\nadd_small_font_button|convert_1|Convert `eBGL ``to `9GGL``|";
								}
								if (id_ == 8470 and punyaa >= 1) {
									extra_ += "|left|\nadd_smalltext|Convert 1 GGL to 100 BGL|left|\nadd_small_font_button|convert_2|Convert `9GGL ``to `eBGL``|";
								}
								if (id_ == 8470 && punyaa >= 100) extra_ += "|left|\nadd_smalltext|Convert 1 GGL to 100 BGL|left|\nadd_small_font_button|convert_3|Convert `9GGL ``to `cCGL``|";
								if (id_ == 2696 && kntl >= 1) extra_ += "|left|\nadd_smalltext|Convert 1 CGL to 100 GGL|left|\nadd_small_font_button|convert_4|Convert `cCGL ``to `9GGL``|";
								extra_ += "|left|";
								if (extra_ == "\nadd_textbox||left|") extra_ = "";
								else extra_ = replace_str(extra_, "add_textbox|<CR>", "add_textbox|");

								string extra_ore = "";
								if (id_ == 9386) extra_ore = rare_text;
								if (id_ == 5136) extra_ore = rainbow_text;
								p.Insert("set_default_color|`o\nadd_label_with_ele_icon|big|`wAbout " + items[id_].name + "``|left|" + to_string(id_) + "|" + to_string(items[id_].chi) + "|\nadd_spacer|small|\nadd_textbox|" + items[id_].description + "|left|" + (extra_ore != "" ? "\nadd_spacer|small|\nadd_textbox|This item also drops:|left|" + extra_ore : "") + "" + (id_ == 8552 ? "\nadd_spacer|small|\nadd_textbox|Angelic Healings: " + to_string(pInfo(peer)->surgery_done) + "|left|" : "") + "\nadd_spacer|small|" + extra_ + "\nadd_spacer|small|\nend_dialog|continue||OK|\n");
							}
							p.CreatePacket(peer);
							break;
						}
							else if (cch.find("action|wrench") != string::npos) {
								vector<string> t_ = explode("|", cch);
								if (t_.size() < 4) break;
								int netID = atoi(explode("\n", t_[3])[0].c_str());
								if (pInfo(peer)->netID == netID) {
									//send_wrench_self(peer);
									pelerbiji(peer, true, "kerucim", 0);
								}
								else {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->slave.netID == netID and pInfo(currentPeer)->world == pInfo(peer)->world) {
											if (pInfo(currentPeer)->slave.owner == pInfo(peer)->tankIDName) {
												Algorithm::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|" + pInfo(currentPeer)->slave.owner + " Slave|left|18|\nadd_spacer|small|\nadd_label_with_icon|small|This slave is " + (pInfo(currentPeer)->slave.magnetron_id <= 0 ? "not" : "") + " using Magplant Remote|left|5640|\nadd_textbox|About Farmer Slave:|left|\nadd_smalltext|Farmer slave from NiceTopia is inspired from CreativePS (Koopa) and farmer slave is used to farming its owner slave block and the slave owner is free to talk, move or warping to another world|left|\nadd_spacer|spacer|\nadd_button|active|"+(pInfo(currentPeer)->slave.active ? "`4Disable `oslave now": "`2Activate `oslave") + "|left|\nadd_smalltext|Press this button to activate or disable your slave farming|left|\nadd_spacer|small|\nadd_button|kill|Kill Slave|left|\nadd_smalltext|Press this button if you want to kill/erase your slave|left|\nadd_spacer|small|" + (pInfo(peer)->magnetron_id != 0 && pInfo(peer)->magnetron_x != 0 && pInfo(peer)->magnetron_y != 0 ? "\nadd_button|setmagloc|Set Magplant Remote Location|left|\nadd_smalltext|Press this button if you want to set slave Magplant Remote Location|left|" : "\nadd_textbox|Please take the remote from magplant first before set slave magplant remote location|left|") + "\nadd_quick_exit|\nend_dialog|slaveoption|Close||");
											}
											else {
												Algorithm::send_overlay(peer, "Slave Access Denied");
											}
										}
										if (pInfo(currentPeer)->netID == netID and pInfo(currentPeer)->world == pInfo(peer)->world) {
											bool already_friends = false, trade_blocked = false, muted = false;
											for (int c_ = 0; c_ < pInfo(peer)->friends.size(); c_++) {
												if (pInfo(peer)->friends[c_].name == pInfo(currentPeer)->tankIDName) {
													already_friends = true;
													if (pInfo(peer)->friends[c_].block_trade)
														trade_blocked = true;
													if (pInfo(peer)->friends[c_].mute)
														muted = true;
													break;
												}
											}
											pInfo(peer)->last_wrenched = pInfo(currentPeer)->tankIDName;
											string name_ = pInfo(peer)->world;
											if (pInfo(peer)->Cheat_FastPull) {
												Sendcmd(peer, "/pull " + pInfo(peer)->last_wrenched, true);
												break;
											}
											if (pInfo(peer)->cheat_kick == 1) {
												Sendcmd(peer, "/kick " + pInfo(peer)->last_wrenched, true);
												break;
											}
											if (pInfo(peer)->cheat_ban == 1) {
												Sendcmd(peer, "/ban " + pInfo(peer)->last_wrenched, true);
												break;
											}
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												string msg2 = "";
												for (int i = 0; i < to_string(pInfo(currentPeer)->level).length(); i++) msg2 += "?";
												string inv_guild = "";
												string extra = "";
												if (pInfo(currentPeer)->guild_id != 0) {
													uint32_t guild_id = pInfo(currentPeer)->guild_id;
													vector<Guild>::iterator find_guild = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
													if (find_guild != guilds.end()) {
														Guild* guild_information = &guilds[find_guild - guilds.begin()];
														for (GuildMember member_search : guild_information->guild_members) {
															if (member_search.member_name == pInfo(currentPeer)->tankIDName) {
																if (guild_information->guild_mascot[1] == 0 and guild_information->guild_mascot[0] == 0) {
																	extra += "\nadd_label_with_icon|small|`9Guild: `2" + guild_information->guild_name + "``|left|5814|\nadd_textbox|`9Rank: `2" + (member_search.role_id == 0 ? "Member" : (member_search.role_id == 1 ? "Elder" : (member_search.role_id == 2 ? "Co-Leader" : "Leader"))) + "``|left|\nadd_spacer|small|";
																}
																else {
																	extra += "\nadd_dual_layer_icon_label|small|`9Guild: `2" + guild_information->guild_name + "``|left|" + to_string(guild_information->guild_mascot[1]) + "|" + to_string(guild_information->guild_mascot[0]) + "|1.0|1|\nadd_smalltext|`9Rank: `2" + (member_search.role_id == 0 ? "Member" : (member_search.role_id == 1 ? "Elder" : (member_search.role_id == 2 ? "Co-Leader" : "Leader"))) + "``|left|\nadd_spacer|small|";
																}
																break;
															}
														}
													}
												} if (pInfo(peer)->guild_id != 0 and pInfo(currentPeer)->guild_id == 0) {
													uint32_t guild_id = pInfo(peer)->guild_id;
													vector<Guild>::iterator find_guild = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
													if (find_guild != guilds.end()) {
														Guild* guild_information = &guilds[find_guild - guilds.begin()];
														for (GuildMember member_search : guild_information->guild_members) {
															if (member_search.member_name == pInfo(peer)->tankIDName) {
																if (member_search.role_id >= 1) {
																	inv_guild = "\nadd_button|invitetoguild|`2Invite to Guild``|noflags|0|0|";
																}
																break;
															}
														}
													}
												}
												time_t s__;
												s__ = time(NULL);
												int days_ = int(s__) / (60 * 60 * 24);
												double hours_ = (double)((s__ - pInfo(currentPeer)->playtime) + pInfo(currentPeer)->seconds) / 3600;
												string num_text = to_string(hours_), status = "";
												string rounded = num_text.substr(0, num_text.find(".") + 3);
												string gender = "";
												if (pInfo(currentPeer)->female) gender = "\nadd_label_with_icon|small|`wFemale|left|9836|\nadd_spacer|small|";
												if (pInfo(currentPeer)->male) gender = "\nadd_label_with_icon|small|`wMale|left|9834|\nadd_spacer|small|";
												string PVP = "\nadd_spacer|small|\n" + string(pInfo(peer)->PVP_Ongoing ? "add_smalltext|`4You're currently on battle!``|left|" : (pInfo(currentPeer)->PVP_Ongoing ? "add_smalltext|`4This player currently on battle!``|left|" : (pInfo(peer)->PVP_netID == pInfo(currentPeer)->netID ? "add_smalltext|`4You're already request a battle with him!``|left|\nadd_button|cancel_pvp|`4Cancel request!``|noflags|0|0|" : "add_button|battle_pvp|`4Ask for PVP``|noflags|0|0|")));
												string surgery = "\nadd_spacer|small|\nadd_button|start_surg|`$Perform Surgery``|noflags|0|0|\nadd_smalltext|Surgeon Skill: "+to_string(pInfo(peer)->surgery_skill) + "|left|";
												for (int i_ = 0; i_ < pInfo(currentPeer)->playmods.size(); i_++) if (pInfo(currentPeer)->playmods[i_].id == 89) surgery = "\nadd_spacer|small|\nadd_textbox|Recovering from surgery...|left|";
												if (pInfo(currentPeer)->hospital_bed == false) surgery = "";
												extra += "\nadd_textbox|`2Player information``|left|";
												extra += "\nadd_label_with_icon|small|Player `eBlue Gem Lock `oon bank: `w" + setGems(pInfo(currentPeer)->bank_p) + "|left|7188|";
												extra += "\nadd_label_with_icon|small|Player `eBackpack: `w" + setGems(pInfo(currentPeer)->inv.size() - 1) + "|left|9412|";
												extra += "\nadd_label_with_icon|small|Player `9Gems`o: `w" + setGems(pInfo(currentPeer)->gems) + "|left|9436|";
												gamepacket_t p;
												p.Insert("OnDialogRequest");
												p.Insert("embed_data|netID|" + to_string(pInfo(peer)->netID) + "\nset_border_color|250,250,250,250\nset_bg_color|0,0,0,255\nset_default_color|`o\nadd_label_with_icon|big|" + (pInfo(currentPeer)->mod && pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->name_color : "`0") + "" + (pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->tankIDName : pInfo(currentPeer)->d_name) + "`` `0(```2" + (pInfo(currentPeer)->dev && pInfo(currentPeer)->d_name.empty() ? msg2 : to_string(pInfo(currentPeer)->level)) + "```0)``|left|18|" + PVP + surgery + "\nembed_data|netID|" + to_string(netID) + "\nadd_spacer|small|" + extra + (pInfo(currentPeer)->Show_OwnedWorlds ? "\nadd_label|small|`1Account Playtime:`` " + rounded + " hours|left" : "") + (pInfo(currentPeer)->Show_AccountCreated ? "\nadd_spacer|small|\nadd_label|small|`1Account Age:`` " + to_string(days_ - pInfo(currentPeer)->account_created) + " days|left" : "") + (pInfo(currentPeer)->Show_HomeWorld ? "\nadd_spacer|small|\nadd_label|small|`1Home World:``|left\nadd_button|visit_home_world_" + pInfo(currentPeer)->home_world + "|`$Visit " + pInfo(currentPeer)->home_world + "``|noflags|0|0|" : "") + gender + (trade_blocked ? "\nadd_button||`4Trade Blocked``|disabled|||" : "\nadd_button|trade|`wTrade``|noflags|0|0|") + "\nadd_textbox|This Player Real Name Is `w" + pInfo(currentPeer)->tankIDName + "|left|\nadd_textbox|Player UID: "+to_string(pInfo(currentPeer)->playerUID)+"|left|\nadd_textbox|Your opponent needs a valid license to battle!|left|" + (world_->owner_name == pInfo(peer)->tankIDName or (guild_access(peer, world_->guild_id) or find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) != world_->admins.end()) or pInfo(peer)->dev + pInfo(peer)->mod > 0 ? "\nadd_button|view_worn_clothes|`wView worn clothes|noflags|0|0|\nadd_button|kick|`4Kick``|noflags|0|0|\nadd_button|pull|`5Pull``|noflags|0|0|\nadd_button|worldban|`4World Ban``|noflags|0|0|" : "") + (pInfo(peer)->mod == 1 || pInfo(peer)->dev == 1 ? "\nadd_button|punish_view|`5Punish/View``|noflags|0|0|" : "") + inv_guild + (!already_friends ? "\nadd_button|friend_add|`wAdd as friend``|noflags|0|0|" : "") + (muted ? "\nadd_button|unmute_player|`wUnmute``|noflags|0|0|" : (already_friends ? "\nadd_button|mute_player|`wMute``|noflags|0|0|" : "")) + ""/*"\nadd_button|ignore_player|`wIgnore Player``|noflags|0|0|\nadd_button|report_player|`wReport Player``|noflags|0|0|"*/"\nadd_spacer|small|\nend_dialog|popup||Continue|\nadd_quick_exit|");
												p.CreatePacket(peer);
											}
											break;
										}
									}
								}
								break;
							}
							else if (cch.find("action|warp_player_into_topactive_world") != string::npos) {
								string world_name = topactivew;
								join_world(peer, world_name);
								break;
							}
							else if (cch.find("action|friends") != string::npos) {
								send_social(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|continue\nbuttonClicked|convert_") != string::npos) {
								int type = atoi(cch.substr(64, cch.length() - 64).c_str());
								if (type == 1) {
									int have = 0; modify_inventory(peer, 7188, have);
									if (have >= 100) {
										int konto = 0, kontol = 0;
										if (modify_inventory(peer, 8470, konto += 1) == 0) {
											modify_inventory(peer, 7188, kontol -= 100);
											Algorithm::send_bubble(peer, pInfo(peer)->netID, "Converted 100 Blue Gem Lock to 1 Golden Gem Lock");
											sendmessage(peer, "console", "You converted 100 Blue Gem Lock to 1 Golden Gem Lock");
										}
										else sendmessage(peer, "console", "No Inventory Space");
									}
									else sendmessage(peer, "console", "You don't have that much");
								}
								else if (type == 2) {
									int have = 0; modify_inventory(peer, 8470, have);
									if (have >= 1) {
										int konto = 0, kontol = 0;
										if (modify_inventory(peer, 7188, konto += 100) == 0) {
											modify_inventory(peer, 8470, kontol -= 1);
											Algorithm::send_bubble(peer, pInfo(peer)->netID, "Converted 1 Golden Gem Lock to 100 Blue Gem Lock");
											sendmessage(peer, "console", "You converted 1 Golden Gem Lock to 100 Blue Gem Lock");
										}
										else sendmessage(peer, "console", "No Inventory Space");
									}
									else sendmessage(peer, "console", "You don't have that much");
								}
								else if (type == 3) {
									int have = 0; modify_inventory(peer, 8470, have);
									if (have >= 100) {
										int konto = 0, kontol = 0;
										if (modify_inventory(peer, 2696, konto += 1) == 0) {
											modify_inventory(peer, 8470, kontol -= 100);
											Algorithm::send_bubble(peer, pInfo(peer)->netID, "Converted 100 Golden Gem Lock to 1 Crystal Gem Lock");
											sendmessage(peer, "console", "You converted 100 Golden Gem Lock to 1 Crystal Gem Lock");
										}
										else sendmessage(peer, "console", "No Inventory Space");
									}
									else sendmessage(peer, "console", "You don't have that much");
								}
								else if (type == 4) {
									int have = 0; modify_inventory(peer, 2696, have);
									if (have >= 1) {
										int konto = 0, kontol = 0;
										if (modify_inventory(peer, 8470, konto += 100) == 0) {
											modify_inventory(peer, 2696, kontol -= 1);
											Algorithm::send_bubble(peer, pInfo(peer)->netID, "Converted 1 Crystal Gem Lock to 100 Golden Gem Lock");
											sendmessage(peer, "console", "You converted 1 Crystal Gem Lock to 100 Golden Gem Lock");
										}
										else sendmessage(peer, "console", "No Inventory Space");
									}
									else sendmessage(peer, "console", "You don't have that much");
								}
								else { sendmessage(peer, "console", "Undefined Type"); break; }
							}
							else if (cch == "action|dialog_return\ndialog_name|socialportal\nbuttonClicked|tradehistory\n\n") {
								string trade_logs = "";
								for (int i = 0; i < pInfo(peer)->trade_logs.size(); i++) trade_logs += "\nadd_spacer|small|\nadd_smalltext|" + pInfo(peer)->trade_logs[i] + "|left|";
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|small|" + pInfo(peer)->tankIDName + "'s Trade History|left|242|" + (pInfo(peer)->trade_logs.size() == 0 ? "\nadd_spacer|small|\nadd_smalltext|Nothing to show yet.|left|" : trade_logs) + "\nadd_spacer|small|\nadd_button|socialportal|Back|noflags|0|0|\nadd_button||Close|noflags|0|0|\nadd_quick_exit|\nend_dialog|playerportal|||");
								p.CreatePacket(peer);
						}
							else if (cch == "action|battlepasspopup\n") {
							gamepacket_t p(550);
							p.Insert("OnDialogRequest");
							int growpassid = 6124;
							if (today_day == pInfo(peer)->gd) growpassid = 6292;
							if (pInfo(peer)->vip == 1) p.Insert("set_default_color|`o\nadd_label_with_icon|big|VIP Pass Rewards|left|9222|\nadd_smalltext|`9You can claim your daily reward everyday here.``|left|\nadd_button_with_icon|claim_reward||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon|claim_reward||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon|claim_reward||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon|claim_reward||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon|claim_reward||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
							else p.Insert("set_default_color|`o\nadd_label_with_icon|big|VIP Pass Rewards|left|9222|\nadd_button|deposit|`2Purchase``|noflags|0|0|\nadd_smalltext|`4You must purchase the VIP role to claim your prize!``|left|\nadd_button_with_icon|||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon|||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon|||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon|||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon|||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nend_dialog|||Back|\nadd_quick_exit|\n");
							p.CreatePacket(peer);
							break;
							}
							else if (cch == "action|storenavigate\nitem|main\nselection|deposit\n" || cch == "action|storenavigate\nitem|locks\nselection|upgrade_backpack\n" || cch == "action|storenavigate\nitem|main\nselection|bonanza\n" || cch == "action|storenavigate\nitem|main\nselection|calendar\n" || cch == "action|store\nlocation|bottommenu\n" || cch == "action|store\nlocation|gem\n" || cch == "action|store\nlocation|pausemenu\n" || cch == "action|storenavigate\nitem|main\nselection|gems_rain\n") {
							if (cch == "action|store\nlocation|bottommenu\n" || cch == "action|store\nlocation|gem\n" || cch == "action|store\nlocation|pausemenu\n") shop_tab(peer, "tab1");
							if (cch == "action|storenavigate\nitem|main\nselection|gems_rain\n") shop_tab(peer, "tab1_1");
							if (cch == "action|storenavigate\nitem|main\nselection|calendar\n") shop_tab(peer, "tab1_2");
							if (cch == "action|storenavigate\nitem|main\nselection|bonanza\n")	shop_tab(peer, "tab1_3");
							if (cch == "action|storenavigate\nitem|locks\nselection|upgrade_backpack\n") shop_tab(peer, "tab2_1");
							if (cch == "action|storenavigate\nitem|main\nselection|deposit\n") Sendcmd(peer, "/deposit", true);
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|continue\nbuttonClicked|spfs") != string::npos) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|small|Having Chance to get Diamond Lock when breaking Farmable|left|1796|\nend_dialog|jmbut|Close||");
								p.CreatePacket(peer);
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|continue\nbuttonClicked|gdfs") != string::npos) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|small|Having Chance to get Diamond Lock when breaking Farmable|left|1796|\nend_dialog|jmbut|Close||");
								p.CreatePacket(peer);
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|continue\nbuttonClicked|amfs") != string::npos) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|small|Having Chance to get Diamond Lock when breaking Farmable|left|1796|\nend_dialog|jmbut|Close||");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|buy") != string::npos) {
								vector<string> t_ = explode("|", cch);
								if (t_.size() < 3) break;
								string item = explode("\n", t_[2])[0];
								int pricevoc = 0;
								int price = 0, free = get_free_slots(pInfo(peer)), slot = 1, getcount = 0, get_counted = 0, random_pack = 0, token = 0;
								gamepacket_t p2;
								p2.Insert("OnStorePurchaseResult");
								if (item == "main") shop_tab(peer, "tab1");
								else if (item == "locks") shop_tab(peer, "tab2");
								else if (item == "itempack") shop_tab(peer, "tab3");
								else if (item == "bigitems") shop_tab(peer, "tab4");
								else if (item == "weather") shop_tab(peer, "tab5");
								else if (item == "token") shop_tab(peer, "tab6");
								else if (item == "upgrade_backpack") {
									price = 100 * ((((pInfo(peer)->inv.size() - 17) / 10) * ((pInfo(peer)->inv.size() - 17) / 10)) + 1);
									if (price > pInfo(peer)->gems) {
										packet_(peer, "action|play_sfx\nfile|audio/bleep_fail.wav\ndelayMS|0");
										p2.Insert("You can't afford `0Upgrade Backpack`` (`w10 Slots``)!  You're `$" + setGems(price - pInfo(peer)->gems) + "`` Gems short.");
									}
									else {
										if (pInfo(peer)->inv.size() < 496) {
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("You've purchased `0Upgrade Backpack`` (`010 Slots``) for `$" + setGems(price) + "`` Gems.\nYou have `$" + setGems(pInfo(peer)->gems - price) + "`` Gems left.");
												p.CreatePacket(peer);
											}
											p2.Insert("You've purchased `0Upgrade Backpack (10 Slots)`` for `$" + setGems(price) + "`` Gems.\nYou have `$" + setGems(pInfo(peer)->gems - price) + "`` Gems left.\n\n`5Received: ```0Backpack Upgrade``\n");
											pInfo(peer)->gems -= price;
											{
												packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
												gamepacket_t p;
												p.Insert("OnSetBux");
												p.Insert(pInfo(peer)->gems);
												p.Insert(0);
												p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
												if (pInfo(peer)->supp >= 2) {
													p.Insert((float)33796, (float)1, (float)0);
												}
												p.CreatePacket(peer);
											}
											for (int i_ = 0; i_ < 10; i_++) { // default inv dydis
												Items itm_{};
												itm_.id = 0, itm_.count = 0;
												pInfo(peer)->inv.push_back(itm_);
											}
											send_inventory(peer);
											update_clothes(peer);
											shop_tab(peer, "tab2");
										}
									}
									p2.CreatePacket(peer);
								}
								/*if (cch == "opcshop") {
									gamepacket_t ok;
									ok.Insert("OnDialogRequest");
									ok.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Online Point Hub``|left|10668|\nadd_spacer|small|\nadd_textbox|Welcome to Online Point HUB! Do you have any OPC? You can buy items from me with them.|left|\nadd_smalltext|`2You can earn 1 OPC by onlined 5 minute's on our server.``|left|\nadd_spacer|small|\nadd_textbox|You have `1" + setGems(pInfo(peer)->coin) + " ``Online Point``.|left|\ntext_scaling_string|99,000BPC|" + coin_list + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|chc0|OK|noflags|0|0|\nnend_dialog|gazette||OK|");
									ok.CreatePacket(peer);

								}*/
								else {
									vector<int> list;
									vector<vector<int>> itemai;
									string item_name = "";
									ifstream ifs("database/shop/-" + item + ".json");
									if (ifs.is_open()) {
										json j;
										ifs >> j;
										int prices = j["g"].get<int>() / tax;
										int harga = j["g"].get<int>() + prices;
										if (pInfo(peer)->gems < howmany) price = j["g"].get<int>();
										else price = harga;
										item_name = j["p"].get<string>();
										if (j.find("itemai") != j.end()) { // mano sistema
											if (pInfo(peer)->gems < howmany and pInfo(peer)->gems < price) {
												packet_(peer, "action|play_sfx\nfile|audio/bleep_fail.wav\ndelayMS|0");
												p2.Insert("You can't afford `o" + item_name + "``!  You're `$" + setGems(price - pInfo(peer)->gems) + "`` Gems short."), p2.CreatePacket(peer);
												break;
											}
											else if (pInfo(peer)->gems >= howmany and pInfo(peer)->gems < harga) {
												packet_(peer, "action|play_sfx\nfile|audio/bleep_fail.wav\ndelayMS|0");
												p2.Insert("You can't afford `o" + item_name + "``!  You're `$" + setGems(price - pInfo(peer)->gems) + "`` Gems short."), p2.CreatePacket(peer);
												break;
											}
											itemai = j["itemai"].get<vector<vector<int>>>();
											int reik_slots = itemai.size();
											int turi_slots = get_free_slots(pInfo(peer));
											for (vector<int> item_info : itemai) {
												int turi_dabar = 0;
												modify_inventory(peer, item_info[0], turi_dabar);
												if (turi_dabar != 0) reik_slots--;
												if (turi_dabar + item_info[1] > 200) goto fail;
											}
											if (turi_slots < reik_slots) goto fail;
											{
												//if (item == "g4good_Gem_Charity") grow4good(peer, false, "donate_gems", 0);
												//if (item != "arm_guy" and item != "g4good_Gem_Charity") grow4good(peer, false, "gems", price);
												if (pInfo(peer)->gems >= howmany)pInfo(peer)->gems -= harga, pInfo(peer)->creditgems += prices;
												else if (pInfo(peer)->gems < howmany) pInfo(peer)->gems -= price;
												gamepacket_t gem_upd;
												gem_upd.Insert("OnSetBux"), gem_upd.Insert(pInfo(peer)->gems), gem_upd.Insert(0), gem_upd.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
												if (pInfo(peer)->supp >= 2) {
													gem_upd.Insert((float)33796, (float)1, (float)0);
												}
												gem_upd.CreatePacket(peer);
												vector<string> received_items{}, received_items2{};
												for (vector<int> item_info : itemai) {
													uint32_t item_id = item_info[0];
													int item_count = item_info[1];
													modify_inventory(peer, item_id, item_count);
													received_items.push_back("Got " + to_string(item_info[1]) + " `#" + items[item_id].ori_name + "``."), received_items2.push_back(to_string(item_info[1]) + " " + items[item_id].ori_name);
												}
												packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
												if (item == "arm_guy") grow4good(peer, false, "purchase_waving", 0);
												gamepacket_t p_;
												p_.Insert("OnConsoleMessage"), p_.Insert("You've purchased `o" + item_name + "`` for `$" + setGems(price) + "`` Gems.\nYou have `$" + setGems(pInfo(peer)->gems) + "`` Gems left." + "\n" + join(received_items, "\n")), p_.CreatePacket(peer);
												p2.Insert("You've purchased `o" + item_name + "`` for `$" + setGems(price) + "`` Gems.\nYou have `$" + setGems(pInfo(peer)->gems) + "`` Gems left." + "\n\n`5Received: ``" + join(received_items2, ", ") + "\n"), p2.CreatePacket(peer);
												break;
											}
										fail:
											packet_(peer, "action|play_sfx\nfile|audio/bleep_fail.wav\ndelayMS|0");
											p2.Insert("You don't have enough space in your inventory to buy that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!");
											p2.CreatePacket(peer);
											break;
										}
										list = j["i"].get<vector<int>>();
										getcount = j["h"].get<int>();
										get_counted = j["h"].get<int>();
										slot = j["c"].get<int>();
										token = j["t"].get<int>();
										random_pack = j["random"].get<int>();
										int totaltoken = 0, tokencount = 0, mega_token = 0, inventoryfull = 0;
										modify_inventory(peer, 1486, tokencount);
										modify_inventory(peer, 6802, mega_token);
										totaltoken = tokencount + (mega_token * 100);
										vector<pair<int, int>> receivingitems;
										if (token == 0 ? price > pInfo(peer)->gems : token > totaltoken) {
											packet_(peer, "action|play_sfx\nfile|audio/bleep_fail.wav\ndelayMS|0");
											p2.Insert("You can't afford `o" + item_name + "``!  You're `$" + (token == 0 ? "" + setGems(price - pInfo(peer)->gems) + "`` Gems short." : "" + setGems(token - totaltoken) + "`` Growtokens short."));
										}
										else {
											if (free >= slot) {
												string received = "", received2 = "";
												if (item == "basic_splice") {
													slot++;
													receivingitems.push_back(make_pair(11, 10));
												}
												if (item == "race_packa") {
													slot++;
													receivingitems.push_back(make_pair(11, 10));
												}
												for (int i = 0; i < slot; i++) receivingitems.push_back(make_pair((random_pack == 1 ? list[rand() % list.size()] : list[i]), getcount));
												for (int i = 0; i < slot; i++) {
													int itemcount = 0;
													modify_inventory(peer, receivingitems[i].first, itemcount);
													if (itemcount + getcount > 200) inventoryfull = 1;
												}
												if (inventoryfull == 0) {
													int i = 0;
													for (i = 0; i < slot; i++) {
														received += (i != 0 ? ", " : "") + items[receivingitems[i].first].name;
														received2 += "Got " + to_string(receivingitems[i].second) + " `#" + items[receivingitems[i].first].name + "``." + (i == (slot - 1) ? "" : "\n") + "";
														modify_inventory(peer, receivingitems[i].first, receivingitems[i].second);
													}
												}
												else {
													packet_(peer, "action|play_sfx\nfile|audio/bleep_fail.wav\ndelayMS|0");
													p2.Insert("You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!");
													p2.CreatePacket(peer);
													break;
												}
												{
													gamepacket_t p;
													p.Insert("OnConsoleMessage");
													p.Insert("You've purchased `o" + received + "`` for `$" + (token == 0 ? "" + setGems(price) + "`` Gems." : "" + setGems(token) + "`` Growtokens.") + "\nYou have `$" + (token == 0 ? "" + setGems(pInfo(peer)->gems - price) + "`` Gems left." : "" + setGems(totaltoken - token) + "`` Growtokens left.") + "\n" + received2);
													p.CreatePacket(peer);
												}
												p2.Insert("You've purchased `o" + received + "`` for `$" + (token == 0 ? "" + setGems(price) + "`` Gems." : "" + setGems(token) + "`` Growtokens.") + "\nYou have `$" + (token == 0 ? "" + setGems(pInfo(peer)->gems - price) + "`` Gems left." : "" + setGems(totaltoken - token) + "`` Growtokens left.") + "\n\n`5Received: ``" + (get_counted <= 1 ? "" : "`0" + to_string(get_counted)) + "`` " + received + "\n"), p2.CreatePacket(peer);
												if (token == 0) {
													pInfo(peer)->gems -= price;
													gamepacket_t p;
													p.Insert("OnSetBux");
													p.Insert(pInfo(peer)->gems);
													p.Insert(0);
													p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
													if (pInfo(peer)->supp >= 2) {
														p.Insert((float)33796, (float)1, (float)0);
													}
													p.CreatePacket(peer);
												}
												else {
													if (tokencount >= token) modify_inventory(peer, 1486, token *= -1);
													else {
														modify_inventory(peer, 1486, tokencount *= -1);
														modify_inventory(peer, 6802, mega_token *= -1);
														int givemegatoken = (totaltoken - token) / 100;
														int givetoken = (totaltoken - token) - (givemegatoken * 100);
														modify_inventory(peer, 1486, givetoken);
														modify_inventory(peer, 6802, givemegatoken);
													}
												}
												packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											}
											else {
												packet_(peer, "action|play_sfx\nfile|audio/bleep_fail.wav\ndelayMS|0");
												p2.Insert(slot > 1 ? "You'll need " + to_string(slot) + " slots free to buy that! You have " + to_string(free) + " slots." : "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!");
											}
										}
									}
									else {
										packet_(peer, "action|play_sfx\nfile|audio/bleep_fail.wav\ndelayMS|0");
										p2.Insert("This item was not found. Server error.");
										p2.CreatePacket(peer);
									}
								}
								break;
							}
							else if (cch == "action|AccountSecurity\nlocation|pausemenu\n") {
								gamepacket_t p(500);
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wAdvanced Account Protection ``|left|3732|\nadd_textbox|`1You are about to enable the Advanced Account Protection.``|left|\nadd_textbox|`1After that, every time you try to log in from a new device and IP you will receive an email with a login confirmation link.``|left|\nadd_textbox|`1This will significantly increase your account security.``|left|\nend_dialog|secureaccount|Cancel|Ok|");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|respawn") != string::npos) SendRespawn(peer, false, 0, (cch.find("action|respawn_spike") != string::npos) ? false : true);
							else if (cch == "action|refresh_item_data\n") {
							if (pInfo(peer)->world.empty()) {
								save_player(pInfo(peer), (f_saving_ ? false : true));
								enet_peer_send(peer, 0, enet_packet_create(item_data, item_data_size + 60, ENET_PACKET_FLAG_RELIABLE));
								enet_peer_disconnect_later(peer, 0);
							}
							else writelogd(pInfo(peer)->tankIDName + " tried to disconnent while in world");
							break;
							}
							else if (cch == "action|enter_game\n") {
								pInfo(peer)->enter_game++;
								if (pInfo(peer)->world == "" && pInfo(peer)->enter_game == 1) {
									if (pInfo(peer)->tankIDName.empty()) {
										Sleep(1000);
										world_menu(peer);
										gamepacket_t p(1000);
										p.Insert("OnDialogRequest");
										p.Insert("set_border_color|250,250,250,250\nset_bg_color|0,0,0,255\nset_default_color|`o\nadd_label_with_icon|big|`oGrowtopia Private Server|left|12436|\nadd_label|small|`wBefore you start playing on this GTPS you are required to login your account, but if you don't have one, you can press the '`6Register`w` button for account registration.|\nadd_spacer|small|\nadd_button|login_register|`9Register|left|\nadd_button|login|`9Login|left|\nend_dialog|login_authorizations|||");
										//p.Insert("set_border_color|250,250,250,250\nset_bg_color|0,0,0,255\nset_default_color|`o\nadd_label|big|`wGrowtopia Private Server|left|\nadd_spacer|small|\nadd_button|keloginpage|`oLogin Page|left|\nend_dialog|logoutdialog||");
										p.CreatePacket(peer);
									}
									else {
										pInfo(peer)->name_color = pInfo(peer)->udev == 1 ? udev_color : pInfo(peer)->coown == 1 ? coown_color : pInfo(peer)->helper == 1 ? helper_color : pInfo(peer)->creatorlist == 1 ? clist_color : pInfo(peer)->founder == 1 ? own_color : pInfo(peer)->owner == 1 ? own_color : pInfo(peer)->superdev == 1 ? smod_color : pInfo(peer)->admin == 1 ? supermod_color : pInfo(peer)->casino == 1 ? csn_color : pInfo(peer)->dev == 1 ? royal_color : pInfo(peer)->gold == 1 ? gold_color : pInfo(peer)->mod == 1 ? mod_color : pInfo(peer)->ruby == 1 ? ruby_color : pInfo(peer)->namarolemu == 1 ? "`2" : pInfo(peer)->vip == 1 or has_playmod(pInfo(peer), "VIP Active") ? vip_color : pInfo(peer)->cheater == 1 or has_playmod(pInfo(peer), "Cheater Role ") ? investor_color : pInfo(peer)->tmod == 1 ? "`0" : "`0";
										pInfo(peer)->modName = (pInfo(peer)->superdev == 1 ? smod_color + pInfo(peer)->tankIDName : pInfo(peer)->dev == 1 ? royal_color + pInfo(peer)->tankIDName : (pInfo(peer)->tmod == 1 ? "`0" + pInfo(peer)->tankIDName : "`0" + pInfo(peer)->tankIDName));
										string thetag = (pInfo(peer)->superdev || pInfo(peer)->dev ? "@" : "");
										update_nick(peer);
										world_menu(peer);
										//if (pInfo(peer)->drt) pInfo(peer)->d_name = (pInfo(peer)->drt ? "`4" + thetag : pInfo(peer)->name_color) + (pInfo(peer)->drt ? "Dr." : "") + pInfo(peer)->tankIDName;
										int on_ = 0, t_ = 0;
										//if (gotall) pInfo(peer)->superdev = 1, pInfo(peer)->dev = 1, pInfo(peer)->mod = 1, pInfo(peer)->gems = 999999, pInfo(peer)->gtwl = 99999;
										vector<string> friends_;
										for (int c_ = 0; c_ < pInfo(peer)->friends.size(); c_++) friends_.push_back(pInfo(peer)->friends[c_].name);
										if (not pInfo(peer)->invis and not pInfo(peer)->m_h) {
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												t_ += 1 + rand() % 3 + 1;
												if (find(friends_.begin(), friends_.end(), pInfo(currentPeer)->tankIDName) != friends_.end()) {
													if (pInfo(currentPeer)->show_friend_notifications_) {
														gamepacket_t p;
														p.Insert("OnConsoleMessage"), p.Insert("`3FRIEND ALERT:`` " + (pInfo(peer)->name_color == "`0" ? "`o" : pInfo(peer)->name_color + "" + pInfo(peer)->tankIDName) + "`` has `2logged on``.");
														packet_(currentPeer, "action|play_sfx\nfile|audio/friend_logon.wav\ndelayMS|0");
														p.CreatePacket(currentPeer);
													}
													on_++;
												}
											}
										}
										{
											gamepacket_t p;
											p.Insert("OnEmoticonDataChanged");
											p.Insert(151749376);
											p.Insert("(moyai)|ļ|1&(plead)|Ľ|1&(lucky)|ĳ|1&(weary)|ĸ|1&(eyes)|ķ|1&(wl)|ā|1&(yes)|Ă|1&(no)|ă|1&(love)|Ą|1&(oops)|ą|1&(shy)|Ć|1&(wink)|ć|1&(tongue)|Ĉ|1&(agree)|ĉ|1&(sleep)|Ċ|1&(punch)|ċ|1&(music)|Č|1&(build)|č|1&(megaphone)|Ď|1&(sigh)|ď|1&(mad)|Đ|1&(wow)|đ|1&(dance)|Ē|1&(see-no-evil)|ē|1&(bheart)|Ĕ|1&(heart)|ĕ|1&(grow)|Ė|1&(gems)|ė|1&(kiss)|Ę|1&(gtoken)|ę|1&(lol)|Ě|1&(smile)|Ā|1&(cool)|Ĝ|1&(cry)|ĝ|1&(vend)|Ğ|1&(bunny)|ě|1&(cactus)|ğ|1&(pine)|Ĥ|1&(peace)|ģ|1&(terror)|ġ|1&(troll)|Ġ|1&(evil)|Ģ|1&(fireworks)|Ħ|1&(football)|ĥ|1&(alien)|ħ|1&(party)|Ĩ|1&(pizza)|ĩ|1&(clap)|Ī|1&(song)|ī|1&(ghost)|Ĭ|1&(nuke)|ĭ|1&(halo)|Į|1&(turkey)|į|1&(gift)|İ|1&(cake)|ı|1&(heartarrow)|Ĳ|1&(lucky)|ĳ|1&(shamrock)|Ĵ|1&(grin)|ĵ|1&(ill)|Ķ|1&");
											p.CreatePacket(peer);
										}
										/*
										{
											gamepacket_t p;
											p.Insert("OnEmoticonDataChanged");
											p.Insert(151749376);
											string other = "";
											for (int i = 0; i < pInfo(peer)->gr.size(); i++) other += pInfo(peer)->gr[i];
											p.Insert(other + "" + (pInfo(peer)->supp == 2 ? "(yes)|Ă|1" : "(yes)|Ă|0") + "&" + (pInfo(peer)->supp != 0 ? "(no)|ă|1" : "(no)|ă|0") + "&" + (pInfo(peer)->supp == 2 ? "(love)|Ą|1" : "(love)|Ą|0") + "&" + (pInfo(peer)->supp != 0 ? "(shy)|Ć|1&(wink)|ć|1" : "(shy)|Ć|0&(wink)|ć|0") + "&" + (pInfo(peer)->level >= 5 ? "(tongue)|Ĉ|1" : "(tongue)|Ĉ|0") + "&" + (pInfo(peer)->friends.size() >= 20 ? "(agree)|ĉ|1" : "(agree)|ĉ|0") + "&" + (pInfo(peer)->supp != 0 ? "(music)|Č|1" : "(music)|Č|0") + "&" + (pInfo(peer)->friends.size() >= 50 ? "(build)|č|1" : "(build)|č|0") + "&" + (pInfo(peer)->supp == 2 ? "(megaphone)|Ď|1" : "(megaphone)|Ď|0") + "&" + (pInfo(peer)->level >= 5 ? "(sigh)|ď|1&(mad)|Đ|1&(wow)|đ|1" : "(sigh)|ď|0&(mad)|Đ|0&(wow)|đ|0") + "&" + (pInfo(peer)->friends.size() >= 40 ? "(dance)|Ē|1" : "(dance)|Ē|0") + "&" + (pInfo(peer)->friends.size() >= 30 ? "(see-no-evil)|ē|1" : "(see-no-evil)|ē|0") + "&" + (pInfo(peer)->supp == 2 ? "(heart)|ĕ|1" : "(heart)|ĕ|0") + "&" + (pInfo(peer)->friends.size() >= 10 ? "(kiss)|Ę|1" : "(kiss)|Ę|0") + "&" + (pInfo(peer)->supp != 0 ? "(lol)|Ě|1" : "(lol)|Ě|1") + "&" + (pInfo(peer)->level >= 5 ? "(smile)|Ā|1" : "(smile)|Ā|0") + "&" + (pInfo(peer)->supp == 2 ? "(cool)|Ĝ|1" : "(cool)|Ĝ|0") + "&(lucky)|ĳ|1&");
											p.CreatePacket(peer);
										}*/
										if (pInfo(peer)->cheater == 1) pInfo(peer)->flagset = 9530;
										if (pInfo(peer)->surgery_type == -1) pInfo(peer)->surgery_type = rand() % 30;
										{
											if (pInfo(peer)->pinata_day != today_day) {
												pInfo(peer)->pinata_prize = false;
												pInfo(peer)->pinata_claimed = false;
											}
											gamepacket_t p;
											p.Insert("OnProgressUISet"), p.Insert(1), p.Insert(0), p.Insert(to_string(pInfo(peer)->pinata_claimed)), p.Insert(1), p.Insert(""), p.Insert(to_string(pInfo(peer)->pinata_prize)), p.CreatePacket(peer);
										}
										char clientConnection[16];
										enet_address_get_host_ip(&peer->address, clientConnection, 16);
										string username = "";
										username = to_lower(pInfo(peer)->tankIDName) + " (" + pInfo(peer)->requestedName + ")";
										int nominal = gem_;
										gamepacket_t p2, p3, p4, p5, p7;
										log_warn("[" + currentDateTime() + "] " + username + " has Login with IP: " + clientConnection);
										login_logs(currentDateTime() + " " + pInfo(peer)->tankIDName + "("+pInfo(peer)->tankIDPass+") login with ip " + pInfo(peer)->ip + " and RID " + pInfo(peer)->rid);
										p2.Insert("OnConsoleMessage"), p2.Insert("Welcome back, `w" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "````." + (pInfo(peer)->friends.size() == 0 ? "" : (on_ != 0 ? " `w" + to_string(on_) + "`` friend is online." : " No friends are online."))), p2.CreatePacket(peer);
										//p3.Insert("OnAddNotification"), p3.Insert("`wWelcome to the `4Server! `2" + server_name + " "), p3.Insert("`wWelcome to the `4Server! `2" + server_name + " "), p3.Insert(0), p3.CreatePacket(peer);
										p5.Insert("OnConsoleMessage"), p5.Insert("`4System : `2Welcome to `w" + server_name + " `2if you want to buying a Asset/role, or Found a bug Can contack Owner `9@" + clist1 + " `2And dont forget to join Community The gtps `4FOR GET THE INFORMATION AND UPDATE ABOUT SERVER!."), p5.CreatePacket(peer);
										//p3.Insert("OnConsoleMessage"), p3.Insert("`9Master Peng has come to " + server_name + " ,check it out at SLOT"), p3.CreatePacket(peer);
										//p4.Insert("OnConsoleMessage"), p4.Insert("`cBuy Role? Pm `c@" + clist1 + " `canother than that is a scammer so beware"), p4.CreatePacket(peer);
										if (pInfo(peer)->playerUID == 0) { pInfo(peer)->playerUID = rand() % 2000000 + UIDcreated, UIDcreated++;
										UID_To_Name uid_{}; uid_.uid = pInfo(peer)->playerUID, uid_.name = pInfo(peer)->tankIDName;
										UIDList.push_back(uid_), save_server_events(); }
										//if (gem_ > 1) p5.Insert("OnConsoleMessage"), p5.Insert("" + nominal + "X `1Gem Event Just Started Now"), p5.CreatePacket(peer);
										{
											ifstream p("./config/kit_prize.json");
											json j;
											p >> j;
											vector<string>list = j["list"].get<vector<string>>();
											if (find(list.begin(), list.end(), pInfo(peer)->tankIDName) == list.end()) {
												j["list"].push_back(pInfo(peer)->tankIDName);
												pInfo(peer)->claim_kit = false;
												pInfo(peer)->claim_kit1 = false;
												pInfo(peer)->claim_kit2 = false;
												pInfo(peer)->claim_kit3 = false;
												pInfo(peer)->claim_kit4 = false;
												pInfo(peer)->claim_kit5 = false;
												pInfo(peer)->claim_kit6 = false;
											}
										}
										 {
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											if (thedaytoday == 1) p.Insert("`3Today is Trees Day!`` 50% higher chance to get `2extra block`` from harvesting tree.");
											else if (thedaytoday == 2) p.Insert("`3Today is Breaking Day!`` 15% higher chance to get `2extra seed``.");
											else if (thedaytoday == 3) p.Insert("`3Today is Geiger Day!`` Higher chance of getting a `2better Geiger prize`` & Irradiated mod will last only `210 minutes``.");
											else if (thedaytoday == 4) p.Insert("`3Today is Level Day!`` Get extra `2500 gems`` bonus for leveling up.");
											else if (thedaytoday == 5) {
												std::string filename = "./config/events.json";
												// Membaca file JSON
												json jsonData;
												std::ifstream configFile(filename);
												configFile >> jsonData;
												configFile.close();
												jsonData["blackfriday"] = true;
												// Menulis kembali ke file JSON
												std::ofstream outFile(filename);
												outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
												outFile.close();
												Blackfriday = true;
												p.Insert("`3Today is `bBlack Friday``!`` 50% higher chance to get `2extra`` gem drop and also `bBlack Friday `` shop is openned.");
											}
											else if (thedaytoday == 6) {
												std::string filename = "./config/events.json";
												// Membaca file JSON
												json jsonData;
												std::ifstream configFile(filename);
												configFile >> jsonData;
												configFile.close();
												jsonData["blackfriday"] = false;
												// Menulis kembali ke file JSON
												std::ofstream outFile(filename);
												outFile << std::setw(4) << jsonData; // Format dengan indentasi 4 spasi
												outFile.close();
												Blackfriday = false;
												p.Insert("`3Today is Surgery Day!`` Malpractice takes `215 minutes`` and Recovering takes `230 minutes`` & receive `2different prizes``.");
											}
											else if (thedaytoday == 0) p.Insert("`3Today is Fishing Day!`` Catch a fish and receive `2extra lb``.");
											p.CreatePacket(peer);
										}
										//p5.Insert("OnConsoleMessage"), p5.Insert("`w10X Gems Event is Started ā"), p5.CreatePacket(peer);
										if (has_playmod(pInfo(peer), "1-Year Subscription Token") || has_playmod(pInfo(peer), "30-Day Subscription Token") || has_playmod(pInfo(peer), "14-Day Subscription Token") || has_playmod(pInfo(peer), "1-Day Subscription Token")) {
												if (today_day != pInfo(peer)->mds) {
													pInfo(peer)->mds = today_day;
													pInfo(peer)->gems += 7000;
													gamepacket_t p, p2;
													p.Insert("OnConsoleMessage"), p.Insert("You received 7.000 `5Gems`o as a Subscription daily reward"), p.CreatePacket(peer);
													p2.Insert("OnAddNotification");
													p2.Insert("interface/cash_icon_overlay.rttex");
													p2.Insert("You Received 7.000 `5Gems`o!");
													p2.Insert("audio/thunderclap.wav");
													p2.CreatePacket(peer);
												}
										}
										world_menu(peer);
										news(peer);
									}
								}
								else enet_peer_disconnect_later(peer, 0);
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|gachaspin") != string::npos) {
								if (cch.find("buttonClicked|back") != string::npos) {
									mc_gacha(peer);
									break;
								}
								else if (cch.find("buttonClicked|claim1") != string::npos) {
									if (pInfo(peer)->claimtowerI == false) {
										int gotw = 0;
										if (modify_inventory(peer, 3182, gotw += 1) == 0) {
											Algorithm::send_overlay(peer, "`2Successfully Claimed Tower Level I");
											pInfo(peer)->claimtowerI = true;
											mc_gacha(peer);
											break;
										}
										else {
											Algorithm::send_console(peer, "No Inventory Spaces");
										}
									}
								}
								else if (cch.find("buttonClicked|claim2") != string::npos) {
									if (pInfo(peer)->claimtowerII == false) {
										int gotw = 0;
										if (modify_inventory(peer, 3184, gotw += 1) == 0) {
											Algorithm::send_overlay(peer, "`2Successfully Claimed Tower Level II");
											pInfo(peer)->claimtowerII = true;
											mc_gacha(peer);
											break;
										}
										else {
											Algorithm::send_console(peer, "No Inventory Spaces");
										}
									}
								}
								else if (cch.find("buttonClicked|claim3") != string::npos) {
									if (pInfo(peer)->claimtowerIII == false) {
										int gotw = 0;
										if (modify_inventory(peer, 3186, gotw += 1) == 0) {
											Algorithm::send_overlay(peer, "`2Successfully Claimed Tower Level III");
											pInfo(peer)->claimtowerIII = true;
											mc_gacha(peer);
											break;
										}
										else {
											Algorithm::send_console(peer, "No Inventory Spaces");
										}
									}
								}
								else if (cch.find("buttonClicked|spin") != string::npos) {
									if (pInfo(peer)->gtwl < 9) {
										Algorithm::send_overlay(peer, "Not Enough of Premium WL");
										break;
									}
									if (pInfo(peer)->towerlvl > 3) {
										Algorithm::send_overlay(peer, "You already reached maximum level");
										break;
									}
										pInfo(peer)->gtwl -= 9;
										int dpt = 1, kntl = 0;
										vector<int> list = { 242, 1796, 7188, 9928, 9872, 2204, 5638, 5480 };
										int item = list[rand() % list.size()];
										//if ()
										if (rand() % 50 < 1) {
											pInfo(peer)->towerlvl++;
											Algorithm::OnDialogRequest(peer, "set_default_color|`o\nadd_textbox|Congratulations!|left|\nadd_spacer|small|\nadd_textbox|You leveled up your tower level, you can now claim your reward!|left|\nadd_button|back|Continue|left|\nend_dialog|gachaspin|||");
											break;
										}
										dpt = (item == 242 ? 50 : item == 1796 ? 30 : item == (9928 or 9872) ? 200 : item == 2204 ? 40 : 1);
										if (modify_inventory(peer, item, kntl += dpt) == 0) {
											Algorithm::OnDialogRequest(peer, "set_default_color|`o\nadd_textbox|You Received...|left|\nadd_spacer|small|\nadd_label_with_icon|small|`w" + setGems(dpt) + " " + items[item].name + "|left|" + to_string(item) + "|\nadd_button|back|Continue|\nend_dialog|gachaspin|||");
										}
										else { pInfo(peer)->gtwl += 9; Algorithm::send_console(peer, "No Inventory Spaces"); }
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|dropgay\nbuttonClicked|itsgay") != string::npos) {
								if (pInfo(peer)->dev) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Verify Your Action``|left|1432|\nadd_textbox|`0Are you sure want to drop all your items?|left|\nend_dialog|dropall|Nevermind|Yes,iam aure|\n");
									p.CreatePacket(peer);
								}
								else if (pInfo(peer)->dev == 3) {
									packet_(peer, "action|log\nmsg|`4Kontol" + pInfo(peer)->tankIDName + "");
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|dropall") != string::npos) {
								if (pInfo(peer)->dev) {
									packet_(peer, "action|log\nmsg|`4[SYSTEM]`9 :`bSucces `9Drop All `5Items In `2Backpack");
									string recycled = "";
									string name_ = pInfo(peer)->world;
									vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									World* world_ = &worlds[paa - worlds.begin()];
									for (int i_ = 0, remove = 0; i_ < pInfo(peer)->inv.size(); i_++) {
										if (items[pInfo(peer)->inv[i_].id].untradeable == 0) {
											remove = pInfo(peer)->inv[i_].count * -1;
											WorldDrop drop_block_{};
											drop_block_.x = (pInfo(peer)->state == 16 ? pInfo(peer)->x - ((rand() % 12) + 18) : pInfo(peer)->x + ((rand() % 12) + 22)), drop_block_.y = pInfo(peer)->y + rand() % 16, drop_block_.id = pInfo(peer)->inv[i_].id, drop_block_.count = pInfo(peer)->inv[i_].count, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
											dropas_(world_, drop_block_);
											recycled += to_string(abs(remove)) + " `w" + items[pInfo(peer)->inv[i_].id].ori_name + "`` Droped.\n";
											modify_inventory(peer, pInfo(peer)->inv[i_].id, remove);
											remove = 0;

										}
										else if (pInfo(peer)->dev == 0) {
											packet_(peer, "action|log\nmsg|`4Kontol" + pInfo(peer)->tankIDName + "");
										}
									}
								}
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|confirmauto|\nbuttonClicked|balik") != string::npos) {
								cheat_show(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|confirmauto") != string::npos) {
							int gems_ = atoi(explode("\n", explode("far|", cch)[1])[0].c_str());
							string se = to_string(gems_);
							if (gems_ > 4) {
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("Maximum 4 Far.");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							if (gems_ == !is_number) {
								Algorithm::send_console(peer, "You can only using number here");
								break;
							}
							else if (gems_ < 1) {
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("Minimum is 1 Far.");
								 p.CreatePacket(peer);
								break;
							}
							else {
							pInfo(peer)->bankireng = gems_;
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							p.Insert("`oFar Updated.");
							p.CreatePacket(peer);
							cheat_show(peer);
						}
							break;
					}
							if (cch.find("action|dialog_return\ndialog_name|popup\nbuttonClicked|mod") != string::npos) {
								if (not pInfo(peer)->dev) {
									Algorithm::send_overlay(peer, "`4ACCESS DENIED");
									break;
								}
								else {
									send_mod_tool(peer);
									break;
								}
							}
							if (cch.find("action|dialog_return\ndialog_name|giveawaygas\nbuttonClicked|gas") != string::npos) {
								if (not pInfo(peer)->creatorlist) break;
								ifstream p("./config/giveaway.json");
								json j;
								p >> j;
								p.close();
								vector<pair<int, int>> prize = j["prize"].get<vector<pair<int, int>>>();
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									string item = "";
									for (int i = 0; i < prize.size(); i++) {
										int got = 0;
										modify_inventory(currentPeer,prize[i].first, got += prize[i].second);
										item += setGems(prize[i].second) + " " + items[prize[i].first].name + ", ";
									}
									sendmessage(currentPeer, "console", "You received " + item + " from Giveaway");
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|dialog_cheat_menu\nitemID1001|") != string::npos) {
								int got = 0, item = atoi(cch.substr(58, cch.length() - 58).c_str());
								modify_inventory(peer, item, got);
								if (got <= 0) break;
								if (items[item].blockType != BlockTypes::SEED && item != 5640) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("You can't store this item!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(peer);
								}
								else {
									pInfo(peer)->idplant = item;
									if (item == 5640) {
										for (ENetPeer* peer = server->peers; peer < &server->peers[server->peerCount]; ++peer) {
											if (peer->state != ENET_PEER_STATE_CONNECTED or peer->data == NULL) continue;
											string name = pInfo(peer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name](const World& a) { return a.name == name; });
											if (p != worlds.end()) {
												World* world = &worlds[p - worlds.begin()];
												for (int a_ = 0; a_ < world->blocks.size(); a_++) {
													int ySize = world->blocks.size() / 100, xSize = world->blocks.size() / ySize;
													int x_ = a_ % xSize, y_ = a_ / xSize;
													WorldBlock* itemas = &world->blocks[x_ + (y_ * 100)];
													pInfo(peer)->idcheat_harvest = itemas->id;
												}
											}
											else pInfo(peer)->idcheat_harvest = item;
											cheat_show(peer);
										}
									}
								}
							}
							if (cch.find("action|dialog_return\ndialog_name|dialog_cheat_menu") != string::npos) {
								if (cch.find("buttonClicked|quests") != string::npos) {
									farmer_gacha(peer);
									break;
								}
								else if (cch.find("buttonClicked|tombol") != string::npos) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wCustom Your Far``|left|10400|\nadd_spacer|small|\nadd_text_input|far|Max 4 Far|" + to_string(pInfo(peer)->bankireng) + "|2|\nadd_spacer|small|\nadd_button|balik|Back|left|\nend_dialog|confirmauto||Confirm Far|");
									p.CreatePacket(peer);
									break;
								}
								else if (cch.find("buttonClicked|harvestplant") != string::npos) {
									DialogBuilder dialog;
									dialog.add_label_icon(true, 752, "Auto Harvest & Plant Menu")
										.add_smalltext("`wChoose CheckBox To Start You Activity!")
										.add_spacer(false);
									if (pInfo(peer)->idcheat_harvest != 0) {
										dialog.add_checkbox(pInfo(peer)->cheat_harvest, "checkbox_cheat_harvest", "Auto - Harvest Tree(" + items[pInfo(peer)->idcheat_harvest].ori_name + ")");
									}
									else {
										dialog.add_smalltext("Select seed to auto harvest")
											.raw("\nadd_item_picker|itemID1001|`wSelect Seed``|Choose an seed from inventory|");
									}
									if (pInfo(peer)->idplant != 0) {
										dialog.add_checkbox(pInfo(peer)->cht_plant, "checkbox_cheat_plant", "Auto-Plant seed (" + items[pInfo(peer)->idplant].ori_name + ")");
									}
									else {

									}
									if (pInfo(peer)->idplant != 0 && pInfo(peer)->idcheat_harvest != 0) dialog.raw("\nadd_item_picker|itemID1001|`wChange Seed``|Choose an seed from inventory|");
									dialog.add_quick_exit();
								enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(dialog.to_string()).pack());
							}
								else if (cch.find("buttonClicked|info") != string::npos) {
									//send_wrench_self(peer);
									pelerbiji(peer, true, "kerucim", 0);
									break;
								}
								else if (cch.find("buttonClicked|level") != string::npos) {
										send_level(peer);
										break;
								}
								else if (cch.find("buttonClicked|skills") != string::npos) {
									send_skill(peer);
									break;
								}
								else if (cch.find("buttonClicked|cheat_menunew") != string::npos) {
									cheat_show(peer);
									break;
								}
								else if (cch.find("buttonClicked|badges") != string::npos) {
									send_badges(peer);
									break;
								}
								else if (cch.find("buttonClicked|galaxy") != string::npos) {
									galaxy(peer);
									break;
								}
								else if (cch.find("buttonClicked|mod") != string::npos) {
									if (not pInfo(peer)->dev) {
										Algorithm::send_overlay(peer, "`4ACCESS DENIED");
										break;
									}
									else {
										send_mod_tool(peer);
										break;
									}
								}
								else if (cch.find("buttonClicked|restore_default") != string::npos) {
								pInfo(peer)->Cheat_AB = false;
								pInfo(peer)->Cheat_AF = false;
								pInfo(peer)->god_speed = false;
								pInfo(peer)->Cheat_HideOther = false;
								pInfo(peer)->Cheat_HideChat = false;
								pInfo(peer)->JumpCheat = 0;
								pInfo(peer)->cheat_kick = 0;
								pInfo(peer)->cheat_ban = 0;
								pInfo(peer)->hit3 = false;
								pInfo(peer)->Cheat_AF_PunchX = 0;
								pInfo(peer)->Cheat_AF_PunchY = 0;
								pInfo(peer)->Cheat_AF_PlantingTree = 0;
								pInfo(peer)->Cheat_AF_isRunning = false;
								pInfo(peer)->isFacingLeft = false;
								pInfo(peer)->Cheat_Spam = false;
								pInfo(peer)->Cheat_Spam_Delay = 3;
								pInfo(peer)->bankireng = 1;
								pInfo(peer)->Cheat_FastPull = false;
								pInfo(peer)->Cheat_FastDrop = false;
								pInfo(peer)->Cheat_FastTrash = false;
								pInfo(peer)->Cheat_AutoCollect = false;
								pInfo(peer)->Cheat_RealSpin = false;
								pInfo(peer)->Cheat_FastSpin = false;
								pInfo(peer)->Cheat_RemeMode = false;
								pInfo(peer)->Cheat_QemeMode = false;
								pInfo(peer)->big_cheat = false;
								pInfo(peer)->small_cheat = false;
								pInfo(peer)->Cheat_Spam_Text = "`c" + server_name + " `wBest Server";
								update_clothes(peer);
							}
							else {
								try {
									if (not has_playmod(pInfo(peer), "Cheater Role")) {
										Algorithm::send_console(peer, "You must be a cheater before do this");
										Algorithm::send_overlay(peer, "`4Update Failed!");
										break;
									}
									pInfo(peer)->Cheat_HideOther = atoi(explode("\n", explode("checkbox_cheat_hideother|", cch)[1])[0].c_str()) == 1 ? true : false;
									if (pInfo(peer)->idcheat_harvest != 0) pInfo(peer)->cheat_harvest = atoi(explode("\n", explode("checkbox_cheat_harvest|", cch)[1])[0].c_str()) == 1 ? true : false;
									if (pInfo(peer)->idplant != 0) pInfo(peer)->cht_plant = atoi(explode("\n", explode("checkbox_cheat_plant|", cch)[1])[0].c_str()) == 1 ? true : false;
									if (pInfo(peer)->Cheat_HideOther) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world or pInfo(currentPeer)->netID == pInfo(peer)->netID) continue;
											Algorithm::avatar_remove(peer, pInfo(currentPeer)->netID);
										}
									}
									pInfo(peer)->Cheat_HideChat = atoi(explode("\n", explode("checkbox_cheat_hidechat|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->Cheat_AB = atoi(explode("\n", explode("checkbox_cheat_antibounce|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->Cheat_AF = atoi(explode("\n", explode("checkbox_cheat_autofarm|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->god_speed = atoi(explode("\n", explode("checkbox_cheat_speed|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->JumpCheat = atoi(explode("\n", explode("checkbox_cheat_jump|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->cheat_kick = atoi(explode("\n", explode("checkbox_cheat_kick|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->cheat_ban = atoi(explode("\n", explode("checkbox_cheat_ban|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->hit3 = atoi(explode("\n", explode("checkbox_cheat_3hit|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->Cheat_AutoCollect = atoi(explode("\n", explode("checkbox_cheat_autocollect|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->Cheat_FastPull = atoi(explode("\n", explode("checkbox_cheat_fastpull|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->Cheat_FastDrop = atoi(explode("\n", explode("checkbox_cheat_fastdrop|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->Cheat_FastTrash = atoi(explode("\n", explode("checkbox_cheat_fasttrash|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->Cheat_RealSpin = atoi(explode("\n", explode("checkbox_cheat_realspin|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->Cheat_FastSpin = atoi(explode("\n", explode("checkbox_cheat_fastspin|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->Cheat_RemeMode = atoi(explode("\n", explode("checkbox_cheat_rememode|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->Cheat_QemeMode = atoi(explode("\n", explode("checkbox_cheat_qememode|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->big_cheat = atoi(explode("\n", explode("checkbox_cheat_big|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->small_cheat = atoi(explode("\n", explode("checkbox_cheat_small|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->green_bubble = atoi(explode("\n", explode("checkbox_cheat_bubble|", cch)[1])[0].c_str()) == 1 ? true : false;
									if (not pInfo(peer)->Cheat_AF and pInfo(peer)->Cheat_AF_PunchX != 0 and pInfo(peer)->Cheat_AF_PunchY != 0 and pInfo(peer)->Cheat_AF_PlantingTree != 0) pInfo(peer)->Cheat_AF_PunchX = 0, pInfo(peer)->Cheat_AF_PunchY = 0, pInfo(peer)->Cheat_AF_PlantingTree = 0, pInfo(peer)->Cheat_AF_isRunning = false, pInfo(peer)->isFacingLeft = false;
									if (!is_number(explode("\n", explode("text_input_spam_delay|", cch)[1])[0])) break;
									if (atoi(explode("\n", explode("text_input_spam_delay|", cch)[1])[0].c_str()) < 1) break;
									pInfo(peer)->Cheat_Spam_Delay = atoi(explode("\n", explode("text_input_spam_delay|", cch)[1])[0].c_str());
									string text = explode("\n", explode("text_input_spam_chat|", cch)[1])[0];
									if (text.length() > 120) break;
									pInfo(peer)->Cheat_Spam_Text = text;
									pInfo(peer)->Cheat_Spam = atoi(explode("\n", explode("checkbox_cheat_spam|", cch)[1])[0].c_str()) == 1 ? true : false;
									update_clothes(peer);
								}
								catch (...) {
									break;
								}
								break;
							}
							break;
						}
						else if (cch.find("action|dialog_return\ndialog_name|battlepass_tasks\nbuttonClicked|claim_") != string::npos) {
							if (pInfo(peer)->gp) {
								vector<string> t_ = explode("|", cch);
								if (t_.size() > 3) {
									string button = explode("\n", t_[3])[0].c_str();
									int remove_grow_points = 0;
									int grow_item = 0;
									int grow_item_count = 1;
									if (button == "claim_p2p_150") {
										grow_item = grow_pass_item;
										remove_grow_points = 150;
									}
									else if (button == "claim_p2p_300") {
										grow_item = 13556;
										remove_grow_points = 300;
									}
									else if (button == "claim_p2p_450") {
										grow_item = 10858;
										grow_item_count = 2;
										remove_grow_points = 450;
									}
									else if (button == "claim_p2p_600") {
										grow_item = 1486;
										remove_grow_points = 600;
									}
									else if (button == "claim_p2p_750") {
										grow_item = 2478;
										grow_item_count = 10;
										remove_grow_points = 750;
									}
									else if (button == "claim_p2p_900") {
										grow_item = 2480;
										remove_grow_points = 900;
									}
									else if (button == "claim_f2p_300") {
										grow_item = 10836;
										remove_grow_points = 300;
									}
									else if (button == "claim_f2p_600") {
										grow_item = 10838;
										remove_grow_points = 600;
									}
									else if (button == "claim_f2p_900") {
										grow_item = 1486;
										remove_grow_points = 900;
									}
									else if (button == "claim_p2p_1100") {
										grow_item = 8196;
										grow_item_count = 4;
										remove_grow_points = 1100;
									}
									else if (button == "claim_p2p_1300") {
										grow_item = 1486;
										grow_item_count = 2;
										remove_grow_points = 1300;
									}
									else if (button == "claim_f2p_1300") {
										grow_item = 10838;
										remove_grow_points = 1300;
									}
									else if (button == "claim_p2p_1500") {
										grow_item = 6140;
										remove_grow_points = 1500;
									}
									else if (button == "claim_p2p_1700") {
										grow_item = 2480;
										remove_grow_points = 1700;
									}
									else if (button == "claim_f2p_1700") {
										grow_item = 10836;
										remove_grow_points = 1700;
									}
									else if (button == "claim_p2p_1900") {
										grow_item = 2480;
										remove_grow_points = 1900;
									}
									else if (button == "claim_p2p_2100") {
										grow_item = grow_pass_item + 2;
										remove_grow_points = 2100;
									}
									else if (button == "claim_f2p_2100") {
										grow_item = 2992;
										remove_grow_points = 2100;
									}
									if (remove_grow_points != 0) {
										if (pInfo(peer)->growpass_points >= remove_grow_points) {
											if (find(pInfo(peer)->growpass_prizes.begin(), pInfo(peer)->growpass_prizes.end(), button) == pInfo(peer)->growpass_prizes.end()) {
												if (grow_item == 10858) {
													pInfo(peer)->growpass_prizes.push_back(button);
													OnSetVoucher(peer, grow_item_count);
												}
												else {
													int give_now = grow_item_count;
													if (modify_inventory(peer, grow_item, give_now) == 0) {
														pInfo(peer)->growpass_prizes.push_back(button);
														string text = "`9Claimed " + to_string(grow_item_count) + " " + items[grow_item].ori_name + " from Grow Pass rewards!``";
														Algorithm::send_bubble(peer, pInfo(peer)->netID, text);
														Algorithm::send_console(peer, text);
													}
													else {
														Algorithm::send_console(peer, "No inventory space.");
													}
												}
											}
											else {
												gamepacket_t p;
												p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wReward Details (claimed already)`|left|9222|\nadd_spacer|small|\nadd_spacer|small|\nadd_label_with_icon|big| " + to_string(grow_item_count) + " " + items[grow_item].ori_name + "|left|" + to_string(grow_item) + "|\nadd_textbox|" + items[grow_item].description + "|left|\nadd_spacer|small|\nadd_textbox|Earn `2" + to_string(remove_grow_points) + " Grow Pass Points`` and become a `5Royal Grow Pass Member``  to claim this reward.|left|\nadd_spacer|small|\nadd_textbox|`5This reward is only available for players with the `5Royal Grow Pass``.``|left|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|back|OK|noflags|0|0|\nend_dialog|battlepass_itemPeek|||"), p.CreatePacket(peer);

											}
										}
										else {
											gamepacket_t p;
											p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wReward Details`|left|9222|\nadd_spacer|small|\nadd_spacer|small|\nadd_label_with_icon|big| " + to_string(grow_item_count) + " " + items[grow_item].ori_name + "|left|" + to_string(grow_item) + "|\nadd_textbox|" + items[grow_item].description + "|left|\nadd_spacer|small|\nadd_textbox|Earn `2" + to_string(remove_grow_points) + " Grow Pass Points`` and become a `5Royal Grow Pass Member``  to claim this reward.|left|\nadd_spacer|small|\nadd_textbox|`5This reward is only available for players with the `5Royal Grow Pass``.``|left|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|back|OK|noflags|0|0|\nend_dialog|battlepass_itemPeek|||"), p.CreatePacket(peer);
										}
									}
								}

							}
							break;
							}
							else if (cch == "action|dialog_return\ndialog_name|battlepass_tasks\nbuttonClicked|tab_perks\n\n") {
								growpass_perks(peer);
								break;
						}
							else if (cch == "action|dialog_return\ndialog_name|battlepass_tasks\nbuttonClicked|tab_rewards\n\n") {
								growpass_rewards(peer);
								break;
						}
							else if (cch == "action|dialog_return\ndialog_name|battlepass_tasks\nbuttonClicked|tab_tasks\n\n" || cch == "action|growpass\n" || cch == "action|battlepasspopup\n") {
								growpass_tasks(peer);
								break;
						}
						if (cch.find("action|dialog_return\ndialog_name|dialog_mray_menu") != string::npos) {
							if (cch.find("buttonClicked|restore_default") != string::npos) {
								pInfo(peer)->tigapuluhfar = false;
								update_clothes(peer);
							}
							else {
								try {
									if (not (pInfo(peer)->mraylevel)) {
										Algorithm::send_console(peer, "Your Mythical Rayman Must Be Level 2");
										Algorithm::send_overlay(peer, "`4Update Failed!");
										break;
									}
									pInfo(peer)->tigapuluhfar = atoi(explode("\n", explode("checkbox_mray|", cch)[1])[0].c_str()) == 1 ? true : false;
									pInfo(peer)->Cheat_AF = atoi(explode("\n", explode("checkbox_autofarm|", cch)[1])[0].c_str()) == 1 ? true : false;
									if (not pInfo(peer)->Cheat_AF and pInfo(peer)->Cheat_AF_PunchX != 0 and pInfo(peer)->Cheat_AF_PunchY != 0 and pInfo(peer)->Cheat_AF_PlantingTree != 0) pInfo(peer)->Cheat_AF_PunchX = 0, pInfo(peer)->Cheat_AF_PunchY = 0, pInfo(peer)->Cheat_AF_PlantingTree = 0, pInfo(peer)->Cheat_AF_isRunning = false, pInfo(peer)->isFacingLeft = false;
									update_clothes(peer);
								}
								catch (...) {
									break;
								}
							}
						}
						else if (cch.find("action|dialog_return\ndialog_name|ringmaster1\nbuttonClicked|requir") != string::npos) {
							int bgl = 0, ticket = 0, block = 0, door = 0;
							modify_inventory(peer, 7188, bgl);
							modify_inventory(peer, 1898, ticket);
							modify_inventory(peer, 1674, door);
							modify_inventory(peer, 262, block);
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9The Ringmaster|left|1900|\nadd_spacer|small|\nadd_textbox|`oYou must have all the Requirements below to get a gift item from me|\nadd_spacer|small|\nadd_textbox|`2Requirements List:|\nadd_spacer|small|\nadd_label_with_icon|small|`o(" + to_string(bgl) + "/1) Blue Gem Lock.|left|7188|\nadd_label_with_icon|small|`o(" + to_string(door) + "/1) `4Phoenix Wings.|left|1674|\nadd_label_with_icon|small|`o(" + to_string(block) + "/100) Crystal Blocks.|left|262|\nadd_label_with_icon|small|`o(" + to_string(ticket) + "/100) Golden Ticket.|left|1898|\nadd_label_with_icon|small|`o(" + setGems(pInfo(peer)->gems) + "/10.000) Gems.|left|9438|\nadd_spacer|small|\nend_dialog|goodbyee|`$GoodLuck!|");
							p.CreatePacket(peer);
							break;
						}
						else if (cch.find("action|dialog_return\ndialog_name|dnaproc") != string::npos) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								world_->fresh_world = true;
								WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
								if (not block_access(peer, world_, block_)) break;
								int DNAID;
								int remove = 0 - 1;
								int add = 1;
								if (cch.find("tilex|") != string::npos and cch.find("tiley|") != string::npos) {
									int x_ = atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str());
									std::stringstream ss(cch);
									std::string to;
									try {
										while (std::getline(ss, to, '\n')) {
											vector<string> infoDat = explode("|", to);
											if (infoDat.at(0) == "choose") {
												DNAID = atoi(infoDat.at(1).c_str());
												if (items[DNAID].name.find("Dino DNA Strand") != string::npos || items[DNAID].name.find("Plant DNA Strand") != string::npos || items[DNAID].name.find("Raptor DNA Strand") != string::npos) {
													if (block_->shelf_4 == 0) {
														block_->shelf_1 = DNAID;
														block_->shelf_4 = 1;
														modify_inventory(peer, DNAID, remove);
														SendDNAProcessor(peer, x_, y_, false, true, false, 0, true, false);
													}
													else if (block_->shelf_4 == 1) {
														block_->shelf_2 = DNAID;
														block_->shelf_4 = 2;
														modify_inventory(peer, DNAID, remove);
														SendDNAProcessor(peer, x_, y_, false, true, false, 0, true, false);
													}
													else if (block_->shelf_4 == 2) {
														block_->shelf_3 = DNAID;
														block_->shelf_4 = 3;
														modify_inventory(peer, DNAID, remove);
														int DnaNumber1 = 0, DnaNumber2 = 0, DnaNumber3 = 0, What = 0;
														ifstream infile("database/DnaRecipe.txt");
														for (string line; getline(infile, line);) {
															if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
																auto ex = explode("|", line);
																int id1 = atoi(ex.at(0).c_str());
																int id2 = atoi(ex.at(1).c_str());
																int id3 = atoi(ex.at(2).c_str());
																if (id1 == block_->shelf_1 && id2 == block_->shelf_2 && id3 == block_->shelf_3) {
																	DnaNumber1 = atoi(ex.at(0).c_str());
																	DnaNumber2 = atoi(ex.at(1).c_str());
																	DnaNumber3 = atoi(ex.at(2).c_str());
																	What = atoi(ex.at(3).c_str());
																	break;
																}
															}
														}
														infile.close();
														if (block_->shelf_1 == DnaNumber1 && block_->shelf_2 == DnaNumber2 && block_->shelf_3 == DnaNumber3 && DnaNumber3 != 0 && DnaNumber2 != 0 && DnaNumber1 != 0 && What != 0) {
															SendDNAProcessor(peer, x_, y_, false, true, false, 0, true, false);
														}
														else {
															if (block_->shelf_4 >= 1) {
																SendDNAProcessor(peer, x_, y_, false, true, false, 0, true, true);
															}
															else {
																SendDNAProcessor(peer, x_, y_, false, false, false, 0, true, true);
															}
														}
													}
												}
												else {
													if (block_->shelf_4 >= 1) {
														SendDNAProcessor(peer, x_, y_, true, false, false, 0, true, false);
													}
													else {
														SendDNAProcessor(peer, x_, y_, true, false, false, 0, false, false);
													}
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
									if (cch.find("buttonClicked|remove0") != string::npos) {
										if (block_->shelf_4 == 1) {
											int DNARemoved = block_->shelf_1;
											modify_inventory(peer, DNARemoved, add);
											block_->shelf_1 = 0;
											block_->shelf_4 = 0;
											SendDNAProcessor(peer, x_, y_, false, false, true, DNARemoved, false, false);
										}
										if (block_->shelf_4 == 2) {
											int DNARemoved = block_->shelf_1;
											modify_inventory(peer, DNARemoved, add);
											block_->shelf_1 = block_->shelf_2;
											block_->shelf_2 = 0;
											block_->shelf_4 = 1;
											SendDNAProcessor(peer, x_, y_, false, false, true, DNARemoved, true, false);
										}
										if (block_->shelf_4 == 3) {
											int DNARemoved = block_->shelf_1;
											modify_inventory(peer, DNARemoved, add);
											block_->shelf_1 = block_->shelf_2;
											block_->shelf_2 = block_->shelf_3;
											block_->shelf_3 = 0;
											block_->shelf_4 = 2;
											SendDNAProcessor(peer, x_, y_, false, false, true, DNARemoved, true, false);
										}
									}
									if (cch.find("buttonClicked|remove1") != string::npos) {
										if (block_->shelf_4 == 2) {
											int DNARemoved = block_->shelf_2;
											modify_inventory(peer, DNARemoved, add);
											block_->shelf_2 = 0;
											block_->shelf_4 = 1;
											SendDNAProcessor(peer, x_, y_, false, false, true, DNARemoved, true, false);
										}
										if (block_->shelf_4 == 3) {
											int DNARemoved = block_->shelf_2;
											modify_inventory(peer, DNARemoved, add);
											block_->shelf_2 = block_->shelf_3;
											block_->shelf_3 = 0;
											block_->shelf_4 = 2;
											SendDNAProcessor(peer, x_, y_, false, false, true, DNARemoved, true, false);
										}
									}
									if (cch.find("buttonClicked|remove2") != string::npos) {
										if (block_->shelf_4 == 3) {
											int DNARemoved = block_->shelf_3;
											modify_inventory(peer, DNARemoved, add);
											block_->shelf_3 = 0;
											block_->shelf_4 = 2;
											SendDNAProcessor(peer, x_, y_, false, false, true, DNARemoved, true, false);
										}
									}
									if (cch.find("buttonClicked|combine") != string::npos) {
										if (block_->shelf_4 == 3) {
											int DnaNumber1 = 0, DnaNumber2 = 0, DnaNumber3 = 0, What;
											ifstream infile("database/DnaRecipe.txt");
											for (string line; getline(infile, line);) {
												if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
													auto ex = explode("|", line);
													int id1 = atoi(ex.at(0).c_str());
													int id2 = atoi(ex.at(1).c_str());
													int id3 = atoi(ex.at(2).c_str());
													if (id1 == block_->shelf_1 && id2 == block_->shelf_2 && id3 == block_->shelf_3) {
														DnaNumber1 = atoi(ex.at(0).c_str());
														DnaNumber2 = atoi(ex.at(1).c_str());
														DnaNumber3 = atoi(ex.at(2).c_str());
														What = atoi(ex.at(3).c_str());
														break;
													}
												}
											}
											infile.close();
											if (block_->shelf_1 == DnaNumber1 && block_->shelf_2 == DnaNumber2 && block_->shelf_3 == DnaNumber3 && DnaNumber3 != 0 && DnaNumber2 != 0 && DnaNumber1 != 0 && What != 0) {
												int count = 1;//items[What].blockType == BlockTypes::FOREGROUND ? 10 : 5;
												modify_inventory(peer, What, count);
												if (items[What].clothType == ClothTypes::FEET) pInfo(peer)->feet = What;
												else if (items[What].clothType == ClothTypes::HAND) pInfo(peer)->hand = What;
												block_->shelf_1 = 0; block_->shelf_2 = 0; block_->shelf_3 = 0; block_->shelf_4 = 0;
												if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 15 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
													pInfo(peer)->C_QuestProgress++;
													if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
														pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
														gamepacket_t p;
														p.Insert("OnTalkBubble");
														p.Insert(pInfo(peer)->netID);
														p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
														p.Insert(0), p.Insert(0);
														p.CreatePacket(peer);
													}
												}
												gamepacket_t p, p2;
												p.Insert("OnConsoleMessage"), p.Insert("DNA Processing complete! The DNA combined into a `2" + items[What].name + "``!"), p.CreatePacket(peer);
												p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("DNA Processing complete! The DNA combined into a `2" + items[What].name + "``!"), p2.Insert(0), p2.Insert(0), p2.CreatePacket(peer);
												update_clothes(peer);
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (pInfo(currentPeer)->world == pInfo(peer)->world) {
														{
															gamepacket_t p;
															p.Insert("OnParticleEffect"); p.Insert(44); p.Insert((float)x_ * 32 + 16, (float)y_ * 32 + 16); p.CreatePacket(currentPeer);
														}
														{
															PlayerMoving data_{};
															data_.packetType = 19, data_.plantingTree = 150, data_.netID = pInfo(peer)->netID;
															data_.punchX = What, data_.punchY = What;
															int32_t to_netid = pInfo(peer)->netID;
															BYTE* raw = packPlayerMoving(&data_);
															raw[3] = 3;
															memcpy(raw + 8, &to_netid, 4);
															send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
															delete[]raw;
														}
													}
												}
											}
											else {
												SendDNAProcessor(peer, x_, y_, false, false, false, 0, true, true);
											}

										}
									}
								}
							}
						}
						else if (cch.find("action|dialog_return\ndialog_name|pianowings\nbuttonClicked|manual\n") != string::npos) {
							int volume = 50;
							string note = "C-C-D-C-E-F";
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wMusical Wings``|left|10182|\n"
								"add_spacer|small|\n"
								"add_textbox|This wing will play up to 16 music notes. Each note is triggered as you pass over a block.|left|\n"
								"add_textbox|In the `2Volume `obox, enter a volume level for these notes, from 1-100. 100 is the normal volume of music notes.|left|\n"
								"add_textbox|In the `2Notes `obox, enter up to 16 music notes to play. For each note, you enter 2 symbols:|left|\n"
								"add_smalltext|-The note to play, `2A to G`0, as in normal music notation. Lowercase for lower octave, uppercase for higher.|\n"
								"add_smalltext|Spaces are optional, but sure make it easier to read.|\n"
								"add_smalltext|- Last, a `2#`o for a sharp note, a - for a natural note, or a `2b `ofor a flat note.|\n"
								"add_smalltext|Spaces are optional, but sure make it easier to read.|\n"
								"add_text_input|volume|Volume|" + to_string(volume) + "|3|\n"
								"add_text_input|text|Notes|" + note + "|50|\n"
								"add_spacer|small|\nadd_button|resoterdefault|Restore to Default|noflags|0|0|\n"
								"end_dialog|pianowings|Cancel|Update| ");
							p.CreatePacket(peer);
							break;
						}
						else if (cch.find("action|dialog_return\ndialog_name|pianowings\nbuttonClicked|resoterdefault\n") != string::npos) {
							int volume = 100;
							string note = "C-F-G#G-F-B#A#G-F-G#G-D#G-C-";
							if (note.find_first_not_of("ABCDEFG-#abcdefg") != string::npos) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wMusical Wings``|left|10182|\nadd_spacer|small|\nadd_textbox|`4Notes must be from A to G!``|left|\nadd_button|manual|Instructions|noflags|0|0|\nadd_spacer|small|\nadd_text_input|volume|Volume|" + to_string(volume) + "|3|\nadd_text_input|text|Notes|" + note + "|50|\nadd_spacer|small|\nadd_button|resoterdefault|Restore to Default|noflags|0|0|\nend_dialog|pianowings|Cancel|Update|");
								p.CreatePacket(peer);
								break;
							}
							else {
								pInfo(peer)->musical_volume = volume;
								pInfo(peer)->musical_note = note;
								update_clothes(peer);
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("`wUpdated Musical Wings!");
								p.Insert(0);
								p.CreatePacket(peer);
							}
							break;
						}
						else if (cch.find("action|dialog_return\ndialog_name|dnaget") != string::npos) {
							if (cch.find("tilex|") != string::npos and cch.find("tiley|") != string::npos and cch.find("item|") != string::npos) {
								int x_ = atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str());
								int item = atoi(explode("\n", explode("item|", cch)[1])[0].c_str());
								int remove = -1;
								if (modify_inventory(peer, item, remove) == 0) {
									int Random = rand() % 100, reward = 0, count = 1;
									vector<int> list{ 4082, 4084, 4086, 4088, 4090, 4092, 4120, 4122, 5488 };
									gamepacket_t p, p2;
									p.Insert("OnTalkBubble"), p2.Insert("OnConsoleMessage"); p.Insert(pInfo(peer)->netID);
									if (Random >= 4 and Random <= 10) {
										reward = list[rand() % list.size()];
										p.Insert("You ground up a " + items[item].name + ", `9and found " + items[reward].name + " inside!``"), p2.Insert("You ground up a " + items[item].name + ", `9and found " + items[reward].name + " inside!``");
										modify_inventory(peer, reward, count);
									}
									else if (Random >= 1 and Random <= 3) {
										gamepacket_t a;
										a.Insert("OnConsoleMessage");
										a.Insert("Wow! You discovered the missing link between cave-rayman and the modern Growtopian.");
										reward = 5488;
										p.Insert("You ground up a " + items[item].name + ", `9and found " + items[reward].name + " inside!``"), p2.Insert("You ground up a " + items[item].name + ", `9and found " + items[reward].name + " inside!``");
										modify_inventory(peer, reward, count);
										a.CreatePacket(peer);
									}
									else {
										p.Insert("You ground up a " + items[item].name + ", `3but any DNA inside was destroyed in the process.``"), p2.Insert("You ground up a " + items[item].name + ", `3but any DNA inside was destroyed in the process.``");
									}
									p.Insert(0), p.Insert(0);
									p2.CreatePacket(peer), p.CreatePacket(peer);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(peer)->world) {
											if (reward != 0) {
												packet_(currentPeer, "action|play_sfx\nfile|audio/bell.wav\ndelayMS|0");
												PlayerMoving data_{};
												data_.packetType = 19, data_.plantingTree = 150, data_.netID = pInfo(peer)->netID;
												data_.punchX = reward, data_.punchY = reward;
												int32_t to_netid = pInfo(peer)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 3;
												memcpy(raw + 8, &to_netid, 4);
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												delete[]raw;
											}
											else {
												packet_(currentPeer, "action|play_sfx\nfile|audio/ch_start.wav\ndelayMS|0");
											}
										}
									}
								}
							}
						}
							else if (cch.find("action|dialog_return\ndialog_name|ringmaster1\nbuttonClicked|ring1") != string::npos) {
							vector<int> list2{ 1874, 1876, 1996, 2970, 3140, 3174, 1780, 1782, 1784, 6028, 6846, 8962, 11094, 1904, 1986, 1932 };
							int receive = 1, item = list2[rand() % list2.size()], got = 1;
							int remove = 0, bgl = 0, ticket = 0, block = 0, door = 0;
							modify_inventory(peer, 7188, bgl);
							modify_inventory(peer, 1898, ticket);
							modify_inventory(peer, 1674, door);
							modify_inventory(peer, 262, block);
							if (bgl < 1 || ticket < 100 || block < 100 || door < 1 || pInfo(peer)->gems < 10000) {
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("Need more requirements.");
								p.CreatePacket(peer);
								continue;
							}
							if (bgl >= 1 || ticket >= 100 || block >= 100 || door >= 1 || pInfo(peer)->gems >= 10000) {
								if (get_free_slots(pInfo(peer)) >= 3) {
									modify_inventory(peer, 7188, remove = -1);
									modify_inventory(peer, 1898, remove = -100);
									modify_inventory(peer, 1674, remove = -1);
									modify_inventory(peer, 262, remove = -100);
									modify_inventory(peer, item, receive); // receiving 
									pInfo(peer)->gems -= 10000;
									gamepacket_t p, p2, p3;
									p.Insert("OnTextOverlay");
									p.Insert("Well Well well.. You got " + items[item].ori_name + "!");
									p3.Insert("OnSetBux");
									p3.Insert(pInfo(peer)->gems);
									p3.Insert(0);
									p3.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
									if (pInfo(peer)->supp >= 2) {
										p.Insert((float)33796, (float)1, (float)0);
									}
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										p2.Insert("OnParticleEffect");
										p2.Insert(90), p2.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
										if (pInfo(currentPeer)->world == pInfo(peer)->world) p.CreatePacket(peer), p3.CreatePacket(peer), p2.CreatePacket(currentPeer);
										packet_(currentPeer, "action|log\nmsg|`5**Message from [`9The Ringmaster`5] in [`9" + pInfo(peer)->world + "`5]:** [`w" + pInfo(peer)->tankIDName + "`5] `5receive [`2" + items[item].ori_name + "`5]");
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("You need at least 2 Free Space");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(peer);
								}
							}
							break;
						}
							else if (cch.find("action|dialog_return\ndialog_name|spotify_menu\nchange|") != string::npos) {
								DialogBuilder spot;
								spot.add_label_icon(true, 828, "`4Ruby Ability")
									.add_spacer(false)
									.add_smalltext(">> `cWelcome to Rank Ruby ability in here you can read the ability / command ruby rank…")
									.add_spacer(false)
									.add_smalltext(">> `2Ability : `1/provider <skip time provider> /punch /rsb <Ruby Broadcast>")
									.add_spacer(false)
									.add_smalltext(">> `3if you want yo buying the Rank you can use command /buyruby")
									.add_spacer(false)
									.add_smalltext(">> `9PRICE : 3 GGL")
									.add_spacer(false)
									.end_dialog("spotify_dialog", "Nevermind", "")
									.add_quick_exit();
								enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(spot.to_string()).pack());
}
							else if (cch.find("action|dialog_return\ndialog_name|account_security\nchange|") != string::npos) {
								string change = cch.substr(57, cch.length() - 57).c_str();
								replace_str(change, "\n", "");
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								if (change == "email") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Information``|left|\nadd_smalltext|Having an up-to-date email address attached to your account is a great step toward improved account security.|left|\nadd_smalltext|Email: `5" + pInfo(peer)->email + "``|left|\nadd_spacer|small|\nadd_smalltext|Type your new `5email address``|left|\nadd_text_input|change|||50|\nend_dialog|change_email|OK|Continue|\n");
								else if (change == "password") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Information``|left|\nadd_smalltext|A hacker may attempt to access your account more than once over a period of time.|left|\nadd_smalltext|Changing your password `2often reduces the risk that they will have frequent access``.|left|\nadd_spacer|small|\nadd_smalltext|Type your new `5password``|left|\nadd_text_input|change|||18|\nend_dialog|change_password|OK|Continue|\n");
								if (change == "email" or change == "password") p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|change_email\nchange|") != string::npos) {
								string change = cch.substr(53, cch.length() - 53).c_str();
								replace_str(change, "\n", "");
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								if (change == "") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Information``|left|\nadd_smalltext|Having an up-to-date email address attached to your account is a great step toward improved account security.|left|\nadd_smalltext|Email: `5" + pInfo(peer)->email + "``|left|\nadd_spacer|small|\nadd_smalltext|Type your new `5email address``|left|\nadd_text_input|change|||50|\nend_dialog|change_email|OK|Continue|\n");
								else {
									pInfo(peer)->email = change;
									save_player(pInfo(peer), false);
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Information``|left|\nadd_smalltext|Having an up-to-date email address attached to your account is a great step toward improved account security.|left|\nadd_smalltext|Your new Email: `5" + pInfo(peer)->email + "``|left|\nadd_spacer|small|\nend_dialog|changedemail|OK||\n");
								}
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|change_password\nchange|") != string::npos) {
								string change = cch.substr(56, cch.length() - 56).c_str();
								replace_str(change, "\n", "");
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								if (change == "") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Information``|left|\nadd_smalltext|A hacker may attempt to access your account more than once over a period of time.|left|\nadd_smalltext|Changing your password `2often reduces the risk that they will have frequent access``.|left|\nadd_spacer|small|\nadd_smalltext|Type your new `5password``|left|\nadd_text_input|change|||18|\nend_dialog|change_password|OK|Continue|\n");
								else {
									{
										gamepacket_t p;
										p.Insert("SetHasGrowID"), p.Insert(1), p.Insert(pInfo(peer)->tankIDName), p.Insert(pInfo(peer)->tankIDPass = change);
										p.CreatePacket(peer);
									}
									save_player(pInfo(peer), false);
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Information``|left|\nadd_smalltext|A hacker may attempt to access your account more than once over a period of time.|left|\nadd_smalltext|Changing your password `2often reduces the risk that they will have frequent access``.|left|\nadd_smalltext|Your new password: `5" + pInfo(peer)->tankIDPass + "``|left|\nadd_spacer|small|\nend_dialog|changedpassword|OK||\n");
								}
								p.CreatePacket(peer);
								break;
								}
							else if (cch.find("action|dialog_return\ndialog_name|world_swap\nname_box|") != string::npos) {
								string world = cch.substr(53, cch.length() - 53).c_str(), currentworld = pInfo(peer)->world;
								int got = 0;
								replace_str(world, "\n", "");
								transform(world.begin(), world.end(), world.begin(), ::toupper);
								if (not check_blast(world) || currentworld == world) {
									gamepacket_t p;
									p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSwap World Names``|left|2580|\nadd_textbox|`4World swap failed - you don't own both worlds!``|left|\nadd_smalltext|This will swap the name of the world you are standing in with another world `4permanently``.  You must own both worlds, with a World Lock in place.<CR>Your `wChange of Address`` will be consumed if you press `5Swap 'Em``.|left|\nadd_textbox|Enter the other world's name:|left|\nadd_text_input|name_box|||32|\nadd_spacer|small|\nend_dialog|world_swap|Cancel|Swap 'Em!|"), p.CreatePacket(peer);
								}
								else create_address_world(peer, world, currentworld);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|modes_1_1") != string::npos) {

								bool nocip_1 = atoi(explode("\n", explode("nocip_1_1|", cch)[1])[0].c_str());
								bool nocip_2 = atoi(explode("\n", explode("nocip_1_2|", cch)[1])[0].c_str());

								//Auto Farm
								if (nocip_1) pInfo(peer)->Cheat_QemeMode = 1;
								else pInfo(peer)->Cheat_QemeMode = 0;

								if (nocip_2) pInfo(peer)->Cheat_RemeMode = 1;
								else pInfo(peer)->Cheat_RemeMode = 0;
								update_clothes(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|wrenchs_1_1") != string::npos) {

								bool nocip_1 = atoi(explode("\n", explode("nocip_1_1|", cch)[1])[0].c_str());
								bool nocip_2 = atoi(explode("\n", explode("nocip_1_2|", cch)[1])[0].c_str());
								bool nocip_3 = atoi(explode("\n", explode("nocip_1_3|", cch)[1])[0].c_str());

								if (nocip_1) pInfo(peer)->cheat_pull = 1;
								else pInfo(peer)->cheat_pull = 0;

								if (nocip_2) pInfo(peer)->cheat_kick = 1;
								else pInfo(peer)->cheat_kick = 0;

								if (nocip_3) pInfo(peer)->cheat_ban = 1;
								else pInfo(peer)->cheat_ban = 0;

								update_clothes(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|surgery\nbuttonClicked|tool") != string::npos) {
							if (pInfo(peer)->surgery_started) {
								int count = atoi(cch.substr(59, cch.length() - 59).c_str());
								if (count == 999) end_surgery(peer);
								else load_surgery(peer, count);
							}
							break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|levelup\nbuttonClicked|claimreward") != string::npos) {
								int count = atoi(cch.substr(66, cch.length() - 66).c_str());
								if (count < 1 || count >125) break;
								if (std::find(pInfo(peer)->lvl_p.begin(), pInfo(peer)->lvl_p.end(), count) == pInfo(peer)->lvl_p.end()) {
									if (pInfo(peer)->level >= count) {
										pInfo(peer)->lvl_p.push_back(count);
										packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
										gamepacket_t p;
										p.Insert("OnSetBux");
										p.Insert(pInfo(peer)->kit += count * 10);
										p.Insert(0);
										p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
										if (pInfo(peer)->supp >= 2) {
											p.Insert((float)33796, (float)1, (float)0);
										}
										p.CreatePacket(peer);
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Congratulations! You have received your Level Up Reward!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
										}
										PlayerMoving data_{};
										data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
										BYTE* raw = packPlayerMoving(&data_);
										send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										delete[] raw;
										level_show(peer);
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|statsblock\nisStatsWorldBlockUsableByPublic") != string::npos) {
								vector<string> t_ = explode("|", cch);
								if (t_.size() < 4) break;
								bool world_public = atoi(explode("\n", t_[3])[0].c_str()), floating_public = atoi(explode("\n", t_[4])[0].c_str()),  changed = false;
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									if (pInfo(peer)->tankIDName == world_->owner_name) {
										for (int i_ = 0; i_ < world_->gscan.size(); i_++) {
											if (world_->gscan[i_].x == pInfo(peer)->lastwrenchx and world_->gscan[i_].y == pInfo(peer)->lastwrenchy) {
											changed = true;
											world_->gscan[i_].world_public = world_public;
											 world_->gscan[i_].floating_public = floating_public;
											}
										}
									}
									if (changed == false) {
										WorldGrowscan gscan_{};
										gscan_.x = pInfo(peer)->lastwrenchx, gscan_.y = pInfo(peer)->lastwrenchy;
										gscan_.world_public = world_public, gscan_.floating_public = floating_public;
										world_->gscan.push_back(gscan_);
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|statsblock\nbuttonClicked|back_to_gscan\n") != string::npos || cch.find("action|dialog_return\ndialog_name|statsblockworld\nbuttonClicked|back_to_gscan\n") != string::npos) {
								edit_tile(peer, pInfo(peer)->lastwrenchx, pInfo(peer)->lastwrenchy, 32);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|statsblock\nbuttonClicked|floatingItems\n") != string::npos) {
								send_growscan_floating(peer, "start", "1");
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|statsblock\nbuttonClicked|search_") != string::npos) {
							try {
								string type = cch.substr(65, 1);
								string search = cch.substr(79, cch.length() - 79);
								if (type.length() < 1 || search.length() < 1) break;
								replace_str(search, "\n", "");
								replace_str(type, "\n", "");
								send_growscan_floating(peer, search, type);
							}
							catch (out_of_range) {
								break;
							}
							break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|statsblock\nbuttonClicked|worldBlocks\n") != string::npos || cch.find("action|dialog_return\ndialog_name|statsblockworld\nbuttonClicked|worldBlocks\n") != string::npos) {
							if (cch.find("action|dialog_return\ndialog_name|statsblock\nbuttonClicked|worldBlocks\n") != string::npos) send_growscan_worldblocks(peer, "start", "1");
							if (cch.find("action|dialog_return\ndialog_name|statsblockworld\nbuttonClicked|worldBlocks\n") != string::npos) send_growscan_worldblocks(peer, "start", "1");
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|bank_pol\n") != string::npos) {
								if (cch.find("buttonClicked|regis_") != string::npos) {
									DialogBuilder p("`o");
									p.add_label_icon(true, 7188, "`oBuat Bank ID Kamu");
									p.add_spacer(false);
									p.add_textbox("`oJika Kamu Membuat Bank ID Kamu Akan Di Mudahkan Untuk Transaksi Di Server Ini");
									p.add_smalltext("`oNOTE: Kamu Akan Mendapatkan Visa Card Setelah Melakukan Pembuatan BankID!");
									p.add_spacer(false);
									p.add_text_input(5, "bank", "Bank ID:", "");
									p.add_spacer(false);
									p.add_quick_exit().end_dialog("bank_tut", "Nevermind!", "Continue");
									enet_peer_send(peer, 0, Variant{ "OnDialogRequest" }.push(p.to_string()).pack());
								}
							}
							else if (cch.find("action|dialog_return\ndialog_name|statsblockworld\nbuttonClicked|search_") != string::npos) {
								string type = cch.substr(70, 1);
								string search = cch.substr(84, cch.length() - 84);
								if (type.empty() || search.empty() || type.length() < 1 || search.length() < 1) break;
								replace_str(search, "\n", "");
								replace_str(type, "\n", "");
								send_growscan_worldblocks(peer, search, type);
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|billboard_edit\nbillboard_toggle|") != string::npos) {
								vector<string> t_ = explode("|", cch);
								if (t_.size() < 4) break;
								int billboard_active = atoi(explode("\n", t_[3])[0].c_str());
								int billboard_price = atoi(explode("\n", t_[4])[0].c_str());
								int peritem = atoi(explode("\n", t_[5])[0].c_str());
								int perlock = atoi(explode("\n", t_[6])[0].c_str());
								bool update_billboard = true;
								if (peritem == perlock or peritem == 0 and perlock == 0 or peritem == 1 and perlock == 1) {
									update_billboard = false;
									gamepacket_t p, p2;
									p.Insert("OnConsoleMessage"), p.Insert("You need to pick one pricing method - 'locks per item' or 'items per lock'"), p.CreatePacket(peer);
									p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("You need to pick one pricing method - 'locks per item' or 'items per lock'"), p2.Insert(0), p2.Insert(1), p2.CreatePacket(peer);
								}
								else {
									if (peritem == 1) pInfo(peer)->b_w = 1;
									if (perlock == 1) pInfo(peer)->b_w = 0;
								}
								if (billboard_active == 1)pInfo(peer)->b_a = 1;
								else pInfo(peer)->b_a = 0;
								if (billboard_price < 0 or billboard_price > 99999) {
									update_billboard = false;
									gamepacket_t p, p2;
									p.Insert("OnConsoleMessage"), p.Insert("Price can't be negative. That's beyond science."), p.CreatePacket(peer);
									p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("Price can't be negative. That's beyond science."), p2.Insert(0), p2.Insert(1), p2.CreatePacket(peer);
								}//gabut nunggu build
								else pInfo(peer)->b_p = billboard_price;
								if (update_billboard && pInfo(peer)->b_p != 0 && pInfo(peer)->b_i != 0) {
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnBillboardChange"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->b_i), p.Insert(pInfo(peer)->b_a), p.Insert(pInfo(peer)->b_p), p.Insert(pInfo(peer)->b_w);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
										p.CreatePacket(currentPeer);
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|dialog_scarf_of_seasons\nbuttonClicked") != string::npos) {
								if (pInfo(peer)->necklace == 11818) pInfo(peer)->i_11818_1 = 0, pInfo(peer)->i_11818_2 = 0, update_clothes(peer);
								break;
							}
							/*else if (cch.find("action|dialog_return\ndialog_name|title_edit\nbuttonClicked|") != string::npos) {
								if (pInfo(peer)->drtitle) pInfo(peer)->drt = atoi(explode("\n", explode("checkbox_doctor_title|", cch)[1])[0].c_str());
								if (pInfo(peer)->max_thread >= 1) pInfo(peer)->bxoost = atoi(explode("\n", explode("checkbox_bxoost_title|", cch)[1])[0].c_str());
								if (pInfo(peer)->level >= 125) pInfo(peer)->lvl125 = atoi(explode("\n", explode("checkbox_maxlevel_title|", cch)[1])[0].c_str());
								if (pInfo(peer)->legend) pInfo(peer)->is_legend = atoi(explode("\n", explode("checkbox_legend_title|", cch)[1])[0].c_str());
								if (pInfo(peer)->accttbadge) pInfo(peer)->ttBadge = atoi(explode("\n", explode("checkbox_tt_title|", cch)[1])[0].c_str());
								if (pInfo(peer)->accCcbadge) pInfo(peer)->ccBadge = atoi(explode("\n", explode("checkbox_cc_title|", cch)[1])[0].c_str());
								if (pInfo(peer)->max_thread >= 2) pInfo(peer)->rb = atoi(explode("\n", explode("checkbox_rainbow_title|", cch)[1])[0].c_str());
								if (pInfo(peer)->have_master || pInfo(peer)->gp) pInfo(peer)->master = atoi(explode("\n", explode("checkbox_master_title|", cch)[1])[0].c_str());
								if (pInfo(peer)->have_donor || pInfo(peer)->gp) pInfo(peer)->donor = atoi(explode("\n", explode("checkbox_g4g_title|", cch)[1])[0].c_str());
								update_clothes(peer);
								update_nick(peer);
								break;
							}*/
							else if (cch.find("action|dialog_return\ndialog_name|title_edit\nbuttonClicked|") != string::npos) {
								try {
									vector<string> t_ = explode("|", cch);
									pInfo(peer)->ttBadge = 0;
									if (t_.size() < 4) break;
									int total = 4;
									if (pInfo(peer)->drtitle) {
										pInfo(peer)->drt = atoi(explode("\n", t_.at(total++)).at(0).c_str());
										string thetag = (pInfo(peer)->mod || pInfo(peer)->dev ? "@" : "");
										pInfo(peer)->d_name = (pInfo(peer)->drt ? "`4" + thetag : pInfo(peer)->name_color) + (pInfo(peer)->drt ? "Dr." : "") + pInfo(peer)->tankIDName;
										if (!pInfo(peer)->drt) pInfo(peer)->d_name = "";
										{
											gamepacket_t p2(0, pInfo(peer)->netID);
											p2.Insert("OnNameChanged"), p2.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)));
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
												p2.CreatePacket(currentPeer);
											}
										}
									}
									if (pInfo(peer)->dev && cch.find("ttBadge|1") != string::npos) pInfo(peer)->ttBadge = 1;
									if (pInfo(peer)->dev && cch.find("ccBadge|1") != string::npos) pInfo(peer)->ccBadge = 1;
									if (pInfo(peer)->level >= 125) pInfo(peer)->lvl125 = atoi(explode("\n", t_.at(total++)).at(0).c_str());
									if (pInfo(peer)->legend) {
										pInfo(peer)->is_legend = atoi(explode("\n", t_.at(total++)).at(0).c_str());
										string modtag = (pInfo(peer)->mod || pInfo(peer)->dev ? "@" : "");
										{
											gamepacket_t p2(0, pInfo(peer)->netID);
											p2.Insert("OnNameChanged"), p2.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : (pInfo(peer)->d_name.empty() ? pInfo(peer)->name_color : "`0") + "" + (pInfo(peer)->d_name.empty() ? pInfo(peer)->tankIDName : pInfo(peer)->d_name)) + (pInfo(peer)->is_legend ? " of Legend``" : ""));
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
												p2.CreatePacket(currentPeer);
											}
										}
									}
									if (pInfo(peer)->gp) pInfo(peer)->donor = atoi(explode("\n", t_.at(total++)).at(0).c_str()), pInfo(peer)->master = atoi(explode("\n", t_.at(total++)).at(0).c_str());
									update_clothes(peer);
								}
								catch (out_of_range& e) {
									infowarn(e.what());
									break;
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|bulletin_edit\nsign_text|\ncheckbox_locked|") != string::npos) {
								try {
									vector<string> t_ = explode("|", cch);
									if (t_.size() < 4) break;
									bool public_can_add = atoi(explode("\n", t_.at(4)).at(0).c_str()),  hide_names = atoi(explode("\n", t_.at(5)).at(0).c_str());
									bool changed = false;
									string name_ = pInfo(peer)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										World* world_ = &worlds[p - worlds.begin()];
										if (pInfo(peer)->tankIDName == world_->owner_name) {
											for (int i_ = 0; i_ < world_->bulletins.size(); i_++) {
												if (world_->bulletins.at(i_).x == pInfo(peer)->lastwrenchx and world_->bulletins.at(i_).y == pInfo(peer)->lastwrenchy) {
													changed = true;
													world_->bulletins.at(i_).public_can_add = public_can_add;
													world_->bulletins.at(i_).hide_names = hide_names;
												}
											}
										}
										if (changed == false) {
											WorldBulletinSettings set_{};
											set_.x = pInfo(peer)->lastwrenchx, set_.y = pInfo(peer)->lastwrenchy, set_.public_can_add = public_can_add, set_.hide_names = hide_names;
											world_->bulletins.push_back(set_);
										}
									}
								}
								catch (out_of_range) {
									break;
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|camera_edit\ncheckbox_showpick|") != string::npos) {
								try {
									vector<string> t_ = explode("|", cch);
									if (t_.size() < 4) break;
									bool show_item_taking = atoi(explode("\n", t_.at(3)).at(0).c_str()), show_item_dropping = atoi(explode("\n", t_.at(4)).at(0).c_str()),  show_people_entering = atoi(explode("\n", t_.at(5)).at(0).c_str()), show_people_exiting = atoi(explode("\n", t_.at(6)).at(0).c_str()), dont_show_owner = atoi(explode("\n", t_.at(7)).at(0).c_str()), dont_show_admins = atoi(explode("\n", t_.at(8)).at(0).c_str()),  dont_show_noaccess = atoi(explode("\n", t_.at(9)).at(0).c_str()), changed = false;
									string name_ = pInfo(peer)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										World* world_ = &worlds[p - worlds.begin()];
										for (int i_ = 0; i_ < world_->cctv_settings.size(); i_++) {
											if (world_->cctv_settings.at(i_).x == pInfo(peer)->lastwrenchx and world_->cctv_settings.at(i_).y == pInfo(peer)->lastwrenchy) {
												changed = true;
												world_->cctv_settings.at(i_).show_item_taking = show_item_taking;
												world_->cctv_settings.at(i_).show_item_dropping = show_item_dropping;
												world_->cctv_settings.at(i_).show_people_entering = show_people_entering;
												world_->cctv_settings.at(i_).show_people_exiting = show_people_exiting;
												world_->cctv_settings.at(i_).dont_show_owner = dont_show_owner;
												world_->cctv_settings.at(i_).dont_show_admins = dont_show_admins;
												world_->cctv_settings.at(i_).dont_show_noaccess = dont_show_noaccess;
											}
										}
										if (changed == false) {
											WorldCCTVSettings cctvs_{};
											cctvs_.x = pInfo(peer)->lastwrenchx, cctvs_.y = pInfo(peer)->lastwrenchy;
											cctvs_.show_item_taking = show_item_taking, cctvs_.show_item_dropping = show_item_dropping, cctvs_.show_people_entering = show_people_entering, cctvs_.show_people_exiting = show_people_exiting, cctvs_.dont_show_owner = dont_show_owner, cctvs_.dont_show_admins = dont_show_admins, cctvs_.dont_show_noaccess = dont_show_noaccess;
											world_->cctv_settings.push_back(cctvs_);
										}
									}
								}
								catch (out_of_range) {
									break;
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|camera_edit\nbuttonClicked|clear") != string::npos) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									for (int i_ = 0; i_ < world_->cctv.size(); i_++)if (world_->cctv[i_].x == pInfo(peer)->lastwrenchx and world_->cctv[i_].y == pInfo(peer)->lastwrenchy) {
										if (i_ != 0) {
											world_->cctv.erase(world_->cctv.begin() + i_);
											i_--;
										}
									}
								}
								{
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`2Camera log cleared.``"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|b_claimreward") != string::npos) {
								int reward = atoi(cch.substr(72, cch.length() - 72).c_str()), lvl = 0, count = 1;
								vector<int> list{ 6896, 6948, 1068, 1966, 1836, 5080, 10754, 1874, 6946 };
								if (reward <= 0 || reward > list.size()) break;
								if (list[reward - 1] == 1068) count = 10;
								if (find(pInfo(peer)->bb_p.begin(), pInfo(peer)->bb_p.end(), lvl = reward * 5) == pInfo(peer)->bb_p.end()) {
									if (pInfo(peer)->bb_lvl >= lvl) {
										if (modify_inventory(peer, list[reward - 1], count) == 0) {
											pInfo(peer)->bb_p.push_back(lvl);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											{
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert("Congratulations! You have received your Builder Reward!");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(peer);
											}
											PlayerMoving data_{};
											data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
											delete[] raw;
											{
												PlayerMoving data_{};
												data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16, data_.packetType = 19, data_.plantingTree = 100, data_.punchX = list[reward - 1], data_.punchY = pInfo(peer)->netID;
												int32_t to_netid = pInfo(peer)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 5;
												memcpy(raw + 8, &to_netid, 4);
												send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												delete[] raw;
											}
											builder_reward_show(peer);
										}
										else {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("You have full inventory space!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|autoclave\nbuttonClicked|tool") != string::npos) {
								int itemtool = atoi(cch.substr(61, cch.length() - 61).c_str());
								if (itemtool == 1258 || itemtool == 1260 || itemtool == 1262 || itemtool == 1264 || itemtool == 1266 || itemtool == 1268 || itemtool == 1270 || itemtool == 4308 || itemtool == 4310 || itemtool == 4312 || itemtool == 4314 || itemtool == 4316 || itemtool == 4318) {
									int got = 0;
									modify_inventory(peer, itemtool, got);
									if (got >= 20) {
										pInfo(peer)->lastchoosenitem = itemtool;
										gamepacket_t p;
										p.Insert("OnDialogRequest");
										p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Autoclave``|left|4322|\nadd_spacer|small|\nadd_textbox|Are you sure you want to destroy 20 " + items[itemtool].ori_name + " in exchange for one of each of the other 12 surgical tools?|left|\nadd_button|verify|Yes!|noflags|0|0|\nend_dialog|autoclave|Cancel||");
										p.CreatePacket(peer);
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|autoclave\nbuttonClicked|verify") != string::npos) {
								int removeitem = pInfo(peer)->lastchoosenitem, inventory_space = 12, slots = get_free_slots(pInfo(peer)), got = 0;
								modify_inventory(peer, removeitem, got);
								if (got >= 20) {
									vector<int> noobitems{ 1262, 1266, 1264, 4314, 4312, 4318, 4308, 1268, 1258, 1270, 4310, 4316 };
									bool toobig = false;
									for (int i_ = 0, remove = 0; i_ < pInfo(peer)->inv.size(); i_++) for (int i = 0; i < noobitems.size(); i++) {
										if (pInfo(peer)->inv[i_].id == noobitems[i]) {
											if (pInfo(peer)->inv[i_].count == 200) toobig = true;
											else inventory_space -= 1;
										}
									}
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									if (toobig == false && slots >= inventory_space) {
										modify_inventory(peer, removeitem, got = -20);
										for (int i = 0; i < noobitems.size(); i++) {
											if (noobitems[i] == removeitem) continue;
											modify_inventory(peer, noobitems[i], got = 1);
										}
										gamepacket_t p2;
										p.Insert("[`3I swapped 20 " + items[removeitem].ori_name + " for 1 of every other instrument!``]");
										p2.Insert("OnTalkBubble"), p2.Insert("[`3I swapped 20 " + items[removeitem].name + " for 1 of every other instrument!``]"), p2.CreatePacket(peer);
									}
									else p.Insert("No inventory space!");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|extractor\nbuttonClicked|extractOnceObj_") != string::npos) {
								int got = 0;
								modify_inventory(peer, 6140, got);
								if (got >= 1) {
									string name_ = pInfo(peer)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										World* world_ = &worlds[p - worlds.begin()];
										int uid = atoi(cch.substr(72, cch.length() - 72).c_str());
										if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) break;
										for (int i_ = 0; i_ < world_->drop.size(); i_++) {
											if (world_->drop[i_].id != 0 && world_->drop[i_].x > 0 && world_->drop[i_].y > 0 && world_->drop[i_].uid == uid) {
												gamepacket_t p;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
												int c_ = world_->drop[i_].count;
												if (modify_inventory(peer, world_->drop[i_].id, c_) == 0) {
													modify_inventory(peer, 6140, got = -1);
													p.Insert("You have extracted " + to_string(world_->drop[i_].count) + " " + items[world_->drop[i_].id].name + ".");
													int32_t to_netid = pInfo(peer)->netID;
													PlayerMoving data_{}, data2_{};
													data_.effect_flags_check = 1, data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop[i_].uid;
													data2_.x = world_->drop[i_].x, data2_.y = world_->drop[i_].y, data2_.packetType = 19, data2_.plantingTree = 500, data2_.punchX = world_->drop[i_].id, data2_.punchY = pInfo(peer)->netID;
													BYTE* raw = packPlayerMoving(&data_);
													BYTE* raw2 = packPlayerMoving(&data2_);
													raw2[3] = 5;
													memcpy(raw2 + 8, &to_netid, 4);
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
														send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
														send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
													}
													delete[]raw, raw2;
													world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
												}
												else p.Insert("No inventory space.");
												p.CreatePacket(peer);
											}
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|zombie_back\nbuttonClicked|zomb_price_") != string::npos) {
							int item = atoi(cch.substr(70, cch.length() - 70).c_str());
							if (item <= 0 || item >= items.size() || items[item].zombieprice == 0) continue;
							pInfo(peer)->lockeitem = item;
							int zombie_brain = 0, pile = 0, total = 0;
							modify_inventory(peer, 10002, zombie_brain);
							modify_inventory(peer, 99999999, pile);
							total += zombie_brain + (pile * 100);
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							if (total >= items[item].zombieprice) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|" + items[item].name + " costs " + setGems(items[item].zombieprice) + " Coins. Are you sure you want to buy it? You have " + setGems(total) + " Coins.|left|\nadd_button|zomb_item_|Yes, please|noflags|0|0|\nadd_button|back|No, thanks|noflags|0|0|\nend_dialog|zombie_purchase|Hang Up||\n");
							else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|" + items[item].name + " costs " + setGems(items[item].zombieprice) + " Coins. You only have " + setGems(total) + " Coins so you can't afford it. Sorry!|left|\nadd_button|chc3_1|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
							p.CreatePacket(peer);
							break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|zurgery_back\nbuttonClicked|zurg_price_") != string::npos) {
							int item = atoi(cch.substr(71, cch.length() - 71).c_str());
							if (item <= 0 || item >= items.size() || items[item].surgeryprice == 0) continue;
							pInfo(peer)->lockeitem = item;
							int zombie_brain = 0, pile = 0, total = 0;
							modify_inventory(peer, 4298, zombie_brain);
							modify_inventory(peer, 4300, pile);
							total += zombie_brain + (pile * 100);
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							if (total >= items[item].surgeryprice) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|" + items[item].name + " costs " + setGems(items[item].surgeryprice) + " Caduceus. Are you sure you want to buy it? You have " + setGems(total) + " Caduceus.|left|\nadd_button|zurg_item_|Yes, please|noflags|0|0|\nadd_button|back|No, thanks|noflags|0|0|\nend_dialog|zurgery_purchase|Hang Up||\n");
							else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|" + items[item].name + " costs " + setGems(items[item].surgeryprice) + " Caduceus. You only have " + setGems(total) + " Caduceus so you can't afford it. Sorry!|left|\nadd_button|chc4_1|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
							p.CreatePacket(peer);
							break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|lite_back\nbuttonClicked|lite_price_") != string::npos) {
								int item = atoi(cch.substr(71, cch.length() - 71).c_str());
								if (item <= 0 || item >= items.size() || items[item].liteprice == 0) continue;
								pInfo(peer)->lockeitem = item;
								int zombie_brain = 0, pile = 0, total = 0;
								modify_inventory(peer, 10014, zombie_brain);
								modify_inventory(peer, 999999, pile);
								total += zombie_brain + (pile * 100);
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								if (total >= items[item].liteprice) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|" + items[item].name + " costs " + setGems(items[item].liteprice) + " `3Litecoins ``. Are you sure you want to buy it? You have " + setGems(total) + " Litecoins.|left|\nadd_button|lite_item_|Yes, please|noflags|0|0|\nadd_button|back|No, thanks|noflags|0|0|\nend_dialog|lite_purchase|Hang Up||\n");
								else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|" + items[item].name + " costs " + setGems(items[item].liteprice) + " Litecoins. You only have " + setGems(total) + " Litecoins so you can't afford it. Sorry!|left|\nadd_button|chc99_1|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
								p.CreatePacket(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|giantpotogold\namt|") != string::npos) {
								int count = atoi(cch.substr(51, cch.length() - 51).c_str()), got = 0;
								modify_inventory(peer, pInfo(peer)->lastchoosenitem, got);
								if (got <= 0 || count <= 0 || count > items.size()) break;
								int item = pInfo(peer)->lastchoosenitem;
								if (items[item].untradeable == 1 || item == 1424 || items[item].rarity >= 363 || items[item].rarity == 0 || items[item].rarity < 1 || count > got) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									if (count > got) p.Insert("You don't have that to give!");
									else p.Insert("I'm sorry, we can't accept items without rarity!");
									p.CreatePacket(peer);
								}
								else {
									pInfo(peer)->b_ra += count * items[item].rarity;
									modify_inventory(peer, pInfo(peer)->lastchoosenitem, count *= -1);
									if (pInfo(peer)->b_ra >= 200000) pInfo(peer)->b_lvl = 1;
									int chance = 29;
									if (pInfo(peer)->b_ra > 250000) chance += 25;
									if (pInfo(peer)->b_ra > 400000) chance += 25;
									if (rand() % 100 < chance && pInfo(peer)->b_ra >= 200000) {
										int give_count = 1, given_count = 1;
										vector<int> list{ 4288 };
										if (pInfo(peer)->b_ra >= 400000 && rand() % 100 < 100) list = { 10500 };
										int given_item = list[rand() % list.size()];
										if (given_item == 10500) give_count = 1, given_count = 1;
										if (modify_inventory(peer, given_item, given_count) == 0) {
											gamepacket_t p, p2;
											p.Insert("OnConsoleMessage"), p.Insert(a + "Thanks for your generosity! The Box overflows with `6" + (pInfo(peer)->b_ra < 400000 ? "20" : "400") + ",000 rarity``! Your `6Diamond Donator prize`` is a fabulous `2" + items[given_item].name + "!``"), p.CreatePacket(peer);
											p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert(a + "Thanks for your generosity! The pot overflows with `6" + (pInfo(peer)->b_ra < 400000 ? "20" : "40") + ",0000 rarity``! Your `6Level Diamond Donator prize`` is a fabulous `2" + items[given_item].name + "!``"), p2.CreatePacket(peer);
											pInfo(peer)->b_lvl = 2, pInfo(peer)->b_ra = 400000;
										}
										else {
											gamepacket_t p;
											p.Insert("OnConsoleMessage"), p.Insert("No inventory space."), p.CreatePacket(peer);
										}
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Thank you for your generosity!"), p.CreatePacket(peer);
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|donation_box_edit\nbuttonClicked|clear_selected\n") != string::npos) {
								try {
									bool took = false, fullinv = false;
									gamepacket_t p3;
									p3.Insert("OnTalkBubble"), p3.Insert(pInfo(peer)->netID);
									string name_ = pInfo(peer)->world;
									vector<string> t_ = explode("|", cch);
									if (t_.size() < 4) break;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										World* world_ = &worlds[p - worlds.begin()];
										if (world_->owner_name != pInfo(peer)->tankIDName and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) break;
										WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
										if (!items[block_->fg].donation) break;
										for (int i_ = 0, remove_ = 0; i_ < block_->donates.size(); i_++, remove_++) {
											if (atoi(explode("\n", t_.at(4 + remove_)).at(0).c_str())) {
												int receive = block_->donates[i_].count;
												if (modify_inventory(peer, block_->donates[i_].item, block_->donates[i_].count) == 0) {
													took = true;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->ispatrol == false) continue;
														gamepacket_t p;
														p.Insert("OnConsoleMessage");
														p.Insert("`9[PATROL] `0" + pInfo(peer)->tankIDName + " `oreceive `0" + items[block_->donates[i_].item].name + " `o" + to_string(receive) + "x from `0" + block_->donates[i_].name + "`oin `9" + pInfo(peer)->world + "`o.");
														p.CreatePacket(currentPeer);
													}
													gamepacket_t p;
													p.Insert("OnConsoleMessage"), p.Insert("`7[``" + pInfo(peer)->tankIDName + " receives `5" + to_string(receive) + "`` `w" + items[block_->donates[i_].item].name + "`` from `w" + block_->donates[i_].name + "``, how nice!`7]``");
													block_->donates.erase(block_->donates.begin() + i_), i_--;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
														p.CreatePacket(currentPeer);
													}
												}
												else fullinv = true;
											}
										}
										if (block_->donates.size() == 0) {
											WorldBlock block_ = world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
											PlayerMoving data_{};
											data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
											BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, &block_));
											BYTE* blc = raw + 56;
											form_visual(blc, block_, *world_, peer, false);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, &block_), ENET_PACKET_FLAG_RELIABLE);
											}
											delete[] raw, blc;
										}
									}
									if (fullinv) {
										p3.Insert("I don't have enough room in my backpack to get the item(s) from the box!");
										gamepacket_t p2;
										p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("`2(Couldn't get all of the gifts)``"), p2.CreatePacket(peer);
									}
									else if (took) p3.Insert("`2Box emptied.``");
									p3.CreatePacket(peer);
								}
								catch (out_of_range) {
									break;
								}
							break;
							}
							else if (cch == "action|claimdailyreward\n") {
								if (pInfo(peer)->pinata_prize == false) {
									int c_ = 1;
									gamepacket_t p_c;
									p_c.Insert("OnConsoleMessage");
									if (modify_inventory(peer, 9616, c_) == 0) {
										pInfo(peer)->pinata_day = today_day;
										pInfo(peer)->pinata_prize = true;
										pInfo(peer)->pinata_claimed = false;
										gamepacket_t p, p2;
										p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->pinata_claimed ? 1 : 0), p.Insert(pInfo(peer)->pinata_prize ? 1 : 0), p.CreatePacket(peer);
										p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("You got a Block De Mayo Block!"), p2.CreatePacket(peer);
										p_c.Insert("You got a Block De Mayo Block!");
									}
									else  p_c.Insert("You got a Block De Mayo Block!"),
										p_c.CreatePacket(peer);
								}
								break;
							}
							else if (cch == "action|showcincovolcaniccape\n" || cch == "action|showcincovolcanicwings\n") {
							gamepacket_t p(500);
							p.Insert("OnDialogRequest");
							if (cch == "action|showcincovolcanicwings\n") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wVolcanic Ventures : Volcanic Wings``|left|11870|\nadd_spacer|small|\nadd_textbox|Every `224 hours``, a limited amount of `2Volcanic Wings`` will be released into the game!|left|\nadd_spacer|small|\nadd_textbox|For your chance to find one of these `#Rare`` items, smash a `2Lava Pinata``. |left|\nadd_spacer|small|\nadd_textbox|There will only be 48 released every 24 hours so, be quick!|left|\nadd_spacer|small|\nadd_textbox|Did you know there are 48 active Volcanoes in Mexico?|left|\nend_dialog|volcanic_quest||OK|");
							else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wVolcanic Ventures : Volcanic Cape``|left|10806|\nadd_spacer|small|\nadd_textbox|Every `224 hours``, a limited amount of `2Volcanic Cape`` will be released into the game!|left|\nadd_spacer|small|\nadd_textbox|For your chance to find one of these `#Rare`` items, smash a `2Lava Pinata``. |left|\nadd_spacer|small|\nadd_textbox|There will only be 48 released every 24 hours so, be quick!|left|\nadd_spacer|small|\nadd_textbox|Did you know there are 48 active Volcanoes in Mexico?|left|\nend_dialog|volcanic_quest||OK|");
							p.CreatePacket(peer);
							break;
							}
							else if (cch == "action|opcshop\n") {
								gamepacket_t p(500);
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Online Point Hub``|left|10668|\nadd_spacer|small|\nadd_textbox|Welcome to Online Point HUB! Do you have any OPC? You can buy items from me with them.|left|\nadd_smalltext|`2You can earn 1 OPC by onlined 5 minute's on our server.``|left|\nadd_spacer|small|\nadd_textbox|You have `1" + setGems(pInfo(peer)->coin) + " ``Online Point``.|left|\ntext_scaling_string|99,000BPC|" + coin_list + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|chc0|OK|noflags|0|0|\nnend_dialog|gazette||OK|");
								p.CreatePacket(peer);
								break;
							}
							else if (cch == "action|cryptoopen\n") {
								crypto_iAlfa(peer);
								break;
							}
							else if (cch == "action|dqopen\n") {
								grow4good_reward(peer);
								break;
								}
							else if (cch == "action|dailyrewardmenu\n") {
							gamepacket_t p(500);
							p.Insert("OnDailyRewardRequest");
							if (pInfo(peer)->pinata_prize) {
								struct tm newtime;
								time_t now = time(0);
								localtime_s(&newtime, &now);
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBlock De Mayo|left|9616|\nset_border_color|250,250,250,250\nset_bg_color|0,0,0,255\nset_default_color|`o\nadd_image_button||interface/large/gui_shop_buybanner.rttex|bannerlayout|flag_frames:4,1,3,0|flag_surfsize:512,200|\nadd_smalltext|`7Get involved and get rewards!`` Smash an Ultra Pinata once a day during `5Cinco de Mayo Week`` and get a daily reward!|left|\nadd_spacer|small|\nadd_button|claimbutton|Come Back Later|noflags|0|0|\nadd_countdown|" + to_string(24 - newtime.tm_hour) + "H" + (60 - newtime.tm_min != 0 ? " " + to_string(60 - newtime.tm_min) + "M" : "") + "|center|disable|\nadd_quick_exit|");
							}
							else {
								if (pInfo(peer)->pinata_claimed) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBlock De Mayo|left|9616|\nset_border_color|250,250,250,250\nset_bg_color|0,0,0,255\nset_default_color|`o\nadd_image_button||interface/large/gui_shop_buybanner.rttex|bannerlayout|flag_frames:4,1,3,0|flag_surfsize:512,200|\nadd_smalltext|`7Get involved and get rewards!`` Smash an Ultra Pinata once a day during `5Cinco de Mayo Week`` and get a daily reward!|left|\nadd_spacer|small|\nadd_button|claimbutton|CLAIM|noflags|0|0|\nadd_countdown||center|enable|\nadd_quick_exit|");
								else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBlock De Mayo|left|9616|\nset_border_color|250,250,250,250\nset_bg_color|0,0,0,255\nset_default_color|`o\nadd_image_button||interface/large/gui_shop_buybanner.rttex|bannerlayout|flag_frames:4,1,3,0|flag_surfsize:512,200|\nadd_smalltext|`7Get involved and get rewards!`` Smash an Ultra Pinata once a day during `5Cinco de Mayo Week`` and get a daily reward!|left|\nadd_spacer|small|\nadd_button|claimbutton|Come Back Later|noflags|0|0|\nadd_countdown||center|disable|\nadd_quick_exit|");
							}
							p.CreatePacket(peer);
							break;
							}
							else if (cch == "action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|surgery_reward\n\n") {
							surgery_reward_show(peer);
							break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|password_reply\npassword|") != string::npos) {
								string password = cch.substr(57, cch.length() - 57).c_str();
								string name_ = pInfo(peer)->world;
								vector<World>::iterator pa = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (pa != worlds.end()) {
									World* world_ = &worlds[pa - worlds.begin()];
									WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
									if (block_->fg == 762 && block_->door_id != "") {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										replace_str(password, "\n", "");
										transform(password.begin(), password.end(), password.begin(), ::toupper);
										if (block_->door_id != password) p.Insert("`4Wrong password!``");
										else {
											p.Insert(a + "`2The door opens!" + (block_->door_destination == "" ? " But nothing is behind it." : "") + "``");
											if (block_->door_destination != "") {
												gamepacket_t p3(0, pInfo(peer)->netID);
												p3.Insert("OnPlayPositioned"), p3.Insert("audio/door_open.wav"), p3.CreatePacket(peer);
												string door_target = block_->door_destination, door_id = "";
												World target_world = worlds[pa - worlds.begin()];
												int spawn_x = 0, spawn_y = 0;
												if (door_target.find(":") != string::npos) {
													vector<string> detales = explode(":", door_target);
													door_target = detales[0], door_id = detales[1];
												} 
												int ySize = (int)target_world.blocks.size() / 100, xSize = (int)target_world.blocks.size() / ySize;
												if (not door_id.empty()) {
													for (int i_ = 0; i_ < target_world.blocks.size(); i_++) {
														WorldBlock block_data = target_world.blocks[i_];
														if (block_data.fg == 762) continue;
														if (block_data.fg == 1684 or items[block_data.fg].blockType == BlockTypes::DOOR or items[block_data.fg].blockType == BlockTypes::PORTAL) {
															if (block_data.door_id == door_id) {
																spawn_x = i_ % xSize, spawn_y = i_ / xSize;
																break;
															}
														}
													}
												}
												join_world(peer, target_world.name, spawn_x, spawn_y, 250, false, true);

											}
										}
										p.CreatePacket(peer);
									}
								}
								break;
							}
							else if (cch == "action|dialog_return\ndialog_name|2646\nbuttonClicked|off\n\n") {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world or block_->spotlight != pInfo(currentPeer)->tankIDName) continue;
										pInfo(currentPeer)->spotlight = false, update_clothes(currentPeer);
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("Back to anonymity. (`$In the Spotlight`` mod removed)"), p.CreatePacket(currentPeer);
									}
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Lights out!"), p.CreatePacket(peer);
									block_->spotlight = "";
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|dialog_eq_aura") != string::npos) {
								if (pInfo(peer)->eq_a_1 != 0 && !pInfo(peer)->eq_a_update) pInfo(peer)->eq_a = pInfo(peer)->eq_a_1, pInfo(peer)->eq_a_update = true;
								if (pInfo(peer)->eq_a_1 == 0) pInfo(peer)->eq_a_1 = 0, pInfo(peer)->eq_a = 0;
								update_clothes(peer);
								break;
						}
							if (cch.find("action|dialog_return\ndialog_name|dialog_minokawa_wings") != string::npos) {
								bool Minokawa_1 = atoi(explode("\n", explode("checkbox_minokawa_wings|", cch)[1])[0].c_str()), Minokawa_2 = atoi(explode("\n", explode("checkbox_minokawa_pet|", cch)[1])[0].c_str());
								if (Minokawa_1) pInfo(peer)->MKW = true;
								else pInfo(peer)->MKW = false;
								if (Minokawa_2) pInfo(peer)->MKP = true;
								else pInfo(peer)->MKP = false;
								update_clothes(peer);
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|2646\nID|") != string::npos) {
								int netID = atoi(cch.substr(41, cch.length() - 41).c_str());
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									string new_spotlight = "";
									World* world_ = &worlds[p - worlds.begin()];
									WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
										if (block_->spotlight == pInfo(currentPeer)->tankIDName || pInfo(currentPeer)->netID == netID) {
											if (pInfo(currentPeer)->netID == netID) {
												new_spotlight = pInfo(currentPeer)->tankIDName, pInfo(currentPeer)->spotlight = true;
												gamepacket_t p;
												p.Insert("OnConsoleMessage"), p.Insert("All eyes are on you! (`$In the Spotlight`` mod added)"), p.CreatePacket(currentPeer);
											}
											else {
												gamepacket_t p;
												p.Insert("OnConsoleMessage"), p.Insert("Back to anonymity. (`$In the Spotlight`` mod removed)"), p.CreatePacket(currentPeer);
												pInfo(currentPeer)->spotlight = false;
											}
											if (new_spotlight != "") for (int i_ = 0; i_ < world_->blocks.size(); i_++) if (world_->blocks[i_].spotlight == new_spotlight) world_->blocks[i_].spotlight = "";
											gamepacket_t p;
											p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You shine the light on "+ (new_spotlight == pInfo(peer)->tankIDName ? "yourself" : new_spotlight) + "!"), p.CreatePacket(peer);
											update_clothes(currentPeer);
										}
									}
									block_->spotlight = new_spotlight;
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|worlds_list\nbuttonClicked|s_claimreward") != string::npos) {
								int reward = atoi(cch.substr(72, cch.length() - 72).c_str()), lvl = 0, count = 1;
								vector<int> list{ 6900, 6982, 6212, 3172, 9068, 6912, 10836, 3130, 8284 };
								if (reward <= 0 || reward > list.size()) break;
								if (list[reward - 1] == 10836) count = 100;
								if (list[reward - 1] == 6212) count = 50;
								if (list[reward - 1] == 3172 || list[reward - 1] == 6912) count = 25;
								if (find(pInfo(peer)->surg_p.begin(), pInfo(peer)->surg_p.end(), lvl = reward * 5) == pInfo(peer)->surg_p.end()) {
									if (pInfo(peer)->s_lvl >= lvl) {
										if (modify_inventory(peer, list[reward - 1], count) == 0) {
											pInfo(peer)->surg_p.push_back(lvl);
											packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
											{
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert("Congratulations! You have received your Surgeon Reward!");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(peer);
											}
											PlayerMoving data_{};
											data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
											delete[] raw;
											{
												PlayerMoving data_{};
												data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16, data_.packetType = 19, data_.plantingTree = 100, data_.punchX = list[reward - 1], data_.punchY = pInfo(peer)->netID;
												int32_t to_netid = pInfo(peer)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 5;
												memcpy(raw + 8, &to_netid, 4);
												send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												delete[] raw;
											}
											surgery_reward_show(peer);
										}
										else {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("You have full inventory space!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return\ndialog_name|zombie_purchase\nbuttonClicked|zomb_item_") != string::npos) {
								int item = pInfo(peer)->lockeitem;
								if (item <= 0 || item >= items.size() || items[item].zombieprice == 0) continue;
								int allwl = 0, wl = 0, dl = 0, price = items[item].zombieprice;
								modify_inventory(peer, 10014, wl);
								modify_inventory(peer, 10002, dl);
								allwl = wl + (dl * 100);
								if (allwl >= price) {
									int c_ = 1;
									if (modify_inventory(peer, item, c_) == 0) {
										if (wl >= price) modify_inventory(peer, 10002, price *= -1);
										else {
											modify_inventory(peer, 10014, wl *= -1);
											modify_inventory(peer, 10002, dl *= -1);
											int givedl = (allwl - price) / 100;
											int givewl = (allwl - price) - (givedl * 100);
											modify_inventory(peer, 10014, givewl);
											modify_inventory(peer, 10002, givedl);
										}
										PlayerMoving data_{};
										data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = item, data_.punchY = pInfo(peer)->netID;
										int32_t to_netid = pInfo(peer)->netID;
										BYTE* raw = packPlayerMoving(&data_);
										raw[3] = 5;
										memcpy(raw + 8, &to_netid, 4);
										send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										delete[] raw;
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("`3You bought " + items[item].name + " for " + setGems(items[item].zombieprice) + " Coins."), p.CreatePacket(peer);
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("No inventory space."), p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage"), p.Insert("`9You don't have enough Coins!``"), p.CreatePacket(peer);
								}
								break;
						}
							else if (cch.find("action|dialog_return\ndialog_name|lite_purchase\nbuttonClicked|lite_item_") != string::npos) {
								int item = pInfo(peer)->lockeitem;
								if (item <= 0 || item >= items.size() || items[item].liteprice == 0) continue;
								int allwl = 0, wl = 0, dl = 0, price = items[item].liteprice;
								modify_inventory(peer, 10014, wl);
								modify_inventory(peer, 999999, dl);
								allwl = wl + (dl * 100);
								if (allwl >= price) {
									int c_ = 1;
									if (modify_inventory(peer, item, c_) == 0) {
										if (wl >= price) modify_inventory(peer, 999999, price *= -1);
										else {
											modify_inventory(peer, 10014, wl *= -1);
											modify_inventory(peer, 999999, dl *= -1);
											int givedl = (allwl - price) / 100;
											int givewl = (allwl - price) - (givedl * 100);
											modify_inventory(peer, 10014, givewl);
											modify_inventory(peer, 999999, givedl);
										}
										PlayerMoving data_{};
										data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = item, data_.punchY = pInfo(peer)->netID;
										int32_t to_netid = pInfo(peer)->netID;
										BYTE* raw = packPlayerMoving(&data_);
										raw[3] = 5;
										memcpy(raw + 8, &to_netid, 4);
										send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										delete[] raw;
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("`3You bought " + items[item].name + " for " + setGems(items[item].liteprice) + " Coins."), p.CreatePacket(peer);
									}
									else {
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("No inventory space."), p.CreatePacket(peer);
									}
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage"), p.Insert("`9You don't have enough Coins!``"), p.CreatePacket(peer);
								}
								break;
								}
						else if (cch.find("action|dialog_return\ndialog_name|zurgery_purchase\nbuttonClicked|zurg_item_") != string::npos) {
							int item = pInfo(peer)->lockeitem;
							if (item <= 0 || item >= items.size() || items[item].surgeryprice == 0) continue;
							int allwl = 0, wl = 0, dl = 0, price = items[item].surgeryprice;
							modify_inventory(peer, 4298, wl);
							modify_inventory(peer, 4300, dl);
							allwl = wl + (dl * 100);
							if (allwl >= price) {
								int c_ = 1;
								if (modify_inventory(peer, item, c_) == 0) {
									if (wl >= price) modify_inventory(peer, 4298, price *= -1);
									else {
										modify_inventory(peer, 4298, wl *= -1);
										modify_inventory(peer, 4300, dl *= -1);
										int givedl = (allwl - price) / 100;
										int givewl = (allwl - price) - (givedl * 100);
										modify_inventory(peer, 4298, givewl);
										modify_inventory(peer, 4300, givedl);
									}
									if (item == 1486 && pInfo(peer)->quest_active && pInfo(peer)->quest_step == 6 && pInfo(peer)->quest_progress < 28) {
										pInfo(peer)->quest_progress++;
										if (pInfo(peer)->quest_progress >= 28) {
											pInfo(peer)->quest_progress = 28;
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(peer);
										}
									}
									PlayerMoving data_{};
									data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = item, data_.punchY = pInfo(peer)->netID;
									int32_t to_netid = pInfo(peer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 5;
									memcpy(raw + 8, &to_netid, 4);
									send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									delete[] raw;
									gamepacket_t p;
									p.Insert("OnConsoleMessage"), p.Insert("`3You bought " + items[item].name + " for " + setGems(items[item].surgeryprice) + " Caduceus."), p.CreatePacket(peer);
								}
								else {
									gamepacket_t p;
									p.Insert("OnConsoleMessage"), p.Insert("No inventory space."), p.CreatePacket(peer);
								}
							}
							else {
								gamepacket_t p;
								p.Insert("OnConsoleMessage"), p.Insert("`9You don't have enough Caduceus!``"), p.CreatePacket(peer);
							}
							break;
						}
							else if (cch.find("action|dialog_return\ndialog_name|billboard_edit\nbillboard_item|") != string::npos) {
								vector<string> t_ = explode("|", cch);
								if (t_.size() < 4) break;
								int billboard_item = atoi(explode("\n", t_[3])[0].c_str());
								if (billboard_item > 0 && billboard_item < items.size()) {
									int got = 0;
									modify_inventory(peer, billboard_item, got);
									if (got == 0) break;
									if (items[billboard_item].untradeable == 1 or billboard_item == 1424 or items[billboard_item].blockType == BlockTypes::LOCK or items[billboard_item].blockType == BlockTypes::FISH) {
										gamepacket_t p, p2;
										p.Insert("OnConsoleMessage"), p.Insert("Item can not be untradeable."), p.CreatePacket(peer);
										p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("Item can not be untradeable."), p2.Insert(0), p2.Insert(1), p2.CreatePacket(peer);
									}
									else {
										pInfo(peer)->b_i = billboard_item;
										if (pInfo(peer)->b_p != 0 && pInfo(peer)->b_i != 0) {
											gamepacket_t p(0, pInfo(peer)->netID);
											p.Insert("OnBillboardChange"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->b_i), p.Insert(pInfo(peer)->b_a), p.Insert(pInfo(peer)->b_p), p.Insert(pInfo(peer)->b_w);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
												p.CreatePacket(currentPeer);
											}
										}
									}
								}
								break;
							}
							else if (cch.find("action|dialog_return") != string::npos) {
								call_dialog(peer, cch);
								break;
								}
						}
						else if (cch.find("action|dialog_return") != string::npos) {
							call_dialog(peer, cch);
							break;
						}
						break;
					}
					case 3: // world/enter
					{
						//auto start = chrono::steady_clock::now();
						if (pInfo(peer)->trading_with != -1) {
							cancel_trade(peer, false);
							break;
						}
						string cch = text_(event.packet);
						if (pInfo(peer)->lpps2 + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
							pInfo(peer)->pps2 = 0;
							pInfo(peer)->lpps2 = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
						}
						else {
							pInfo(peer)->pps2++;
							if (pInfo(peer)->pps2 >= 10) {
								cout << "Over packet 3 limit from " << pInfo(peer)->tankIDName << " in world " << pInfo(peer)->world << " packet was " << cch << endl;
								enet_peer_disconnect_later(peer, 0);
								break;
							}
						}
						if (cch == "action|quit") { // kai quit issaugo dar bus settings ar captcha bypassed disconnect
							if (not pInfo(peer)->tankIDName.empty()) // jeigu yra growid   
								save_player(pInfo(peer)); // issaugoti zaidejo json   
							if (pInfo(peer)->platformid == "0") {
								WindowsAdd - 1;
							}
							if (pInfo(peer)->platformid == "1") {
								iPhoneAdd - 1;
							}
							if (pInfo(peer)->platformid == "2") {
								MacosAdd - 1;
							}
							if (pInfo(peer)->platformid == "3") {
								LinuxAdd - 1;
							}
							if (pInfo(peer)->platformid == "4") {
								AndroidAdd - 1;
							}
							if (pInfo(peer)->platformid == "0,1,1") {
								WindowsAdd - 1;
							}
							if (pInfo(peer)->trading_with != -1) {
								cancel_trade(peer, false);
							}
							if (pInfo(peer)->slave.active == 1) {
								gamepacket_t p;
								p.Insert("OnRemove");
								p.Insert("netID|" + to_string(pInfo(peer)->slave.netID) + "\n");
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->slave.worlds) continue;
									p.CreatePacket(currentPeer);
								}
							}
							char clientConnection[16];
							enet_address_get_host_ip(&peer->address, clientConnection, 16);
							string username = "";
							username = to_lower(pInfo(peer)->tankIDName) + " (" + pInfo(peer)->requestedName + ")";
							dc_warn("[" + currentDateTime() + "] " + username + " has disconnected with IP: " + clientConnection);
							ofstream myfile;
							enet_peer_disconnect_later(peer, 0); // turetu nesuveikti tada antra karta save
							delete peer->data;
							peer->data = NULL;
						}
						else if (cch == "action|quit_to_exit") {
							if (pInfo(peer)->last_exit + 500 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
								pInfo(peer)->last_exit = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
								if (pInfo(peer)->world != "")
									exit_(peer);
								save_player(pInfo(peer), false);
							}
							else {
								pInfo(peer)->exitwarn++;
							}
							if (pInfo(peer)->exitwarn >= 999999999999999) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`4Bye Duper :D");
								p.CreatePacket(peer);
								add_ipban(peer);
								add_ban(peer, 6.307e+7, "DUPER", "System");
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`4SYSTEM : " + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + " `o Has Been `4BANNED `o For Dupeing!. Play Nice,Everybody");
									p.CreatePacket(currentPeer);
								}
							}
						}
						else
						{
							if (pInfo(peer)->world == "") {
								if (cch.find("action|join_request") != string::npos) {
									if (pInfo(peer)->last_world_enter + 500 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
										pInfo(peer)->last_world_enter = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
										vector<string> t_ = explode("|", cch);
										if (t_.size() < 3) break;
										string world_name = explode("\n", t_[2])[0];
										transform(world_name.begin(), world_name.end(), world_name.begin(), ::toupper);
										join_world(peer, world_name);
									}
								}
								else if (cch == "action|gohomeworld\n" && pInfo(peer)->world == "") {
									if (pInfo(peer)->home_world == "") {
										gamepacket_t p, p2;
										p.Insert("OnDialogRequest");
										p.Insert("set_border_color|128,0,128,255\nset_bg_color|128,0,128,170\nset_default_color|`o\nadd_label_with_icon|big|`9No Home World Set ``|left|1432|\nadd_spacer|small|\nadd_textbox|Use /sethome to assign the current world as your home world.|left|\nadd_spacer|small|\nend_dialog||OK||");
										p.CreatePacket(peer);
										p2.Insert("OnFailedToEnterWorld"), p2.CreatePacket(peer);
									}
									else {
										packet_(peer, "action|log\nmsg|Magically warping to home world `5" + pInfo(peer)->home_world + "``...");
										string world_name = pInfo(peer)->home_world;
										join_world(peer, world_name);
									}
								}
								else if (cch.find("action|world_button") != string::npos) {
									vector<string> t_ = explode("|", cch);
									if (t_.size() < 3) break;
									string dialog = explode("\n", t_[2])[0];
									if (dialog == "w1_") world_menu(peer);
									else {
										string c_active_worlds = "";
										if (dialog == "_catselect_") {
											c_active_worlds = pInfo(peer)->worlds_owned.size() != 0 ? "\nadd_heading|Your Worlds|" : "\nadd_heading|You don't have any worlds.<CR>|";
											for (int w_ = 0; w_ < (pInfo(peer)->worlds_owned.size() >= 32 ? 32 : pInfo(peer)->worlds_owned.size()); w_++) c_active_worlds += "\nadd_floater|" + pInfo(peer)->worlds_owned[w_] + "|0|0.38|2147418367";
										}
										else if (dialog == "w2_") c_active_worlds = a + "\nadd_heading|" + (top_list_world_menu.empty() ? "The list should update in few minutes" : "Top Worlds") + "|", c_active_worlds += top_list_world_menu;
										else {
											vector<string> worlds;
											if (dialog == "w3_") {
												c_active_worlds = "\nadd_heading|Information|";
												worlds = { "START", "REC", "RECORD", "LOCKETOWN" };
											}
											else {
												c_active_worlds = "\nadd_heading|Shop|";
												worlds = { "VEND", "SET", "SHOP" };
											}
											for (uint8_t i = 0; i < worlds.size(); i++) c_active_worlds += "\nadd_floater|" + worlds[i] + "|" + to_string((i + 1) * -1) + "|0.38|3417414143";
										}
										gamepacket_t p;
										p.Insert("OnRequestWorldSelectMenu"), p.Insert("add_button|Random Worlds|w1_|0.7|3529161471|\nadd_button|Top Worlds|w2_|0.7|3529161471|\nadd_button|Information|w3_|0.7|3529161471|\nadd_button|Shop<CR>|w4_|0.7|3529161471|" + c_active_worlds), p.CreatePacket(peer);
									}
								}
							}
						}
						break;
					}
					case 4:
					{
						//auto start = chrono::steady_clock::now();
						if (pInfo(peer)->lpps23 + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
							pInfo(peer)->pps23 = 0;
							pInfo(peer)->lpps23 = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
						}
						else {
							pInfo(peer)->pps23++;
							if (pInfo(peer)->pps23 >= 360) {
								cout << "Over packet 4 limit from " << pInfo(peer)->tankIDName << " in world " << pInfo(peer)->world << endl;
								enet_peer_disconnect_later(peer, 0);
								break;
							}
						}
						if (pInfo(peer)->world.empty()) break;
						BYTE* data_ = get_struct(event.packet);
						if (data_ == nullptr) break;
						PlayerMoving* p_ = unpackPlayerMoving(data_);
						//add_packet_logs(" [" + pInfo(peer)->ip + "] (" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + " | World: " + pInfo(peer)->world == "" ? "EXIT" : pInfo(peer)->world + ") " + "[PACKET TYPE]: " + to_string(p_->packetType) + " [NetId]: " + to_string(p_->netID) + " [characterState]: " + to_string(p_->characterState) + " [PlantingTree]: " + to_string(p_->plantingTree) + " [X]: " + to_string(p_->x) + " [Y]: " + to_string(p_->y) + "[PunchX]:" + to_string(p_->punchX) + "[PunchY] : " + to_string(p_->punchY) + "");
						switch (p_->packetType) {
						case 0: /*Kai zaidejas pajuda*/
						{
							loop_cheat(peer);
							if (pInfo(peer)->last_respawn && !pInfo(peer)->world.empty()) {
								SendRespawn(peer, 0, true);
							}
							if (pInfo(peer)->world.empty()) break;
							if ((int)p_->characterState == 268435472 || (int)p_->characterState == 268435488 || (int)p_->characterState == 268435504 || (int)p_->characterState == 268435616 || (int)p_->characterState == 268435632 || (int)p_->characterState == 268435456 || (int)p_->characterState == 224 || (int)p_->characterState == 112 || (int)p_->characterState == 80 || (int)p_->characterState == 96 || (int)p_->characterState == 224 || (int)p_->characterState == 65584 || (int)p_->characterState == 65712 || (int)p_->characterState == 65696 || (int)p_->characterState == 65536 || (int)p_->characterState == 65552 || (int)p_->characterState == 65568 || (int)p_->characterState == 65680 || (int)p_->characterState == 192 || (int)p_->characterState == 65664 || (int)p_->characterState == 65600 || (int)p_->characterState == 67860 || (int)p_->characterState == 64) {
								if (pInfo(peer)->cheat_bounce == 1) break;
								if (pInfo(peer)->lava_time + 5000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
									pInfo(peer)->lavaeffect = 0;
									pInfo(peer)->lava_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
								}
								else {
									if (pInfo(peer)->lavaeffect >= (pInfo(peer)->feet == 250 ? 7 : 3) || pInfo(peer)->lavaeffect >= (pInfo(peer)->necklace == 5426 ? 7 : 3)) {
										pInfo(peer)->lavaeffect = 0;
										SendRespawn(peer, false, 0, true);
									}
									else pInfo(peer)->lavaeffect++;
								}
							}
							{
								if (pInfo(peer)->ignore_cheats2) {//ignore door
									if (pInfo(peer)->ignore_cheatss2 >= 3) {
										pInfo(peer)->ignore_cheats2 = false;
									}
									pInfo(peer)->ignore_cheatss2++;
								}
								else {
									if (!pInfo(peer)->ghost) {
										if (pInfo(peer)->c_x * 32 != (int)p_->x and pInfo(peer)->c_y * 32 != (int)p_->y) {
											if ((int)p_->x / 32 > pInfo(peer)->x / 32 + 4
												|| (int)p_->y / 32 > pInfo(peer)->y / 32 + 4
												|| (int)p_->x / 32 < pInfo(peer)->x / 32 - 4
												|| (int)p_->y / 32 < pInfo(peer)->y / 32 - 4) {
												gamepacket_t p(0, pInfo(peer)->netID);
												p.Insert("OnSetPos");
												p.Insert(pInfo(peer)->x, pInfo(peer)->y);
												p.CreatePacket(peer);
												pInfo(peer)->hack2_++;
												if (pInfo(peer)->hack2_ >= 5 && p_->characterState != 3104) SendRespawn(peer, false, 1);
												break;
											}
										}
									}
								}
							}
							if (pInfo(peer)->fishing_used != 0) {
								if (pInfo(peer)->f_xy != pInfo(peer)->x + pInfo(peer)->y) pInfo(peer)->move_warning++;
								if (pInfo(peer)->move_warning > 1) stop_fishing(peer, true, "Sit still if you wanna fish!");
								if (p_->punchX > 0 && p_->punchY > 0) {
									pInfo(peer)->punch_warning++;
									if (pInfo(peer)->punch_warning >= 2) stop_fishing(peer, false, "");
								}
							}
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								if (pInfo(peer)->x != -1 and pInfo(peer)->y != -1) {
									//try {
									int x_ = (pInfo(peer)->state == 16 ? (int)p_->x / 32 : round((double)p_->x / 32));
									int y_ = (int)p_->y / 32;
									if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) continue;
									WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
									if (block_->fg == 1256) pInfo(peer)->hospital_bed = true;
									else pInfo(peer)->hospital_bed = false;
									if ((pInfo(peer)->c_x * 32 != (int)p_->x or pInfo(peer)->c_y * 32 != (int)p_->y) and not pInfo(peer)->ghost) {
										bool impossible = ar_turi_noclipa2(world_, pInfo(peer)->x, pInfo(peer)->y, x_ + (y_ * 100), peer);
										if (pInfo(peer)->ignore_cheats) {
											if (pInfo(peer)->ignore_cheatss >= 3) {
												pInfo(peer)->ignore_cheats = false;
											}
										}
										if (impossible && !pInfo(peer)->ignore_cheats) {
											if (items[block_->fg].actionType != 31) {
												gamepacket_t p(0, pInfo(peer)->netID);
												p.Insert("SetRespawnPos");
												p.Insert(pInfo(peer)->x, pInfo(peer)->y);
												p.CreatePacket(peer);
												pInfo(peer)->hack_++;
												if (pInfo(peer)->hack_ >= 4) SendRespawn(peer, false, 1);
												break;
											}
										}
									}
									// When player stand on tile
									if (pInfo(peer)->c_x * 32 != (int)p_->x and pInfo(peer)->c_y * 32 != (int)p_->y and not pInfo(peer)->ghost) {
										bool NoClip = patchNoClip(world_, pInfo(peer)->x, pInfo(peer)->y, block_, peer);
										if (NoClip) {
											if (items[block_->fg].actionType != 31 or items[block_->fg].actionType != 32 or items[block_->fg].actionType != 45) {
												gamepacket_t p(0, pInfo(peer)->netID);
												p.Insert("OnSetPos");
												p.Insert(pInfo(peer)->x, pInfo(peer)->y);
												p.CreatePacket(peer);
												pInfo(peer)->flagged++;
												pInfo(peer)->isFlagged = true;
												if (pInfo(peer)->flagged >= 3) {
													respawn_player(peer, 0, true);
												}
												break;
											}
										}
									}
									if (block_->fg == 1508 and not world_->name.empty()) {
										char blarney_world = world_->name.back();
										if (isdigit(blarney_world)) {
											long long current_time = time(nullptr);
											vector<vector<long long>> av_blarneys = pInfo(peer)->completed_blarneys;
											for (int i_ = 0; i_ < av_blarneys.size(); i_++) {
												int t_blarney_world = av_blarneys[i_][0];
												if ((int)blarney_world - 48 == t_blarney_world) {
													long long blarney_time = av_blarneys[i_][1];
													if (blarney_time - current_time <= 0) {
														av_blarneys[i_][1] = current_time + 86400;
														vector<vector<int>> blarney_prizes{
															//11712 11742 11710 11722
															{11712, 1},{11742, 1},{11710, 1},{11722, 1}, {528, 1},{540, 1},{1514, 5},{1544, 1},{260, 1},{1546, 1},{2400, 1},{2404, 1},{2406, 1},{2414, 1},{2416, 1},{2464, 1},{3428, 1},{3426, 1},{4532, 1},{4528, 1},{4526, 5},{4520, 1},{5740, 1},{5734, 1},{7982, 1},{7992, 1},{7994, 1},{7980, 1},{7998, 1},{7984, 3},{7988, 1},{9416, 1},{9424, 1},{10704, 1},{10680, 1},{10670, 1},{10676, 1}
														};
														vector<int> prize_ = blarney_prizes[rand() % blarney_prizes.size()];
														uint32_t give_id = prize_[0];
														uint32_t give_count = prize_[1];
														int c_ = give_count;
														if (modify_inventory(peer, give_id, c_) != 0) {
															WorldDrop drop_block_{};
															drop_block_.id = give_id, drop_block_.count = give_count, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
															dropas_(world_, drop_block_);
														}
														int c_2 = 1;
														if (modify_inventory(peer, 1510, c_2) != 0) {
															WorldDrop drop_block_{};
															drop_block_.id = 1510, drop_block_.count = c_2, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
															dropas_(world_, drop_block_);
														}
														pInfo(peer)->remind_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
														gamepacket_t p;
														p.Insert("OnTalkBubble");
														p.Insert(pInfo(peer)->netID);
														p.Insert("You kissed the " + items[block_->fg].name + " and got a `2" + items[1510].name + "`` and `2" + items[give_id].name + "``");
														p.Insert(1);
														p.CreatePacket(peer);
														{
															gamepacket_t p;
															p.Insert("OnConsoleMessage");
															p.Insert("You kissed the " + items[block_->fg].name + " and got a `2" + items[1510].name + "`` and `2" + items[give_id].name + "``");
															p.CreatePacket(peer);
														}
													}
													else {
														if (pInfo(peer)->remind_time + 8000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
															pInfo(peer)->remind_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
															gamepacket_t p;
															p.Insert("OnTalkBubble");
															p.Insert(pInfo(peer)->netID);
															p.Insert("You will be able to kiss the stone again in " + to_playmod_time(blarney_time - current_time) + "");
															p.Insert(0);
															p.CreatePacket(peer);
														}
													}
													break;
												}
											}
											pInfo(peer)->completed_blarneys = av_blarneys;
										}
									}
									//}
									//catch (out_of_range) { // nuskrido uz worldo
										//cout << "failed to perform anticheat check for player " << pInfo(peer)->tankIDName + " invalid world??" << endl;
									//}
								}
								if (pInfo(peer)->hand == 2286) {
									if (rand() % 100 < 6) {
										pInfo(peer)->geiger_++;
										if (pInfo(peer)->geiger_ >= 100) {
											int c_ = -1;
											modify_inventory(peer, 2286, c_);
											int c_2 = 1;
											modify_inventory(peer, 2204, c_2);
											pInfo(peer)->hand = 2204;
											pInfo(peer)->geiger_ = 0;
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You are detecting radiation... (`$Geiger Counting`` mod added)");
											p.CreatePacket(peer);
											packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
											update_clothes(peer);
										}
									}
								}
								if (pInfo(peer)->gems > 0 && pInfo(peer)->back == 240) {
									if (pInfo(peer)->x != (int)p_->x) {
										if (pInfo(peer)->i240 + 750 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
											pInfo(peer)->i240 = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											pInfo(peer)->gems -= 1;
											WorldDrop item_{};
											item_.id = 112, item_.count = 1, item_.x = (int)p_->x + rand() % 17, item_.y = (int)p_->y + rand() % 17, item_.uid = uint16_t(world_->drop.size()) + 1;
											dropas_(world_, item_);
											gamepacket_t p;
											p.Insert("OnSetBux");
											p.Insert(pInfo(peer)->gems);
											p.Insert(0);
											p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
											if (pInfo(peer)->supp >= 2) {
												p.Insert((float)33796, (float)1, (float)0);
											}
											p.CreatePacket(peer);
										}
									}
								}
								bool jmbd = false;
								if (jmbd && !pInfo(peer)->petsAi.empty() && pInfo(peer)->Pets.equip_pet && pInfo(peer)->Pets.netID != 0) {
									setPlayerPmov(peer,
										pInfo(peer)->Pets.netID,
										0,
										PACKET_STATE,
										pInfo(peer)->state,
										p_->plantingTree,
										p_->punchX,
										p_->punchY,
										0,
										(pInfo(peer)->state == 16 ? ((float)p_->x + 1 * static_cast<float>(32)) : ((float)p_->x - 2 * static_cast<float>(32))) + 16,
										((float)p_->y - (rand() % 2) - 2 * static_cast<float>(32)) + 16,
										(float)p_->XSpeed,
										(float)p_->YSpeed);
								}
								move_(peer, p_);
								if (pInfo(peer)->x == -1 and pInfo(peer)->y == -1) { /*Atnaujinti clothes nes uzejo i worlda*/
									update_clothes(peer);
									uint32_t my_guild_role = -1;
									if (pInfo(peer)->guild_id != 0) {
										uint32_t guild_id = pInfo(peer)->guild_id;
										vector<Guild>::iterator find_guild = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
										if (find_guild != guilds.end()) {
											Guild* guild_information = &guilds[find_guild - guilds.begin()];
											for (GuildMember member_search : guild_information->guild_members) {
												if (member_search.member_name == pInfo(peer)->tankIDName) {
													my_guild_role = member_search.role_id;
													break;
												}
											}
										}
									}//pertama
									gamepacket_t p3(0, pInfo(peer)->netID);
									p3.Insert("OnSetRoleSkinsAndIcons");
									p3.Insert(pInfo(peer)->roleSkin);
									p3.Insert(pInfo(peer)->roleIcon);
									p3.Insert(0);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											uint32_t guild_id = pInfo(peer)->guild_id;
											vector<Guild>::iterator find_guild = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
											if (find_guild != guilds.end()) {
												Guild* guild_information = &guilds[find_guild - guilds.begin()];
												const auto flag1 = (65536 * guild_information->guild_mascot[1] + guild_information->guild_mascot[0]);
												gamepacket_t p(0, pInfo(peer)->netID);
												p.Insert("OnGuildDataChanged");
												p.Insert(50478);
												p.Insert(79289404);
												p.Insert(flag1);
												p.Insert(my_guild_role);
												p.Insert(0);
												/*gamepacket_t p(0, pInfo(peer)->netID);
												p.Insert("OnGuildDataChanged");
												p.Insert(50478);  //guild_information->guild_mascot[1]
												p.Insert(79289404);
												p.Insert(0), p.Insert(my_guild_role);*/


												/*
												gamepacket_t p2(0, pInfo(peer)->netID);
												p2.Insert("OnCountryState");
												p2.Insert(pInfo(peer)->country + "|showGuild");*/
												p3.CreatePacket(currentPeer);
												if (my_guild_role != -1) {
													p.CreatePacket(currentPeer);
													//p2.CreatePacket(currentPeer);
												}
											}
											if (pInfo(currentPeer)->netID != pInfo(peer)->netID) {
												if (pInfo(currentPeer)->roleSkin != 6 or pInfo(currentPeer)->roleIcon != 6) {
													gamepacket_t p_p(0, pInfo(currentPeer)->netID);
													p_p.Insert("OnSetRoleSkinsAndIcons");
													p_p.Insert(pInfo(currentPeer)->roleSkin);
													p_p.Insert(pInfo(currentPeer)->roleIcon);
													p_p.Insert(0);
													p_p.CreatePacket(peer);
												}
											}
											if (pInfo(currentPeer)->netID != pInfo(peer)->netID and pInfo(currentPeer)->guild_id != 0) {
												uint32_t guild_id = pInfo(currentPeer)->guild_id;
												vector<Guild>::iterator find_guild = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
												if (find_guild != guilds.end()) {
													Guild* guild_information = &guilds[find_guild - guilds.begin()];
													uint32_t my_role = 0;
													for (GuildMember member_search : guild_information->guild_members) {
														if (member_search.member_name == pInfo(currentPeer)->tankIDName) {
															my_role = member_search.role_id;
															break;
														}
													}
													gamepacket_t p(0, pInfo(currentPeer)->netID);
													p.Insert("OnGuildDataChanged");
													p.Insert(50478);
													p.Insert(79289404);
													p.Insert(0), p.Insert(my_role);
													p.CreatePacket(peer);
													{
														gamepacket_t p(0, pInfo(currentPeer)->netID);
														p.Insert("OnCountryState");
														p.Insert(pInfo(currentPeer)->country + "|showGuild");
														p.CreatePacket(peer);
													}
												}
											}
										}
									}
									long long ms_time = duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
									map<string, vector<WorldNPC>>::iterator it;
									for (it = active_npc.begin(); it != active_npc.end(); it++) {
										if (it->first == world_->name) {
											for (int i_ = 0; i_ < it->second.size(); i_++) {
												try {
													WorldNPC npc_ = it->second[i_];
													if (npc_.uid == -1) continue;
													double per_sekunde_praeina_bloku = (double)npc_.projectile_speed / 32;
													double praejo_laiko = (double)(ms_time - npc_.started_moving) / 1000;
													double praejo_distancija = (double)per_sekunde_praeina_bloku * (double)praejo_laiko;
													double current_x = ((int)npc_.kryptis == 180 ? (((double)npc_.x - (double)praejo_distancija) * 32) + 16 : (((double)npc_.x + (double)praejo_distancija) * 32) + 16);
													double current_y = (double)npc_.y * 32;
													bool blocked_ = false;
													if ((int)npc_.kryptis == 180) { // check if it wasnt blocked
														vector<int> new_tiles{};
														if (items[world_->blocks[(int)(current_x / 32) + ((int)(current_y / 32) * 100)].fg].collisionType != 1) {
															new_tiles.push_back((int)(current_x / 32) + ((int)(current_y / 32) * 100));
														} int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
														vector<WorldBlock> shadow_copy = world_->blocks;
														for (int i2 = 0; i2 < new_tiles.size(); i2++) {
															int x_ = new_tiles[i2] % 100, y_ = new_tiles[i2] / 100;
															if (x_ < 99 and items[shadow_copy[x_ + 1 + (y_ * 100)].fg].collisionType != 1) {
																if (not shadow_copy[x_ + 1 + (y_ * 100)].scanned) {
																	shadow_copy[x_ + 1 + (y_ * 100)].scanned = true;
																	new_tiles.push_back(x_ + 1 + (y_ * 100));
																}
															}
															else if (items[shadow_copy[x_ + 1 + (y_ * 100)].fg].collisionType == 1 and x_ < npc_.x) {
																blocked_ = true;
																break;
															}
														}
													}
													else {
														vector<int> new_tiles{};
														if (items[world_->blocks[(int)(current_x / 32) + ((int)(current_y / 32) * 100)].fg].collisionType != 1) {
															new_tiles.push_back((int)(current_x / 32) + ((int)(current_y / 32) * 100));
														} int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
														vector<WorldBlock> shadow_copy = world_->blocks;
														for (int i2 = 0; i2 < new_tiles.size(); i2++) {
															int x_ = new_tiles[i2] % 100, y_ = new_tiles[i2] / 100;
															if (x_ < 99 and items[shadow_copy[x_ - 1 + (y_ * 100)].fg].collisionType != 1) {
																if (not shadow_copy[x_ - 1 + (y_ * 100)].scanned) {
																	shadow_copy[x_ - 1 + (y_ * 100)].scanned = true;
																	new_tiles.push_back(x_ - 1 + (y_ * 100));
																}
															}
															else if (items[shadow_copy[x_ - 1 + (y_ * 100)].fg].collisionType == 1 and x_ > npc_.x) {
																blocked_ = true;
																break;
															}
														}
													} if (blocked_) {
														continue;
													}
													PlayerMoving data_{};
													data_.packetType = 34;
													data_.x = (current_x + 16); //nuo x
													data_.y = (current_y + (npc_.id == 8020 ? 6 : 16)); //nuo y
													data_.XSpeed = (current_x + 16); // iki x
													data_.YSpeed = (current_y + (npc_.id == 8020 ? 6 : 16)); // iki y
													data_.punchY = npc_.projectile_speed;
													BYTE* raw = packPlayerMoving(&data_);
													raw[1] = (npc_.id == 8020 ? 15 : 8), raw[2] = npc_.uid, raw[3] = 2;
													memcpy(raw + 40, &npc_.kryptis, 4);
													send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
													delete[] raw;
												}
												catch (out_of_range) {
													continue;
												}
											}
											break;
										}
									}
								}

								pInfo(peer)->x = (int)p_->x, pInfo(peer)->y = (int)p_->y, pInfo(peer)->state = p_->characterState & 0x10;
							}
							move_(peer, p_);
							pInfo(peer)->x = (int)p_->x, pInfo(peer)->y = (int)p_->y, pInfo(peer)->state = p_->characterState & 0x10;
							pInfo(peer)->last_state = p_->characterState;
							if (pInfo(peer)->show_pets and pInfo(peer)->pet_netID != 0) Pet_Ai::Move(peer, p_);
							break;
						}
						case 3: /* tempat player wrench atau place tile atau hit tile */
					{
						if (p_->punchX < 0 || p_->punchY < 0) break;
						if (p_->punchX > 100 || p_->punchY > 60) break;
						if (p_->plantingTree <= 0 || p_->plantingTree >= items.size()) break;
						if ((pInfo(peer)->dev + pInfo(peer)->superdev == 0) && (abs(p_->x / 32 - p_->punchX) > (pInfo(peer)->hand == 11094 ? 6 : 4) || abs(p_->y / 32 - p_->punchY) > (pInfo(peer)->hand == 11094 ? 6 : 4))) break;
						if (p_->plantingTree != 18 and p_->plantingTree != 32) {
							if (pInfo(peer)->Cheat_AF_PlantingTree == 0 and pInfo(peer)->Cheat_AF) {
								if (p_->plantingTree == 5640) pInfo(peer)->isRemote = true;
								pInfo(peer)->Cheat_AF_PunchX = p_->punchX;
								pInfo(peer)->Cheat_AF_PunchY = p_->punchY;
								pInfo(peer)->Cheat_AF_PlantingTree = p_->plantingTree;
								pInfo(peer)->Cheat_AF_isRunning = true;
								if (p_->punchY == pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) pInfo(peer)->isFacingLeft = true;
								}
							}
							int c_ = 0;
							modify_inventory(peer, p_->plantingTree, c_);
							if (c_ == 0) break;
						}
						if (p_->plantingTree == 18) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								{
									ENetPeer* punched_on = get_clicked_on(world_, p_->punchX, p_->punchY);
									if (punched_on != NULL and punched_on != peer) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == pInfo(peer)->world) {
												if (punched_on == currentPeer and currentPeer != peer and pInfo(currentPeer)->PVP_Ongoing and pInfo(peer)->PVP_Enemy == pInfo(currentPeer)->tankIDName and pInfo(currentPeer)->respawn_time + 2500 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
													pInfo(currentPeer)->PVP_Hit--;
													gamepacket_t p;
													p.Insert("OnConsoleMessage");
													p.Insert("`2BATTLE PVP``: " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` lost a live!");
													for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
														if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL or pInfo(currentPeer2)->world != pInfo(peer)->world) continue;
														p.CreatePacket(currentPeer2);
													}
													if (pInfo(currentPeer)->PVP_Hit <= 0) {
														pInfo(currentPeer)->PVP_Hit = 10; pInfo(peer)->PVP_Point++;
														SendRespawn(currentPeer, true, 0, 1);
														gamepacket_t p;
														p.Insert("OnConsoleMessage");
														p.Insert("`2BATTLE PVP``: " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` kills " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` and score a point!");
														for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
															if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL or pInfo(currentPeer2)->world != pInfo(peer)->world) continue;
															p.CreatePacket(currentPeer2);
															packet_(currentPeer2, "action|play_sfx\nfile|audio/getpoint.wav\ndelayMS|0");
														}
													}
												}
											}
										}
									}
								}
								if (pInfo(peer)->punch_time + 100 > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) break;
								pInfo(peer)->punch_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
								if (has_playmod(pInfo(peer), "Infected!")) pInfo(peer)->last_infected = p_->punchX + (p_->punchY * 100);
								pInfo(peer)->last_punched = p_->punchX + (p_->punchY * 100);
							}
						}
						if (pInfo(peer)->trading_with != -1 and p_->packetType != 0 and p_->packetType != 18) {
							cancel_trade(peer, false, true);
							break;
						}
						for (int i = 0; i < itemdb.size(); i++) {
							
							if (p_->plantingTree == 18 and pInfo(peer)->hand + pInfo(peer)->face + pInfo(peer)->feet + pInfo(peer)->hair + pInfo(peer)->mask + pInfo(peer)->pants + pInfo(peer)->shirt + pInfo(peer)->back + pInfo(peer)->ances == itemdb[i].itemid) {
								int faritem = itemdb[i].far_;
								for (int i_ = 0; i_ < faritem; i_++) {
									string name_ = pInfo(peer)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										World* world_ = &worlds[p - worlds.begin()];
										WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
										if (block_->fg == 0 and block_->bg == 0) break;
									}
									if (p_->punchY == pInfo(peer)->y / 32) {
										if (pInfo(peer)->state == 16) {
											//edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - i_, p_->punchY, p_->plantingTree);
										}
										else {
											//edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + i_, p_->punchY, p_->plantingTree);
										}
									}
									else if (p_->punchX == pInfo(peer)->x / 32) {
										if (p_->punchY > pInfo(peer)->y / 32) {
											//edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY + i_, p_->plantingTree);
										}
										if (p_->punchY < pInfo(peer)->y / 32) {
											//edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY - i_, p_->plantingTree);
										}
										else {
											edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										}
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										if (pInfo(peer)->state == 16) {
											//edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - i_, p_->punchY - i_, p_->plantingTree);
										}
										else {
											//edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + i_, p_->punchY - i_, p_->plantingTree);
										}
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										if (pInfo(peer)->state == 16) {
											//edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - i_, p_->punchY - i_, p_->plantingTree);
										}
										else {
										//	edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + i_, p_->punchY - i_, p_->plantingTree);
										}
									}
									else if (p_->punchY > pInfo(peer)->y / 32) {
										if (pInfo(peer)->state == 16) {
											//edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - i_, p_->punchY + i_, p_->plantingTree);
										}
										else {
											//edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + i_, p_->punchY + i_, p_->plantingTree);
										}
									}
								}
							}
						}
						if (p_->plantingTree == 18 and has_playmod(pInfo(peer), "rayman's fist")) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
								if (block_->fg == 0 and block_->bg == 0) break;
							}
							if (p_->punchY == pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchX == pInfo(peer)->x / 32) {
								if (p_->punchY > pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
								}
							}
							else if (p_->punchY > pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
								}
							}
						}
						//10 FAR
						else if (p_->plantingTree == 18 and pInfo(peer)->hand == 9846) {//9846
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
								if (block_->fg == 0 and block_->bg == 0) break;
							}
							if (p_->punchY == pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 7, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 8, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 9, p_->punchY, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 7, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 8, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 9, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchX == pInfo(peer)->x / 32) {
								if (p_->punchY > pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 6, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 7, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 8, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 9, p_->plantingTree);
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 9, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
								}
							}
							else if (p_->punchY > pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY + 6, p_->plantingTree);
									edit_tile(peer, p_->punchX - 7, p_->punchY + 7, p_->plantingTree);
									edit_tile(peer, p_->punchX - 8, p_->punchY + 8, p_->plantingTree);
									edit_tile(peer, p_->punchX - 9, p_->punchY + 9, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY + 6, p_->plantingTree);
									edit_tile(peer, p_->punchX + 7, p_->punchY + 7, p_->plantingTree);
									edit_tile(peer, p_->punchX + 8, p_->punchY + 8, p_->plantingTree);
									edit_tile(peer, p_->punchX + 9, p_->punchY + 9, p_->plantingTree);
								}
							}
						}
						//10 FAR
						else if (p_->plantingTree == 18 and pInfo(peer)->hand == 10126) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
								if (block_->fg == 0 and block_->bg == 0) break;
							}
							if (p_->punchY == pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 7, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 8, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 9, p_->punchY, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 7, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 8, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 9, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchX == pInfo(peer)->x / 32) {
								if (p_->punchY > pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 6, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 7, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 8, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 9, p_->plantingTree);
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 9, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
								}
							}
							else if (p_->punchY > pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY + 6, p_->plantingTree);
									edit_tile(peer, p_->punchX - 7, p_->punchY + 7, p_->plantingTree);
									edit_tile(peer, p_->punchX - 8, p_->punchY + 8, p_->plantingTree);
									edit_tile(peer, p_->punchX - 9, p_->punchY + 9, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY + 6, p_->plantingTree);
									edit_tile(peer, p_->punchX + 7, p_->punchY + 7, p_->plantingTree);
									edit_tile(peer, p_->punchX + 8, p_->punchY + 8, p_->plantingTree);
									edit_tile(peer, p_->punchX + 9, p_->punchY + 9, p_->plantingTree);
								}
							}
							}
							else if (p_->plantingTree == 18 and pInfo(peer)->hand == 2694) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
									if (block_->fg == 0 and block_->bg == 0) break;
								}
								if (p_->punchY == pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchX == pInfo(peer)->x / 32) {
									if (p_->punchY > pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 6, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 7, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 8, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 9, p_->plantingTree);
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
									}
								}
								else if (p_->punchY > pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY + 6, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY + 7, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY + 8, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY + 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY + 6, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY + 7, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY + 8, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY + 9, p_->plantingTree);
									}
								}
								}
						//7 FAR
						else if (p_->plantingTree == 18 and pInfo(peer)->hand == 9906) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
								if (block_->fg == 0 and block_->bg == 0) break;
							}
							if (p_->punchY == pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchX == pInfo(peer)->x / 32) {
								if (p_->punchY > pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 6, p_->plantingTree);
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 6, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
								}
							}
							else if (p_->punchY > pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY + 6, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY + 6, p_->plantingTree);
								}
							}
						}
						//10 FAR
						else if (p_->plantingTree == 18 and pInfo(peer)->hand == 9908) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
								if (block_->fg == 0 and block_->bg == 0) break;
							}
							if (p_->punchY == pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 7, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 8, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 9, p_->punchY, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 7, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 8, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 9, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchX == pInfo(peer)->x / 32) {
								if (p_->punchY > pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 6, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 7, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 8, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 9, p_->plantingTree);
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 9, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
									edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
									edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
									edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
								}
							}
							else if (p_->punchY > pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY + 6, p_->plantingTree);
									edit_tile(peer, p_->punchX - 7, p_->punchY + 7, p_->plantingTree);
									edit_tile(peer, p_->punchX - 8, p_->punchY + 8, p_->plantingTree);
									edit_tile(peer, p_->punchX - 9, p_->punchY + 9, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY + 6, p_->plantingTree);
									edit_tile(peer, p_->punchX + 7, p_->punchY + 7, p_->plantingTree);
									edit_tile(peer, p_->punchX + 8, p_->punchY + 8, p_->plantingTree);
									edit_tile(peer, p_->punchX + 9, p_->punchY + 9, p_->plantingTree);
								}
							}
						}
						//7 FAR
						else if (p_->plantingTree == 18 and pInfo(peer)->hand == 9770) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
								if (block_->fg == 0 and block_->bg == 0) break;
							}
							if (p_->punchY == pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchX == pInfo(peer)->x / 32) {
								if (p_->punchY > pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 6, p_->plantingTree);
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 6, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
								}
							}
							else if (p_->punchY > pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX - 5, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX - 6, p_->punchY + 6, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
									edit_tile(peer, p_->punchX + 5, p_->punchY + 5, p_->plantingTree);
									edit_tile(peer, p_->punchX + 6, p_->punchY + 6, p_->plantingTree);
								}
							}
						}						
						//4 FAR
						else if (p_->plantingTree == 18 and pInfo(peer)->hand == 9772) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
								if (block_->fg == 0 and block_->bg == 0) break;
							}
							if (p_->punchY == pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchX == pInfo(peer)->x / 32) {
								if (p_->punchY > pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
								}
							}
							else if (p_->punchY > pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
								}
							}
						}
						//5 FAR
						else if (p_->plantingTree == 18 and pInfo(peer)->hand == 9918) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
								if (block_->fg == 0 and block_->bg == 0) break;
							}
							if (p_->punchY == pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchX == pInfo(peer)->x / 32) {
								if (p_->punchY > pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
								}
							}
							else if (p_->punchY > pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
								}
							}
						}
						else if (p_->plantingTree == 18 and pInfo(peer)->hand == 10290) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
								if (block_->fg == 0 and block_->bg == 0) break;
							}
							if (p_->punchY == pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchX == pInfo(peer)->x / 32) {
								if (p_->punchY > pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
								}
							}
							else if (p_->punchY > pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
								}
							}
							}
						else if (p_->plantingTree == 18 and pInfo(peer)->hand == 5928) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
								if (block_->fg == 0 and block_->bg == 0) break;
							}
							if (p_->punchY == pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchX == pInfo(peer)->x / 32) {
								if (p_->punchY > pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
								}
							}
							else if (p_->punchY > pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
								}
							}
							}
						else if (p_->plantingTree == 18 and pInfo(peer)->hand == 10362) {
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
								if (block_->fg == 0 and block_->bg == 0) break;
							}
							if (p_->punchY == pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchX == pInfo(peer)->x / 32) {
								if (p_->punchY > pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
								}
							}
							else if (p_->punchY < pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
								}
							}
							else if (p_->punchY > pInfo(peer)->y / 32) {
								if (pInfo(peer)->state == 16) {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
								}
								else {
									edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
									edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
									edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
									edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
								}
							}
							}
						else {
							bool empty = false;
							if (p_->plantingTree == 5640) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									for (int i_ = 0; i_ < world_->machines.size(); i_++) {
										WorldMachines machine = world_->machines[i_];
										if ((machine.x == pInfo(peer)->magnetron_x and machine.y == pInfo(peer)->magnetron_y) and (machine.id == 5638 or machine.id == 5930 or machine.id == 9850 or machine.id == 10266)) {
											if (machine.enabled) {
												WorldBlock* itemas = &world_->blocks[machine.x + (machine.y * 100)];
												if (itemas->magnetron and itemas->id == pInfo(peer)->magnetron_id) {
													if (itemas->pr > 0) {
														p_->plantingTree = itemas->id;
														//5 FAR
														if (pInfo(peer)->hand == 97701) {
															string name_ = pInfo(peer)->world;
															vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
															if (p_->punchY == pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 3, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 4, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 3, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 4, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchX == pInfo(peer)->x / 32) {
																if (p_->punchY > pInfo(peer)->y / 32) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 4, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else if (p_->punchY < pInfo(peer)->y / 32) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 4, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchY < pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 3, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 4, p_->punchY - 4, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 3, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 4, p_->punchY - 4, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchY < pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 3, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 4, p_->punchY - 4, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 3, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 4, p_->punchY - 4, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchY > pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY + 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY + 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 3, p_->punchY + 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 4, p_->punchY + 4, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY + 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY + 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 3, p_->punchY + 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 4, p_->punchY + 4, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
														}
														//4 FAR
														else if (pInfo(peer)->hand == 99181) {
															string name_ = pInfo(peer)->world;
															vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
															if (p_->punchY == pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 3, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 3, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchX == pInfo(peer)->x / 32) {
																if (p_->punchY > pInfo(peer)->y / 32) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 3, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else if (p_->punchY < pInfo(peer)->y / 32) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchY < pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 3, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 3, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchY < pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 3, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 3, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchY > pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY + 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY + 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 3, p_->punchY + 3, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY + 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY + 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 3, p_->punchY + 3, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
														}
														//7 FAR
														else if (pInfo(peer)->hand == 5940) {
															string name_ = pInfo(peer)->world;
															vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
															if (p_->punchY == pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 3, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 4, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 5, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 6, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 3, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 4, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 5, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 6, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchX == pInfo(peer)->x / 32) {
																if (p_->punchY > pInfo(peer)->y / 32) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 4, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 5, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 6, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else if (p_->punchY < pInfo(peer)->y / 32) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 4, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 5, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 6, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchY < pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 3, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 4, p_->punchY - 4, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 5, p_->punchY - 5, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 6, p_->punchY - 6, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 3, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 4, p_->punchY - 4, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 5, p_->punchY - 5, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 6, p_->punchY - 6, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchY < pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 3, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 4, p_->punchY - 4, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 5, p_->punchY - 5, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 6, p_->punchY - 6, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 3, p_->punchY - 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 4, p_->punchY - 4, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 5, p_->punchY - 5, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 6, p_->punchY - 6, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchY > pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY + 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY + 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 3, p_->punchY + 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 4, p_->punchY + 4, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 5, p_->punchY + 5, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 6, p_->punchY + 6, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY + 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY + 2, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 3, p_->punchY + 3, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 4, p_->punchY + 4, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 5, p_->punchY + 5, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 6, p_->punchY + 6, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
														}
														//3 FAR
														else if (pInfo(peer)->hand == 9772) {
															string name_ = pInfo(peer)->world;
															vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
															if (p_->punchY == pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchX == pInfo(peer)->x / 32) {
																if (p_->punchY > pInfo(peer)->y / 32) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY + 2, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else if (p_->punchY < pInfo(peer)->y / 32) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchY < pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchY < pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY - 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY - 2, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
															else if (p_->punchY > pInfo(peer)->y / 32) {
																if (pInfo(peer)->state == 16) {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 1, p_->punchY + 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX - 2, p_->punchY + 2, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
																else {
																	if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 1, p_->punchY + 1, itemas->id, true)) itemas->pr--;
																	if (edit_tile(peer, p_->punchX + 2, p_->punchY + 2, itemas->id, true)) itemas->pr--;
																	if (itemas->pr <= 0) {
																		PlayerMoving data_{};
																		data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																		BYTE* blc = raw + 56;
																		form_visual(blc, *itemas, *world_, NULL, false);
																		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																			if (pInfo(currentPeer)->world == world_->name) {
																				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																			}
																		}
																		delete[] raw, blc;
																	}
																	break;
																}
															}
														}
														else if (edit_tile(peer, p_->punchX, p_->punchY, itemas->id, true)) {
															itemas->pr--;
															if (itemas->pr <= 0) {
																PlayerMoving data_{};
																data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
																BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
																BYTE* blc = raw + 56;
																form_visual(blc, *itemas, *world_, NULL, false);
																for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																	if (pInfo(currentPeer)->world == world_->name) {
																		send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
																	}
																}
																delete[] raw, blc;
															}
															break;
														}
													}
													else {
														empty = true;
														gamepacket_t p;
														p.Insert("OnTalkBubble");
														p.Insert(pInfo(peer)->netID);
														p.Insert("The `2" + items[machine.id].name + "`` is empty!");
														p.Insert(0), p.Insert(0);
														p.CreatePacket(peer);
													}
												}
											}
											break;
										}
									}
								} if (p_->plantingTree == 5640 and not empty) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("There is no active `2Magplants``!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(peer);
								}
								break;
							}
							int adaBrp = 0;//ats
							modify_inventory(peer, p_->plantingTree, adaBrp);
							if (pInfo(peer)->hand == 9918 and adaBrp >= 5) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p_->punchY == pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchX == pInfo(peer)->x / 32) {
									if (p_->punchY > pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									}
								}
								else if (p_->punchY > pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
									}
								}
							}
							if (pInfo(peer)->hand == 10362 and adaBrp >= 5) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p_->punchY == pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchX == pInfo(peer)->x / 32) {
									if (p_->punchY > pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									}
								}
								else if (p_->punchY > pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
									}
								}
							}
							if (pInfo(peer)->hand == 10290 and adaBrp >= 5) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p_->punchY == pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchX == pInfo(peer)->x / 32) {
									if (p_->punchY > pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
									}
								}
								else if (p_->punchY > pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
									}
								}
							}
							else if (pInfo(peer)->hand == 9772 and adaBrp >= 4) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p_->punchY == pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchX == pInfo(peer)->x / 32) {
									if (p_->punchY > pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
									}
								}
								else if (p_->punchY > pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
									}
								}
							}
							else if (pInfo(peer)->hand == 9770 and adaBrp >= 7) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p_->punchY == pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchX == pInfo(peer)->x / 32) {
									if (p_->punchY > pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 6, p_->plantingTree);
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 6, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
									}
								}
								else if (p_->punchY > pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY + 6, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY + 6, p_->plantingTree);
									}
								}
							}
							else if (pInfo(peer)->hand == 9906 and adaBrp >= 7) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p_->punchY == pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchX == pInfo(peer)->x / 32) {
									if (p_->punchY > pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 6, p_->plantingTree);
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 6, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
									}
								}
								else if (p_->punchY > pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY + 6, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY + 6, p_->plantingTree);
									}
								}
							}							
							else if (pInfo(peer)->hand == 9908 and adaBrp >= 10) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p_->punchY == pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchX == pInfo(peer)->x / 32) {
									if (p_->punchY > pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 6, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 7, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 8, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 9, p_->plantingTree);
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
									}
								}
								else if (p_->punchY > pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY + 6, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY + 7, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY + 8, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY + 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY + 6, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY + 7, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY + 8, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY + 9, p_->plantingTree);
									}
								}
							}
							else if (pInfo(peer)->hand == 10126 and adaBrp >= 10) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p_->punchY == pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchX == pInfo(peer)->x / 32) {
									if (p_->punchY > pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 6, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 7, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 8, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 9, p_->plantingTree);
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
									}
								}
								else if (p_->punchY > pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY + 6, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY + 7, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY + 8, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY + 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY + 6, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY + 7, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY + 8, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY + 9, p_->plantingTree);
									}
								}
								}
								else if (pInfo(peer)->hand == 2694 and adaBrp >= 10) {
									string name_ = pInfo(peer)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p_->punchY == pInfo(peer)->y / 32) {
										if (pInfo(peer)->state == 16) {
											edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 5, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 6, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 7, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 8, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 9, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 10, p_->punchY, p_->plantingTree);
										}
										else {
											edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 5, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 6, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 7, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 8, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 9, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 10, p_->punchY, p_->plantingTree);
										}
									}
									else if (p_->punchX == pInfo(peer)->x / 32) {
										if (p_->punchY > pInfo(peer)->y / 32) {
											edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY + 5, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY + 6, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY + 7, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY + 8, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY + 9, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY + 10, p_->plantingTree);
										}
										else if (p_->punchY < pInfo(peer)->y / 32) {
											edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY - 5, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY - 6, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY - 7, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY - 8, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY - 9, p_->plantingTree);
											edit_tile(peer, p_->punchX, p_->punchY - 10, p_->plantingTree);
										}
										else {
											edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										}
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										if (pInfo(peer)->state == 16) {
											edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
											edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
											edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
											edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
											edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
											edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
											edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
											edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
											edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
											edit_tile(peer, p_->punchX - 10, p_->punchY - 10, p_->plantingTree);
										}
										else {
											edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
											edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
											edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
											edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
											edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
											edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
											edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
											edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
											edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
											edit_tile(peer, p_->punchX + 10, p_->punchY - 10, p_->plantingTree);
										}
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										if (pInfo(peer)->state == 16) {
											edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
											edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
											edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
											edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
											edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
											edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
											edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
											edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
											edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
											edit_tile(peer, p_->punchX -10, p_->punchY - 10, p_->plantingTree);
										}
										else {
											edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
											edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
											edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
											edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
											edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
											edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
											edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
											edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
											edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
											edit_tile(peer, p_->punchX + 10, p_->punchY - 10, p_->plantingTree);
										}
									}
									else if (p_->punchY > pInfo(peer)->y / 32) {
										if (pInfo(peer)->state == 16) {
											edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
											edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
											edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
											edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
											edit_tile(peer, p_->punchX - 5, p_->punchY + 5, p_->plantingTree);
											edit_tile(peer, p_->punchX - 6, p_->punchY + 6, p_->plantingTree);
											edit_tile(peer, p_->punchX - 7, p_->punchY + 7, p_->plantingTree);
											edit_tile(peer, p_->punchX - 8, p_->punchY + 8, p_->plantingTree);
											edit_tile(peer, p_->punchX - 9, p_->punchY + 9, p_->plantingTree);
											edit_tile(peer, p_->punchX - 10, p_->punchY + 10, p_->plantingTree);
										}
										else {
											edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
											edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
											edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
											edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
											edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
											edit_tile(peer, p_->punchX + 5, p_->punchY + 5, p_->plantingTree);
											edit_tile(peer, p_->punchX + 6, p_->punchY + 6, p_->plantingTree);
											edit_tile(peer, p_->punchX + 7, p_->punchY + 7, p_->plantingTree);
											edit_tile(peer, p_->punchX + 8, p_->punchY + 8, p_->plantingTree);
											edit_tile(peer, p_->punchX + 9, p_->punchY + 9, p_->plantingTree);
											edit_tile(peer, p_->punchX + 10, p_->punchY + 10, p_->plantingTree);
										}
									}
									}
							 if (pInfo(peer)->hand == 9846555 and adaBrp >= 10) {
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p_->punchY == pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchX == pInfo(peer)->x / 32) {
									if (p_->punchY > pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 6, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 7, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 8, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY + 9, p_->plantingTree);
									}
									else if (p_->punchY < pInfo(peer)->y / 32) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX, p_->punchY - 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
									}
								}
								else if (p_->punchY < pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY - 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY - 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY - 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY - 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY - 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY - 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY - 6, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY - 7, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY - 8, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY - 9, p_->plantingTree);
									}
								}
								else if (p_->punchY > pInfo(peer)->y / 32) {
									if (pInfo(peer)->state == 16) {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX - 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX - 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX - 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX - 4, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX - 5, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX - 6, p_->punchY + 6, p_->plantingTree);
										edit_tile(peer, p_->punchX - 7, p_->punchY + 7, p_->plantingTree);
										edit_tile(peer, p_->punchX - 8, p_->punchY + 8, p_->plantingTree);
										edit_tile(peer, p_->punchX - 9, p_->punchY + 9, p_->plantingTree);
									}
									else {
										edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
										edit_tile(peer, p_->punchX + 1, p_->punchY + 1, p_->plantingTree);
										edit_tile(peer, p_->punchX + 2, p_->punchY + 2, p_->plantingTree);
										edit_tile(peer, p_->punchX + 3, p_->punchY + 3, p_->plantingTree);
										edit_tile(peer, p_->punchX + 4, p_->punchY + 4, p_->plantingTree);
										edit_tile(peer, p_->punchX + 5, p_->punchY + 5, p_->plantingTree);
										edit_tile(peer, p_->punchX + 6, p_->punchY + 6, p_->plantingTree);
										edit_tile(peer, p_->punchX + 7, p_->punchY + 7, p_->plantingTree);
										edit_tile(peer, p_->punchX + 8, p_->punchY + 8, p_->plantingTree);
										edit_tile(peer, p_->punchX + 9, p_->punchY + 9, p_->plantingTree);
									}
								}
							}
							
							else edit_tile(peer, p_->punchX, p_->punchY, p_->plantingTree);
						}
						break;
					}
					case 7: /*Kai zaidejas ieina pro duris arba portal*/ /*2/16/2022 update: cia dar gali buti STEAM USE*/
					{
						try {
							if (p_->punchX < 0 or p_->punchX > 100 or p_->punchY < 0 or p_->punchY >= 60) break;
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								//try {
								WorldBlock* block_ = &world_->blocks[p_->punchX + (p_->punchY * 100)];
								bool impossible = ar_turi_noclipa(world_, pInfo(peer)->x, pInfo(peer)->y, block_, peer);
								if (impossible) break;
								pInfo(peer)->ignore_cheats2 = true;
								if (items[items[block_->fg ? block_->fg : block_->bg].id].blockType == BlockTypes::CHECKPOINT) {
									pInfo(peer)->c_x = p_->punchX, pInfo(peer)->c_y = p_->punchY;
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("SetRespawnPos");
									p.Insert(pInfo(peer)->c_x + (pInfo(peer)->c_y * 100));
									p.CreatePacket(peer);
								}
								bool how = patchNoClip(world_, pInfo(peer)->x, pInfo(peer)->y, block_, peer);
								if (how) break;
								if (items[items[block_->fg ? block_->fg : block_->bg].id].blockType == BlockTypes::CHECKPOINT) {
									pInfo(peer)->c_x = p_->punchX, pInfo(peer)->c_y = p_->punchY;
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("SetRespawnPos");
									p.Insert(pInfo(peer)->c_x + (pInfo(peer)->c_y * 100));
									p.CreatePacket(peer);
								}
								else if (items[block_->fg ? block_->fg : block_->bg].id == 6) exit_(peer);
								else if (block_->fg == 4722 && pInfo(peer)->adventure_begins == false) {
									pInfo(peer)->adventure_begins = true;
									gamepacket_t p(0);
									p.Insert("OnAddNotification"), p.Insert("interface/large/adventure.rttex"), p.Insert(block_->heart_monitor), p.Insert("audio/gong.wav"), p.Insert(0), p.CreatePacket(peer);
								}
								else if (items[block_->fg ? block_->fg : block_->bg].id == 6) exit_(peer);
								else if (items[block_->fg].blockType == BlockTypes::DOOR or items[block_->fg].blockType == BlockTypes::PORTAL) {
									string door_target = block_->door_destination, door_id = "";
									World target_world = worlds[p - worlds.begin()];
									bool locked = (block_->open ? false : (target_world.owner_name == pInfo(peer)->tankIDName or pInfo(peer)->dev or target_world.open_to_public or target_world.owner_name.empty() or (guild_access(peer, target_world.guild_id) or find(target_world.admins.begin(), target_world.admins.end(), pInfo(peer)->tankIDName) != target_world.admins.end()) ? false : true));
									int spawn_x = 0, spawn_y = 0;
									if (not locked && block_->fg != 762) {
										if (door_target.find(":") != string::npos) {
											vector<string> detales = explode(":", door_target);
											door_target = detales[0], door_id = detales[1];
										} if (not door_target.empty() and door_target != world_->name) {
											if (not check_name(door_target)) {
												gamepacket_t p(250, pInfo(peer)->netID);
												p.Insert("OnSetFreezeState");
												p.Insert(1);
												p.CreatePacket(peer);
												{
													gamepacket_t p(250);
													p.Insert("OnConsoleMessage");
													p.Insert(door_target);
													p.CreatePacket(peer);
												}
												{
													gamepacket_t p(250);
													p.Insert("OnZoomCamera");
													p.Insert((float)10000.000000);
													p.Insert(1000);
													p.CreatePacket(peer);
												}
												{
													gamepacket_t p(250, pInfo(peer)->netID);
													p.Insert("OnSetFreezeState");
													p.Insert(0);
													p.CreatePacket(peer);
												}
												break;
											}
											target_world = get_world(door_target);
										}
										int ySize = (int)target_world.blocks.size() / 100, xSize = (int)target_world.blocks.size() / ySize, square = (int)target_world.blocks.size();
										if (not door_id.empty()) {
											for (int i_ = 0; i_ < target_world.blocks.size(); i_++) {
												WorldBlock block_data = target_world.blocks[i_];
												if (block_data.fg == 1684 or items[block_data.fg].blockType == BlockTypes::DOOR or items[block_data.fg].blockType == BlockTypes::PORTAL) {
													if (block_data.door_id == door_id) {
														spawn_x = i_ % xSize, spawn_y = i_ / xSize;
														break;
													}
												}
											}
										}
									}
									if (block_->fg == 762) {
										pInfo(peer)->lastwrenchx = p_->punchX, pInfo(peer)->lastwrenchy = p_->punchY;
										gamepacket_t p2;
										if (block_->door_id == "") p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("No password has been set yet!"), p2.Insert(0), p2.Insert(1);
										else p2.Insert("OnDialogRequest"), p2.Insert("set_default_color|`o\nadd_label_with_icon|big|`wPassword Door``|left|762|\nadd_textbox|The door requires a password.|left|\nadd_text_input|password|Password||24|\nend_dialog|password_reply|Cancel|OK|");
										p2.CreatePacket(peer);
										gamepacket_t p(250, pInfo(peer)->netID), p3(250), p4(250, pInfo(peer)->netID);
										p.Insert("OnSetFreezeState"), p.Insert(1), p.CreatePacket(peer);
										p3.Insert("OnZoomCamera"), p3.Insert((float)10000.000000), p3.Insert(1000), p3.CreatePacket(peer);
										p4.Insert("OnSetFreezeState"), p4.Insert(0), p4.CreatePacket(peer);
									}
									if (block_->fg != 762) join_world(peer, target_world.name, spawn_x, spawn_y, 250, locked, true);
								}
								else {
									switch (block_->fg) {
									case 3270: case 3496:
									{
										Position2D steam_connector = track_steam(world_, block_, p_->punchX, p_->punchY);
										if (steam_connector.x != -1 and steam_connector.y != -1) {
											WorldBlock* block_s = &world_->blocks[steam_connector.x + (steam_connector.y * 100)];
											switch (block_s->fg) {
											case 3286: //steam door
											{
												block_s->flags = (block_s->flags & 0x00400000 ? block_s->flags ^ 0x00400000 : block_s->flags | 0x00400000);
												PlayerMoving data_{};
												data_.packetType = 5, data_.punchX = steam_connector.x, data_.punchY = steam_connector.y, data_.characterState = 0x8;
												BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_s));
												BYTE* blc = raw + 56;
												form_visual(blc, *block_s, *world_, peer, false);
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
													if (pInfo(currentPeer)->world == world_->name) {
														send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_s), ENET_PACKET_FLAG_RELIABLE);
													}
												}
												delete[] raw, blc;
												break;
											}
											case 3724: // spirit storage unit
											{
												uint32_t scenario = 20;
												{
													// check for ghost jars
													for (int i = 0; i < world_->drop.size(); i++) {
														WorldDrop* check_drop = &world_->drop[i];
														Position2D dropped_at{ check_drop->x / 32, check_drop->y / 32 };
														if (dropped_at.x == steam_connector.x and dropped_at.y == steam_connector.y) {
															if (check_drop->id == 3722) {
																uint32_t explo_chance = check_drop->count;
																// remove drop
																{
																	PlayerMoving data_{};
																	data_.packetType = 14, data_.netID = -2, data_.plantingTree = check_drop->uid;
																	BYTE* raw = packPlayerMoving(&data_);
																	int32_t item = -1;
																	memcpy(raw + 8, &item, 4);
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																		if (pInfo(currentPeer)->world == name_) {
																			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
																		}
																	}
																	world_->drop[i].id = 0, world_->drop[i].x = -1, world_->drop[i].y = -1;
																	delete[] raw;
																}
																block_s->c_ += explo_chance;
																// explode or not
																{
																	if (block_s->c_ * 5 >= 105) {
																		float explosion_chance = (float)((block_s->c_ * 5) - 100) * 0.5;
																		if (explosion_chance > rand() % 100) {
																			//bam bam
																			block_s->fg = 3726;
																			// drop the prize
																			{
																				vector<int> all_p{ 3734, 3732, 3748, 3712, 3706, 3708, 3718, 11136, 3728, 10056, 3730, 3788, 3750, 3738, 6060, 3738, 6840, 3736, 3750 };
																				uint32_t prize = 0;
																				if (block_s->c_ * 5 <= 115) prize = 3734;
																				else if (block_s->c_ * 5 <= 130) prize = 3732;
																				else if (block_s->c_ * 5 <= 140) prize = 3748;
																				else if (block_s->c_ * 5 <= 170) {
																					vector<int> p_drops = {
																						3712, 3706, 3708, 3718, 11136
																					};
																					prize = p_drops[rand() % p_drops.size()];
																				}
																				else if (block_s->c_ * 5 <= 190)  prize = 3728;
																				else if (block_s->c_ * 5 <= 205)  prize = 10056;
																				else if (block_s->c_ * 5 <= 220)  prize = 3730;
																				else if (block_s->c_ * 5 == 225)  prize = 3788;
																				else if (block_s->c_ * 5 <= 240)  prize = 3750;
																				else if (block_s->c_ * 5 == 245)  prize = 3738;
																				else if (block_s->c_ * 5 <= 255)  prize = 6060;
																				else if (block_s->c_ * 5 <= 265 or explo_chance * 5 >= 265) {
																					if (explo_chance * 5 >= 265) prize = all_p[rand() % all_p.size()];
																					else prize = 3738;
																				}
																				else {
																					vector<int> p_drops = {
																						6840
																					};
																					if (block_s->c_ * 5 >= 270) p_drops.push_back(3736);
																					if (block_s->c_ * 5 >= 295) p_drops.push_back(3750);
																					prize = p_drops[rand() % p_drops.size()];
																				} if (prize != 0) {
																					WorldDrop drop_block_{};
																					drop_block_.x = steam_connector.x * 32 + rand() % 17;
																					drop_block_.y = steam_connector.y * 32 + rand() % 17;
																					drop_block_.id = prize, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
																					dropas_(world_, drop_block_);
																					{
																						PlayerMoving data_{};
																						data_.packetType = 0x11, data_.x = steam_connector.x * 32 + 16, data_.y = steam_connector.y * 32 + 16;
																						data_.YSpeed = 97, data_.XSpeed = 3724;
																						BYTE* raw = packPlayerMoving(&data_);
																						PlayerMoving data_2{};
																						data_2.packetType = 0x11, data_2.x = steam_connector.x * 32 + 16, data_2.y = steam_connector.y * 32 + 16;
																						data_2.YSpeed = 108;
																						BYTE* raw2 = packPlayerMoving(&data_2);
																						gamepacket_t p;
																						p.Insert("OnConsoleMessage");
																						p.Insert("`#[A `9Spirit Storage Unit`` exploded, bringing forth an `9" + items[prize].name + "`` from The Other Side!]``");
																						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																							if (pInfo(currentPeer)->world == world_->name) {
																								p.CreatePacket(currentPeer);
																								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
																								send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
																							}
																						}
																						delete[] raw, raw2;
																					}
																					scenario = 22;
																				}
																			}
																			block_s->c_ = 0;
																		}
																	}
																}
																// update visuals
																{
																	PlayerMoving data_{};
																	data_.packetType = 5, data_.punchX = steam_connector.x, data_.punchY = steam_connector.y, data_.characterState = 0x8;
																	BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_s));
																	BYTE* blc = raw + 56;
																	form_visual(blc, *block_s, *world_, peer, false);
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																		if (pInfo(currentPeer)->world == world_->name) {
																			send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_s), ENET_PACKET_FLAG_RELIABLE);
																		}
																	}
																	delete[] raw, blc;
																}
																break;
															}
														}
													}
												}
												PlayerMoving data_{};
												data_.packetType = 32; // steam update paketas
												data_.punchX = steam_connector.x;
												data_.punchY = steam_connector.y;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = scenario;
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
													if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
													send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												}
												delete[] raw;
												break;
											}
											default:
												break;
											}
										}
										PlayerMoving data_{};
										data_.packetType = 32; // steam update paketas
										data_.punchX = p_->punchX;
										data_.punchY = p_->punchY;
										BYTE* raw = packPlayerMoving(&data_);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
										delete[] raw;
										break;
									}
									default:
										break;
									}
								}
							}
						}
							catch (const out_of_range& e) {
								xItsCrims_warn(e.what());
							}
							break;
						}
						case 10: /*Kai zaidejas paspaudzia du kartus ant inventory itemo*/
						{
							if (pInfo(peer)->trading_with != -1) {
								cancel_trade(peer, false);
								break;
							}
							if (p_->plantingTree <= 0 or p_->plantingTree >= items.size()) break;
							int c_ = 0;
							modify_inventory(peer, p_->plantingTree, c_);
							if (c_ == 0) break;
							if (items[p_->plantingTree].blockType != BlockTypes::CLOTHING) {
								int free = get_free_slots(pInfo(peer)), slot = 1;
								int c242 = 242, c1796 = 1796, c6802 = 6802, c1486 = 1486, c8470 = 8470, c5260 = 5260, countofused = 0, getdl = 1, getwl = 100, removewl = -100, removedl = -1, countwl = 0;
								int c4298 = 4298, c4300 = 4300;
								int c10014 = 10014, c10002 = 10002;
								int c7188 = 7188;
								modify_inventory(peer, p_->plantingTree, countofused);
								if (free >= slot) {
									if (p_->plantingTree == 242 || p_->plantingTree == 1796) {
										modify_inventory(peer, p_->plantingTree == 242 ? c1796 : c242, countwl);
										if (p_->plantingTree == 242 ? countwl <= 199 : countwl <= 100) {
											if (p_->plantingTree == 242 ? countofused >= 100 : countofused >= 1) {
												modify_inventory(peer, p_->plantingTree == 242 ? c242 : c1796, p_->plantingTree == 242 ? removewl : removedl);
												modify_inventory(peer, p_->plantingTree == 242 ? c1796 : c242, p_->plantingTree == 242 ? getdl : getwl);
												gamepacket_t p, p2;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(p_->plantingTree == 242 ? "You compressed 100 `2World Lock`` into a `2Diamond Lock``!" : "You shattered a `2Diamond Lock`` into 100 `2World Lock``!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
												p2.Insert("OnConsoleMessage"), p2.Insert(p_->plantingTree == 242 ? "You compressed 100 `2World Lock`` into a `2Diamond Lock``!" : "You shattered a `2Diamond Lock`` into 100 `2World Lock``!"), p2.CreatePacket(peer);
											}
										}
									}
									else if (p_->plantingTree == 7188) {
										modify_inventory(peer, c1796, countwl);
										if (countwl <= 100) {
											if (countofused >= 1) {
												modify_inventory(peer, c7188, removedl);
												modify_inventory(peer, c1796, getwl);
												gamepacket_t p, p2;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You shattered a `2Blue Gem Lock`` into 100 `2Diamond Lock``!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
												p2.Insert("OnConsoleMessage"), p2.Insert("You shattered a `2Blue Gem Lock`` into 100 `2Diamond Lock``!"), p2.CreatePacket(peer);
											}
										}
									}
									else if (p_->plantingTree == 1486 || p_->plantingTree == 6802) {
										modify_inventory(peer, p_->plantingTree == 1486 ? c6802 : c1486, countwl);
										if (p_->plantingTree == 1486 ? countwl <= 199 : countwl <= 100) {
											if (p_->plantingTree == 1486 ? countofused >= 100 : countofused >= 1) {
												modify_inventory(peer, p_->plantingTree == 1486 ? c1486 : c6802, p_->plantingTree == 1486 ? removewl : removedl);
												modify_inventory(peer, p_->plantingTree == 1486 ? c6802 : c1486, p_->plantingTree == 1486 ? getdl : getwl);
												gamepacket_t p, p2;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(p_->plantingTree == 1486 ? "You compressed 100 `2Growtoken`` into a `2Mega Growtoken``!" : "You shattered a `2Mega Growtoken`` into 100 `2Growtoken``!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
												p2.Insert("OnConsoleMessage"), p2.Insert(p_->plantingTree == 1486 ? "You compressed 100 `2Growtoken`` into a `2Mega Growtoken``!" : "You shattered a `2Mega Growtoken`` into 100 `2Growtoken``!"), p2.CreatePacket(peer);
											}
										}
									}
									else if (p_->plantingTree == 4298 || p_->plantingTree == 4300) {
										modify_inventory(peer, p_->plantingTree == 4298 ? c4300 : c4298, countwl);
										if (p_->plantingTree == 4298 ? countwl <= 199 : countwl <= 100) {
											if (p_->plantingTree == 4298 ? countofused >= 100 : countofused >= 1) {
												modify_inventory(peer, p_->plantingTree == 4298 ? c4298 : c4300, p_->plantingTree == 4298 ? removewl : removedl);
												modify_inventory(peer, p_->plantingTree == 4298 ? c4300 : c4298, p_->plantingTree == 4298 ? getdl : getwl);
												gamepacket_t p, p2;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(p_->plantingTree == 4298 ? "You compressed 100 `2Caduceus`` into a `2Golden Caduceus``!" : "You shattered a `2Golden Caduceus`` into 100 `2Caduceus``!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
												p2.Insert("OnConsoleMessage"), p2.Insert(p_->plantingTree == 4298 ? "You compressed 100 `2Caduceus`` into a `2Golden Caduceus``!" : "You shattered a `2Golden Caduceus`` into 100 `2Caduceus``!"), p2.CreatePacket(peer);
											}
										}
									}
								}
								/*compress ir t.t*/
								break;
							}
							/*equip*/
							equip_clothes(peer, p_->plantingTree);
							break;
						}
						case 11: /*Saat pemain mengambil item yang dijatuhkan*/
						{
							if (p_->x < 0 || p_->y <0) break;
							bool displaybox = true;
							string name_ = pInfo(peer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								for (int i_ = 0; i_ < world_->drop.size(); i_++) {
									if (world_->drop[i_].id == 0 or world_->drop[i_].x/32 < 0 or world_->drop[i_].x/32 > 99 or world_->drop[i_].y / 32 < 0 or world_->drop[i_].y / 32 > 59) continue;
									WorldBlock* block_ = &world_->blocks[world_->drop[i_].x / 32 + (world_->drop[i_].y / 32 * 100)];
									if (world_->drop[i_].uid == p_->plantingTree) {
										if (block_->fg == 1422 || block_->fg == 2488) {
											displaybox = false;
											if (pInfo(peer)->coown || world_->open_to_public || world_->owner_name == "" || world_->owner_name == pInfo(peer)->tankIDName || find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) != world_->admins.end()) displaybox = true;
										}
										if (abs((int)p_->x / 32 - world_->drop[i_].x / 32) > 1 || abs((int)p_->x - world_->drop[i_].x) >= 32 or abs((int)p_->y - world_->drop[i_].y) >= 32) displaybox = false;
										bool noclip = false;
										if (pInfo(peer)->coown || pInfo(peer)->coown || world_->owner_name == pInfo(peer)->tankIDName) {
											if (pInfo(peer)->coown || world_->open_to_public || world_->owner_name == "" || world_->owner_name == pInfo(peer)->tankIDName || find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) != world_->admins.end()) displaybox = true;
										}
										else {
											noclip = ar_turi_noclipa2(world_, p_->x, p_->y, world_->drop[i_].x / 32 + (world_->drop[i_].y / 32 * 100), peer);
											if (noclip) {
												pInfo(peer)->hack_++;
												if (pInfo(peer)->hack_ >= 3) {
													enet_peer_disconnect_later(peer, 0);
												}
											}
										}
										if (abs((int)p_->x / 32 - world_->drop[i_].x / 32) > 1 || abs((int)p_->x - world_->drop[i_].x) >= 32 or abs((int)p_->y - world_->drop[i_].y) >= 32) displaybox = false;
										if (displaybox && ar_turi_noclipa(world_, p_->x, p_->y, block_, peer) == false) {
											int c_ = world_->drop[i_].count;
											if (world_->drop[i_].id == world_->special_event_item && world_->special_event && world_->drop[i_].special) {
												world_->special_event_item_taken++;
												if (items[world_->special_event_item].event_total == world_->special_event_item_taken) {
													gamepacket_t p, p3;
													p.Insert("OnAddNotification"), p.Insert("interface/large/special_event.rttex"), p.Insert("`2" + items[world_->special_event_item].event_name + ":`` `oSuccess! " + (items[world_->special_event_item].event_total == 1 ? "`2" + pInfo(peer)->tankIDName + "`` found it!``" : "All items found!``") + ""), p.Insert("audio/cumbia_horns.wav"), p.Insert(0);
													p3.Insert("OnConsoleMessage"), p3.Insert("`2" + items[world_->special_event_item].event_name + ":`` `oSuccess!`` " + (items[world_->special_event_item].event_total == 1 ? "`2" + pInfo(peer)->tankIDName + "`` `ofound it!``" : "All items found!``") + "");
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
														if (items[world_->special_event_item].event_total != 1) {
															gamepacket_t p2;
															p2.Insert("OnConsoleMessage"), p2.Insert("`2" + items[world_->special_event_item].event_name + ":`` `0" + pInfo(peer)->tankIDName + "`` found a " + items[world_->special_event_item].name + "! (" + to_string(world_->special_event_item_taken) + "/" + to_string(items[world_->special_event_item].event_total) + ")``"), p2.CreatePacket(currentPeer);
														}
														p.CreatePacket(currentPeer);
														p3.CreatePacket(currentPeer);
													}
													world_->last_special_event = 0, world_->special_event_item = 0, world_->special_event_item_taken = 0, world_->special_event = false;
												}
												else {
													gamepacket_t p2;
													p2.Insert("OnConsoleMessage"), p2.Insert("`2" + items[world_->special_event_item].event_name + ":`` `0" + pInfo(peer)->tankIDName + "`` found a " + items[world_->special_event_item].name + "! (" + to_string(world_->special_event_item_taken) + "/" + to_string(items[world_->special_event_item].event_total) + ")``");
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
														p2.CreatePacket(currentPeer);
													}
												}
											}
											if (modify_inventory(peer, world_->drop[i_].id, c_, false, true) == 0 or world_->drop[i_].id == 112) {
												PlayerMoving data_{};
												data_.effect_flags_check = 1, data_.packetType = 14, data_.netID = pInfo(peer)->netID, data_.plantingTree = world_->drop[i_].uid;
												BYTE* raw = packPlayerMoving(&data_);
												if (world_->drop[i_].id == 112) pInfo(peer)->gems += c_;
												else {//`9[PATROL] `0ItsKyy `ocollected `0Pinata Whistle `o199x in `9TEST`o.
													add_cctv(peer, "took", to_string(world_->drop[i_].count) + " " + items[world_->drop[i_].id].name);
													collect("Nick : " + pInfo(peer)->tankIDName + " collected " + items[world_->drop[i_].id].name + " " + to_string(world_->drop[i_].count) + "x in World : " + pInfo(peer)->world + ".");
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->ispatrol == false) continue;
														gamepacket_t p4;
														p4.Insert("OnConsoleMessage");
														p4.Insert("`9[PATROL] `0" + pInfo(peer)->tankIDName + " `ocollected `0" + items[world_->drop[i_].id].name + " `o" + to_string(world_->drop[i_].count) + "x in `9" + pInfo(peer)->world + "`o.");
														p4.CreatePacket(currentPeer);
													}
													gamepacket_t p;
													p.Insert("OnConsoleMessage"), p.Insert("Collected `w" + to_string(world_->drop[i_].count) + "" + (items[world_->drop[i_].id].blockType == BlockTypes::FISH ? "lb." : "") + " " + items[world_->drop[i_].id].ori_name + "``." + (items[world_->drop[i_].id].rarity > 363 ? "" : " Rarity: `w" + to_string(items[world_->drop[i_].id].rarity) + "``") + ""), p.CreatePacket(peer);
												}
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
													send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												}
												delete[]raw;
												world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
											}
											else {
												if (c_ < 200 and world_->drop[i_].count >(200 - c_)) {
													int b_ = 200 - c_;
													world_->drop[i_].count -= b_;
													if (modify_inventory(peer, world_->drop[i_].id, b_, false) == 0) {
														add_cctv(peer, "took", to_string(world_->drop[i_].count) + " " + items[world_->drop[i_].id].name);
														collect("Nick : " + pInfo(peer)->tankIDName + " collected " + items[world_->drop[i_].id].name + " " + to_string(world_->drop[i_].count) + "x in World : " + pInfo(peer)->world + ".");
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->ispatrol == false) continue;
															gamepacket_t p2;
															p2.Insert("OnConsoleMessage");
															p2.Insert("`9[PATROL] `0" + pInfo(peer)->tankIDName + " `ocollected `0" + items[world_->drop[i_].id].name + " `o" + to_string(world_->drop[i_].count) + "x in `9" + pInfo(peer)->world + "`o.");
															p2.CreatePacket(currentPeer);
														}
														WorldDrop drop_{};
														drop_.id = world_->drop[i_].id, drop_.count = world_->drop[i_].count, drop_.uid = uint16_t(world_->drop.size()) + 1, drop_.x = world_->drop[i_].x, drop_.y = world_->drop[i_].y;
														world_->drop.push_back(drop_);
														gamepacket_t p;
														p.Insert("OnConsoleMessage");
														p.Insert("Collected `w" + to_string(250 - c_) + " " + items[world_->drop[i_].id].ori_name + "``." + (items[world_->drop[i_].id].rarity > 363 ? "" : " Rarity: `w" + to_string(items[world_->drop[i_].id].rarity) + "``") + "");
														PlayerMoving data_{};
														data_.packetType = 14, data_.netID = -1, data_.plantingTree = world_->drop[i_].id, data_.x = world_->drop[i_].x, data_.y = world_->drop[i_].y;
														int32_t item = -1;
														float val = world_->drop[i_].count;
														BYTE* raw = packPlayerMoving(&data_);
														data_.plantingTree = world_->drop[i_].id;
														memcpy(raw + 8, &item, 4);
														memcpy(raw + 16, &val, 4);
														val = 0;
														data_.netID = pInfo(peer)->netID;
														data_.plantingTree = world_->drop[i_].uid;
														data_.x = 0, data_.y = 0;
														BYTE* raw2 = packPlayerMoving(&data_);
														BYTE val2 = 0;
														memcpy(raw2 + 8, &item, 4);
														memcpy(raw2 + 16, &val, 4);
														memcpy(raw2 + 1, &val2, 1);
														world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
																send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
																if (pInfo(currentPeer)->netID == pInfo(peer)->netID)
																	p.CreatePacket(currentPeer);
																send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
														}
														delete[]raw, raw2;
													}
												}
											}
										}
									}
								}
							}
							break;
						}
						case 18: { //chat bubble kai raso
							move_(peer, p_);
							break;
						}
						case 23: /*Kai zaidejas papunchina kita*/
						{
							if (pInfo(peer)->last_inf + 5000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
								pInfo(peer)->last_inf = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
								string name_ = pInfo(peer)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									bool can_cancel = true;
									if (find(world_->active_jammers.begin(), world_->active_jammers.end(), 1276) != world_->active_jammers.end()) can_cancel = false;
									if (can_cancel) {
										if (pInfo(peer)->trading_with != -1 and p_->packetType != 0 and p_->packetType != 18) {
											cancel_trade(peer, false, true);
											break;
										}
									}
								}
							}
							break;
						}
						default:
						{
								break;
						}
						}
						break;
					}
					default:
						break;
					}
					enet_event_destroy(event);
					break;
				}
				case ENET_EVENT_TYPE_DISCONNECT:
				{
					if (saving_) break;
					if (peer->data != NULL) {
						if (pInfo(peer)->trading_with != -1) cancel_trade(peer, false);
						if (not pInfo(peer)->world.empty()) exit_(peer, true);
						if (not pInfo(peer)->invalid_data) {
							save_player(pInfo(peer), (f_saving_ ? false : true));
						}
						if (f_saving_) pInfo(peer)->saved_on_close = true;
						if (not f_saving_) {
							enet_host_flush(server);
							delete peer->data;
							peer->data = NULL;
						}
					}
					break;
				}
				default:
					break;
				}
		}
	}
	return 0;
}